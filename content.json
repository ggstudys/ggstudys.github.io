{"meta":{"title":"小日的博客","subtitle":null,"description":null,"author":"XiaoRI","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-08-15T03:39:10.000Z","updated":"2018-08-15T03:40:45.631Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"##关于我！！！ 一个学习前端的小菜鸟~ Email：1554019387@qq.com"},{"title":"pagetest","date":"2018-07-21T03:50:30.000Z","updated":"2018-07-21T04:10:20.807Z","comments":true,"path":"pagetest/index.html","permalink":"http://yoursite.com/pagetest/index.html","excerpt":"","text":"使用HEXO的page模板显示引言我其实也不知道是什么样子，就是用来测试一下page模板，基本语法还是一致 还有补充一下现在头脑里充满的全是迷惑！ 这个文件就是问了测试看page模板的显示效果。别无其他用处~"},{"title":"tags","date":"2018-08-15T03:37:10.000Z","updated":"2018-08-15T03:38:01.693Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JS进阶系列之作用域","slug":"JS进阶系列之作用域","date":"2018-11-10T06:34:38.000Z","updated":"2018-11-12T06:37:25.159Z","comments":true,"path":"2018/11/10/JS进阶系列之作用域/","link":"","permalink":"http://yoursite.com/2018/11/10/JS进阶系列之作用域/","excerpt":"","text":"引言作用域是JavaScript最重要的概念之一，想要学好JavaScript就需要理解JavaScript作用域和作用域链的工作原理。今天这篇文章对JavaScript作用域和作用域链作简单的介绍，希望能帮助大家更好的学习JavaScript。 JavaScript作用域 任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。 1. 全局作用域（Global Scope） 在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域： （1）最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如： （2）所有末定义直接赋值的变量自动声明为拥有全局作用域，例如： 变量blogName拥有全局作用域，而authorName在函数外部无法访问到。 （3）所有window对象的属性拥有全局作用域 一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。 1. 局部作用域（Local Scope） 和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域，例如下列代码中的blogName和函数innerSay都只拥有局部作用域。 作用域链（Scope Chain） 在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。 当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。例如定义下面这样一个函数： 在函数add创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量，如下图所示（注意：图片只例举了全部变量中的一部分）： 函数add的作用域将会在执行时用到。例如执行如下代码： 执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。 这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。新的作用域链如下图所示： 在函数执行过程中，没遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。 作用域链和代码优化 从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。如上图所示，因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。例如下面的代码： 这个函数引用了两次全局变量document，查找该变量必须遍历整个作用域链，直到最后在全局对象中才能找到。这段代码可以重写如下： 这段代码比较简单，重写后不会显示出巨大的性能提升，但是如果程序中有大量的全局变量被从反复访问，那么重写后的代码性能会有显著改善。 改变作用域链 函数每次执行时对应的运行期上下文都是独一无二的，所以多次调用同一个函数就会导致创建多个运行期上下文，当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联。一般情况下，在运行期上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响。 with语句是对象的快捷应用方式，用来避免书写重复代码。例如： 这里使用width语句来避免多次书写document，看上去更高效，实际上产生了性能问题。 当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。如下图所示： 因此在程序中应避免使用with语句，在这个例子中，只要简单的把document存储在一个局部变量中就可以提升性能。 另外一个会改变作用域链的是try-catch语句中的catch语句。当try代码块中发生错误时，执行过程会跳转到catch语句，然后把异常对象推入一个可变对象并置于作用域的头部。在catch代码块内部，函数的所有局部变量将会被放在第二个作用域链对象中。示例代码： 请注意，一旦catch语句执行完毕，作用域链机会返回到之前的状态。try-catch语句在代码调试和异常处理中非常有用，因此不建议完全避免。你可以通过优化代码来减少catch语句对性能的影响。一个很好的模式是将错误委托给一个函数处理，例如： 优化后的代码，handleError方法是catch子句中唯一执行的代码。该函数接收异常对象作为参数，这样你可以更加灵活和统一的处理错误。由于只执行一条语句，且没有局部变量的访问，作用域链的临时改变就不会影响代码性能了。 注：博客转载自https://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JS进阶系列只内存泄漏","slug":"JS进阶系列之内存泄漏","date":"2018-11-09T03:56:35.000Z","updated":"2018-11-09T04:05:01.408Z","comments":true,"path":"2018/11/09/JS进阶系列之内存泄漏/","link":"","permalink":"http://yoursite.com/2018/11/09/JS进阶系列之内存泄漏/","excerpt":"","text":"引言也许很多人像我一样，觉得JS有垃圾回收机制，内存就可以不管了，以至于在全局作用域下定义了很多变量，自以为JS会自动回收，直到最近，看了阮一峰老师，关于javascript内存泄漏的文章时，才发现自己写的代码，存在很严重的内存泄漏问题，再者，因为忽略对内存的学习，导致后面很多进阶概念很模糊，比如深复制与浅复制的区别，比如闭包、作用域链等等。 堆与栈与C/C++不同，JavaScript语言没有严格意义上，区分堆与栈，所以我们可以理解为，JavaScript所有的数据都是存放在堆内存中。不过，在某些场景下，我们仍然需要借助堆栈数据结构来处理，所以有必要理解一下这两个数据结构的区别。 栈：也叫做堆栈 栈数据结构的一个特点就是后进先出，好比羽毛球盒子，在一头放羽毛球，在另外一头取羽毛球。堆数据结构，好比书架上的书，虽然已经按顺序放好了，但是我们只要知道书的名字，就可以对应的取下来，类似于JSON对象中的key-value。 变量对象与基本数据类型JavaScript中的数据类型大致分为，基本数据类型与引用数据类型，上文提到，JavaScript中所有的数据都是存放在堆内存中，但是，这里提到的变量对象（在执行上下文创建阶段生成），由于它有特殊的职能，所以在理解上就把它与堆内存单独分开了，如下图所示： 一般变量对象里面存放的是基本数据类型,包括Undefined、Null、Boolean、Number、String,它们到是按值访问的。 12345demo01var a = 20;var b = a;b = 30;console.log(a);//20 上面这段代码指的是，在变量对象中执行数据复制的时候，其实系统会自动为新的变量分配一个新的值，所以a与b其实已经是完全独立的两个变量，只是值一样而已。 堆内存与引用数据类型javascript中的引用数据类型是存放在堆内存中的，但是不同于变量对象，javascript是不允许直接访问堆内存中的数据，所以如果我们要访问引用数据类型的时候，采用的是按引用访问，其实就是在变量对象中存放了一个指向对象的句柄，可以理解为一个地址，要访问堆内存中的对象，就要通过这个引用句柄来访问，例如上图中的d变量，就是一个指向对象的地址。 12345demo02var m = &#123; a:10,b:20&#125;;var n = m;n.a = 15;console.log(m.a);//15 上面这段代码指的是执行引用类型数据的复制时，在变量对象中会分配一个新的值，来存放新的变量，但是这两个变量的地址是一样的，相当于指向的对象是一样的，所以各自改变对象里面的属性值，会互相影响，如下图 内存泄漏上面讲解了JavaScript中的内存空间，接下来就要讲解，我写这篇文章的初衷，就是我代码中严重的内存泄漏 内存泄漏：就是不再用到的内存，但是没有及时释放，就叫做内存泄漏 有些语言必须手动释放内存，程序员负责内存的管理，例如C语言 1234char *buffer;buffer = (char*) malloc(42);//do something with bufferfree(buffer); 这里malloc就是负责分配内存，free是负责释放内存。 那么JavaScript中的垃圾回收机制又是怎么一回事呢？ 垃圾回收机制以前我一直天真的以为，垃圾回收机制就像人工智能一样，会自动帮你识别出不用的内存，然后释放掉，然而真相只有一个垃圾回收机制的原理就是，使用引用计数法，就是语言引擎有一张“引用表”，保存了内存里面所有的资源的引用次数，就像下面这样 但是如果一个值不再需要了，引用数却不为0，垃圾回收机制是无法释放这块内存，从而导致内存泄漏例如：const arr = [1,2,3,4,5];console.log(‘hello world”); 1arr的引用次数为1，尽管后面不再使用arr了，但是它还会持续占用内存，所以一般要这样处理 const arr = [1,2,3,4,5];console.log(‘hello world”);arr = null;`让arr的指向为空，垃圾回收机制就会默认它的引用数为0而回收掉。 避免内存泄漏 在局部作用域中，等函数执行完毕，变量就没有存在的必要了，js垃圾回收机制很快做出判断并且回收，但是对于全局变量，很难判断什么时候不用，所以，经验之谈就是，尽量少使用全局变量。我们在使用闭包的时候，就会造成严重的内存泄漏，因为闭包的原因，局部变量会一直保存在内存中，所以在使用闭包的时候，要多加小心。 标签: javascript 注：博客转载自：https://www.cnblogs.com/mcray/p/7002089.html","categories":[],"tags":[{"name":"javaScpript","slug":"javaScpript","permalink":"http://yoursite.com/tags/javaScpript/"}]},{"title":"h5语义化","slug":"h5语义化","date":"2018-10-15T03:15:13.000Z","updated":"2018-10-15T05:57:53.329Z","comments":true,"path":"2018/10/15/h5语义化/","link":"","permalink":"http://yoursite.com/2018/10/15/h5语义化/","excerpt":"","text":"距HTML5标准规范制定完成并公开发布已经有好些年了，面试时也少不了要问对HTML5语义化得理解。但是在实际运用时，真正使用HTML5标签来开发的似乎不是很多（ps：查看了几个巨头公司网站推论），可能一部分原因是仍有部分用户使用在使用低版本浏览器。 但是就我个人而言，因选取一些标签时会比较纠结，所以仍使用了div。（PS：正是因为这样，才有了这篇文章的，没错，以后要注意语义化了） 什么是语义化？就是用合理、正确的标签来展示内容，比如h1~h6定义标题。 语义化优点： 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。方便其他设备解析，如盲人阅读器根据语义渲染网页有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。今天先介绍主体结构标签，如图所示： HTML5-语义化 1、 定义文档或者文档的部分区域的页眉，应作为介绍内容或者导航链接栏的容器。 在一个文档中，您可以定义多个元素，但需要注意的是元素不能作为、 或 元素的子元素。 2、 描述一个含有多个超链接的区域，该区域包含跳转到其他页面或页面内部其他部分的链接列表。 在一个文档中，可定义多个元素。 3、 定义文档的主要内容，该内容在文档中应当是独一无二的，不包含任何在文档中重复的内容，比如侧边栏，导航栏链接，版权信息，网站logo，搜索框（除非搜索框作为文档的主要功能）。 需要注意的是在一个文档中不能出现多个标签。 4、 元素表示文档、页面、应用或网站中的独立结构，是可独立分配的、可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 当元素嵌套使用时，则该元素代表与外层元素有关的文章。例如，代表博客评论的元素可嵌套在代表博客文章的元素中。 5、 元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分且可以被单独的拆分出来而不会影响整体。通常表现为侧边栏或嵌入内容。 6、 定义最近一个章节内容或者根节点元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。 使用footer插入联系信息时，应在 footer 元素内使用 元素。 注意不能包含或者 7、 表示文档中的一个区域（或节），比如，内容中的一个专题组。 如果元素内容可以分为几个部分的话，应该使用 而不是 。 不要把 元素作为一个普通的容器来使用，特别是当仅仅是为了美化样式或方便脚本使用的时候，应使用。 这几个标签，比较容易混淆的是、，所以这里特别说明： “Authors are encouraged to use the article element instead of the section element when it would make sense to syndicate the contents of the elemen.” 通俗来说就是比更具有独立性、完整性。可通过该段内容脱离了所在的语境，是否完整、独立来判断。","categories":[],"tags":[{"name":"h5","slug":"h5","permalink":"http://yoursite.com/tags/h5/"}]},{"title":"移动端开发的兼容问题（二）","slug":"移动端开发的兼容问题（二）","date":"2018-10-15T02:27:19.000Z","updated":"2018-10-15T02:44:46.156Z","comments":true,"path":"2018/10/15/移动端开发的兼容问题（二）/","link":"","permalink":"http://yoursite.com/2018/10/15/移动端开发的兼容问题（二）/","excerpt":"","text":"CSS部分1.body如果设置height:100%;overflow:hidden是依然可以滑动的，如果需禁止，要再加一层div设置 height:100%加overflow：hidden（html,body加height:100%） ，这样元素超出body的高度也不能滑动了。或者同时给html，body加height:100%;overflow:hidden 2.meta标签 移动端加上这个标签才是真正的自适应，不加的话，假如你把一个980px宽度(手机端常规是980)的PC网页放在手机上显示，倒也能正常显示不出现滚动条，不过是移动设备对页面 做了缩小优化，所以字体等都相应缩小了（980px是相对于手机像素的，我的是超过1000px多一些就出现滚动条了，这个没具体研究）。关于 initial-scale=1 ，这个参照iphone5的尺寸320568，如果你页面按照6401136做的话，scale就设为0.5 IOS中safari允许全屏浏览 IOS中Safari顶端状态条样式 忽略将数字变为电话号码 忽略识别email 3.做全屏显示的图片时，一般为了兼容大部分的手机，图片尺寸一般设为640*960（我是觉得这个尺寸好，也看不少的图片也是这个尺寸，视情况而定） 4.去除webkit的滚动条 12345element::-webkit-scrollbar&#123; display: none;&#125; 5.去除button在ios上的默认样式 123-webkit-appearance: none;border-radius: 0 6.不想让按钮touch时有蓝色的边框 -webkit-tap-highlight-color:rgba(0,0,0,0); 7.如果要用到fixed譬如导航等，可以用absolute达到一样的效果，把body设为100%；将元素absolute到body上即可，不过这样不能让body滚动，如果需要有滚动的地方，就放在div中滚动 8.在移动端做动画效果的话，如果通过改变绝对定位的top，或者margin的话做出来的效果很差，很不流畅，而使用css3的transition或者animation的效果将会非常棒（这一方面IOS比android又要好不少）。 如果用translate3d来实现动画，会开启GPU加速，硬件配置差的安卓用起来会耗性能，需慎用 9.使用图片时，会发现图片下总是有大概4px的空白，（原因据说图片是inline，触发baseline什么的。。。）常用解决方法有 123img&#123;display:block&#125;；img&#123;vertical-align:top&#125;也可取其他几个值，视情况而定 其他解决办法 见此 10.学会使用display:-webkit-box的布局，能很好地帮我们做到页面自适应，譬如 导航栏 这些个人觉得特别适合，具体使用方法此处不叙述 11.使用 a 标签的话，尽量让 a 标签 block ，尽量让用户可点击区域最大化 12.两个页面使用了transform之后，页面下的z-index有时就会失效，我遇到过，但没去认真探究，只是把z-index提高就好了，如果遇到这个问题的，详细可以 看这 13.在iOS中，当你点击比如 input 准备输入时，虚拟键盘弹出，整个视窗的 高度 就会变为 减去键盘 的高度，加入你在底部有fixed的元素比如btn，这个元素就会跑上来，一般都不会太美观。我是当focus时就把它设为absolute，视情况而定 14.禁止用户选中文字 -webkit-user-select:none 15.当你把input设为 width:100%时，有时可能会遇到input的宽度超出了屏幕，这时可对input加一个属性 box-sizing:border-box 关于box-sizing:border-box，此属性是把边框的高宽包含在盒子的高宽中，假如你设置两个元素float且各占50%，又都有border时，用这个属性就可以完美地让它们能显示在同一行 16.要table的td用col设置了宽度后超出部分隐藏的话给table加属性table-layout:fixed（固定宽度布局） 17.如果想改变 placeholder 里的样式，需要用css伪类。 如 ::-webkit-input-placeholder{color:#ccc} 18.做一个方向箭头比如 “&gt;” 时，可以用一个正方形的div，设置border:1px 1px 0 0；然后rotate(45deg) 19.CSS权重：style是1000，id是100，class是10，普通如li、div和伪类是1，通用如*是0； 20.使用rem时，设某个div比如的height:3rem;line-height:1.5rem;overflow:hidden;时，在某些android手机上可能会出现显示不止两行,第三行会显示点头部。 解决：利用js获取文字line-height再去设置div高度 JS部分1.如果使用jquery绑定touch事件的话，获取touchstart，touchmove的触点坐标用 e.originalEvent.targetTouches[0].pageX，获取touchend则用 e.originalEvent.changedTouches[0].pageX 2.利用style获取获取transform的rotate值 parseInt(/rotateX((.*?))/.exec(getALL.style.webkitTransform)[1]) 如果页面一开始没有style值，rotate是写在CSS里的，需要用到getComputedStyle，具体请看这里。 3.有些版本的iphone4中， audio和video默认播放事件不会触发，比如使用window.onload或计时器等都不能触发播放，必须用JS写事件让用户手动点击触发才会开始播放 4.想要在touchmove:function(e,参数一)加一个参数，结果直接使用e.preventDefault()就会 e 报错，处理方法为 1234567touchmove:function(e,参数一)&#123; var e=arguments[0] e.preventDefault()&#125; 5.HTML5的新js API有新的选择器，比如querySelector(“.class #id”)和querySelectorAll(“.class element”) 6.点击一个元素时，使用touchstart会立即触发，而使用click则用有大概0.3s的延迟 7.用e.preventDefault()会阻止的scroll，click等事件 微信部分1.判断是否来自微信浏览器 1234567function isFromWeiXin() &#123; var ua = navigator.userAgent.toLowerCase(); if (ua.match(/MicroMessenger/i) == &quot;micromessenger&quot;) &#123; return true; &#125; return false;&#125; 2.判断手机的类型 123456789var user=&quot;&quot;; if (/android/i.test(navigator.userAgent))&#123; // android user=&quot;1&quot;; &#125; if (/ipad|iphone|mac/i.test(navigator.userAgent))&#123; // ios user=&quot;0&quot;; &#125; 3.微信浏览器里均不能打开下载的链接，需在浏览器打开 4.如果在网页里嵌套一个iframe，src为其他的网址等，当在微信浏览器打开时，如果irame里的页面过大，则iframe的src不能加载 5.微信升级到6.0后，在微信网页里需要用到设置分享的标题等，需要用到JSSDK，同时去微信公众平台里绑定里放置网页的域名。 不过JSSDK也不是所有问题都解决了，在android里点击分享到朋友圈时就触发了分享成功的回调函数，即使取消分享也已经触发了成功的函数（现在不知道是否有修复，如果遇到了这类问题，应该就是这个原因）","categories":[],"tags":[{"name":"兼容性 移动端","slug":"兼容性-移动端","permalink":"http://yoursite.com/tags/兼容性-移动端/"}]},{"title":"ES6十大新特性","slug":"ES6十大新特性","date":"2018-09-28T07:17:05.000Z","updated":"2018-09-28T07:25:19.908Z","comments":true,"path":"2018/09/28/ES6十大新特性/","link":"","permalink":"http://yoursite.com/2018/09/28/ES6十大新特性/","excerpt":"","text":"引言ES6（ECMAScript2015）的出现，无疑给前端开发人员带来了新的惊喜，它包含了一些很棒的新特性，可以更加方便的实现很多复杂的操作，提高开发人员的效率。 本文主要针对ES6做一个简要介绍。 主要译自： http://webapplog.com/ES6/comment-page-1/。也许你还不知道ES6是什么, 实际上, 它是一种新的javascript规范。在这个大家都很忙碌的时代，如果你想对ES6有一个快速的了解，那么请继续往下读，去了解当今最流行的编程语言JavaScript最新一代的十大特性。 以下是ES6排名前十的最佳特性列表（排名不分先后）： Default Parameters（默认参数） in ES6 Template Literals （模板文本）in ES6 Multi-line Strings （多行字符串）in ES6 Destructuring Assignment （解构赋值）in ES6 Enhanced Object Literals （增强的对象文本）in ES6 Arrow Functions （箭头函数）in ES6 Promises in ES6 Block-Scoped Constructs Let and Const（块作用域构造Let and Const） Classes（类） in ES6 Modules（模块） in ES6 声明：这些列表仅是个人主观意见。它绝不是为了削弱ES6其它功能，这里只列出了10条比较常用的特性。 首先回顾一下JavaScript的历史，不清楚历史的人，很难理解JavaScript为什么会这样发展。下面就是一个简单的JavaScript发展时间轴： 1、1995：JavaScript诞生，它的初始名叫LiveScript。 2、1997：ECMAScript标准确立。 3、1999：ES3出现，与此同时IE5风靡一时。 4、2000–2005： XMLHttpRequest又名AJAX， 在Outlook Web Access (2000)、Oddpost (2002)，Gmail (2004)和Google Maps (2005)大受重用。 5、2009： ES5出现，（就是我们大多数人现在使用的）例如foreach，Object.keys，Object.create和JSON标准。 6、2015：ES6/ECMAScript2015出现。 历史回顾就先到此，现让我们进入正题。 1.Default Parameters（默认参数） in ES6还记得我们以前不得不通过下面方式来定义默认参数： 123456var link = function (height, color, url) &#123; var height = height || 50; var color = color || &apos;red&apos;; var url = url || &apos;http://azat.co&apos;; ...&#125; 一切工作都是正常的，直到参数值是0后，就有问题了，因为在JavaScript中，0表示fasly，它是默认被hard-coded的值，而不能变成参数本身的值。当然，如果你非要用0作为值，我们可以忽略这一缺陷并且使用逻辑OR就行了！但在ES6，我们可以直接把默认值放在函数申明里： 123var link = function(height = 50, color = &apos;red&apos;, url = &apos;http://azat.co&apos;) &#123; ...&#125; 顺便说一句，这个语法类似于Ruby！ 2.Template Literals（模板对象） in ES6 在其它语言中，使用模板和插入值是在字符串里面输出变量的一种方式。因此，在ES5，我们可以这样组合一个字符串： 12var name = &apos;Your name is &apos; + first + &apos; &apos; + last + &apos;.&apos;;var url = &apos;http://localhost:3000/api/messages/&apos; + id; 幸运的是，在ES6中，我们可以使用新的语法$ {NAME}，并把它放在反引号里： 12var name = `Your name is $&#123;first&#125; $&#123;last&#125;. `;var url = `http://localhost:3000/api/messages/$&#123;id&#125;`; 3.Multi-line Strings （多行字符串）in ES6 ES6的多行字符串是一个非常实用的功能。在ES5中，我们不得不使用以下方法来表示多行字符串： 1234567var roadPoem = &apos;Then took the other, as just as fair,nt&apos; + &apos;And having perhaps the better claimnt&apos; + &apos;Because it was grassy and wanted wear,nt&apos; + &apos;Though as for that the passing therent&apos; + &apos;Had worn them really about the same,nt&apos;;var fourAgreements = &apos;You have the right to be you.n You can only be you when you do your best.&apos;; 然而在ES6中，仅仅用反引号就可以解决了： 1234567var roadPoem = `Then took the other, as just as fair, And having perhaps the better claim Because it was grassy and wanted wear, Though as for that the passing there Had worn them really about the same,`;var fourAgreements = `You have the right to be you. You can only be you when you do your best.`; 4.Destructuring Assignment （解构赋值）in ES6 解构可能是一个比较难以掌握的概念。先从一个简单的赋值讲起，其中house 和 mouse是key，同时house 和mouse也是一个变量，在ES5中是这样 123var data = $(&apos;body&apos;).data(), // data has properties house and mouse house = data.house, mouse = data.mouse; 以及在node.js中用ES5是这样： 1234var jsonMiddleware = require(&apos;body-parser&apos;).jsonMiddleware ;var body = req.body, // body has username and password username = body.username, password = body.password; 在ES6，我们可以使用这些语句代替上面的ES5代码： 123var &#123; house, mouse&#125; = $(&apos;body&apos;).data(); // we&apos;ll get house and mouse variablesvar &#123;jsonMiddleware&#125; = require(&apos;body-parser&apos;);var &#123;username, password&#125; = req.body; 这个同样也适用于数组，非常赞的用法： 12var [col1, col2] = $(&apos;.column&apos;), [line1, line2, line3, , line5] = file.split(&apos;n&apos;); 我们可能需要一些时间来习惯解构赋值语法的使用，但是它确实能给我们带来许多意外的收获。 5.Enhanced Object Literals （增强的对象字面量）in ES6 使用对象文本可以做许多让人意想不到的事情！通过ES6，我们可以把ES5中的JSON变得更加接近于一个类。 下面是一个典型ES5对象文本，里面有一些方法和属性： 123456789101112var serviceBase = &#123;port: 3000, url: &apos;azat.co&apos;&#125;, getAccounts = function()&#123;return [1,2,3]&#125;;var accountServiceES5 = &#123; port: serviceBase.port, url: serviceBase.url, getAccounts: getAccounts, toString: function() &#123; return JSON.stringify(this.valueOf()); &#125;, getUrl: function() &#123;return &quot;http://&quot; + this.url + &apos;:&apos; + this.port&#125;, valueOf_1_2_3: getAccounts()&#125; 如果我们想让它更有意思，我们可以用Object.create从serviceBase继承原型的方法： 123456789var accountServiceES5ObjectCreate = Object.create(serviceBase)var accountServiceES5ObjectCreate = &#123; getAccounts: getAccounts, toString: function() &#123; return JSON.stringify(this.valueOf()); &#125;, getUrl: function() &#123;return &quot;http://&quot; + this.url + &apos;:&apos; + this.port&#125;, valueOf_1_2_3: getAccounts()&#125; 我们知道，accountServiceES5ObjectCreate 和accountServiceES5 并不是完全一致的，因为一个对象(accountServiceES5)在proto对象中将有下面这些属性： 图片1 为了方便举例，我们将考虑它们的相似处。所以在ES6的对象文本中，既可以直接分配getAccounts: getAccounts,也可以只需用一个getAccounts，此外，我们在这里通过proto（并不是通过’proto’）设置属性，如下所示： 12345var serviceBase = &#123;port: 3000, url: &apos;azat.co&apos;&#125;,getAccounts = function()&#123;return [1,2,3]&#125;;var accountService = &#123; __proto__: serviceBase, getAccounts, 另外，我们可以调用super防范，以及使用动态key值(valueOf_1_2_3): 1234567 toString() &#123; return JSON.stringify((super.valueOf())); &#125;, getUrl() &#123;return &quot;http://&quot; + this.url + &apos;:&apos; + this.port&#125;, [ &apos;valueOf_&apos; + getAccounts().join(&apos;_&apos;) ]: getAccounts()&#125;;console.log(accountService) 图片3 ES6对象文本是一个很大的进步对于旧版的对象文本来说。 6.Arrow Functions in（箭头函数） ES6这是我迫不及待想讲的一个特征，CoffeeScript 就是因为它丰富的箭头函数让很多开发者喜爱。在ES6中，也有了丰富的箭头函数。这些丰富的箭头是令人惊讶的因为它们将使许多操作变成现实，比如， 以前我们使用闭包，this总是预期之外地产生改变，而箭头函数的迷人之处在于，现在你的this可以按照你的预期使用了，身处箭头函数里面，this还是原来的this。 有了箭头函数在ES6中， 我们就不必用that = this或 self = this 或 _this = this 或.bind(this)。例如，下面的代码用ES5就不是很优雅： 1234var _this = this;$(&apos;.btn&apos;).click(function(event)&#123; _this.sendData();&#125;) 在ES6中就不需要用 _this = this： 123$(&apos;.btn&apos;).click((event) =&gt;&#123; this.sendData();&#125;) 不幸的是，ES6委员会决定，以前的function的传递方式也是一个很好的方案，所以它们仍然保留了以前的功能。 下面这是一个另外的例子，我们通过call传递文本给logUpperCase() 函数在ES5中： 12345678910var logUpperCase = function() &#123; var _this = this; this.string = this.string.toUpperCase(); return function () &#123; return console.log(_this.string); &#125;&#125; logUpperCase.call(&#123; string: &apos;ES6 rocks&apos; &#125;)(); 而在ES6，我们并不需要用_this浪费时间： 12345var logUpperCase = function() &#123; this.string = this.string.toUpperCase(); return () =&gt; console.log(this.string);&#125;logUpperCase.call(&#123; string: &apos;ES6 rocks&apos; &#125;)(); 请注意，只要你愿意，在ES6中=&gt;可以混合和匹配老的函数一起使用。当在一行代码中用了箭头函数，它就变成了一个表达式。它将暗地里返回单个语句的结果。如果你超过了一行，将需要明确使用return。 这是用ES5代码创建一个消息数组： 1234var ids = [&apos;5632953c4e345e145fdf2df8&apos;,&apos;563295464e345e145fdf2df9&apos;];var messages = ids.map(function (value) &#123; return &quot;ID is &quot; + value; // explicit return&#125;); 用ES6是这样： 12var ids = [&apos;5632953c4e345e145fdf2df8&apos;,&apos;563295464e345e145fdf2df9&apos;];var messages = ids.map(value =&gt; `ID is $&#123;value&#125;`); // implicit return 请注意，这里用了字符串模板。 在箭头函数中，对于单个参数，括号()是可选的，但当你超过一个参数的时候你就需要他们。 在ES5代码有明确的返回功能： 1234var ids = [&apos;5632953c4e345e145fdf2df8&apos;, &apos;563295464e345e145fdf2df9&apos;];var messages = ids.map(function (value, index, list) &#123; return &apos;ID of &apos; + index + &apos; element is &apos; + value + &apos; &apos;; // explicit return&#125;); 在ES6中有更加严谨的版本，参数需要被包含在括号里并且它是隐式的返回： 12var ids = [&apos;5632953c4e345e145fdf2df8&apos;,&apos;563295464e345e145fdf2df9&apos;];var messages = ids.map((value, index, list) =&gt; `ID of $&#123;index&#125; element is $&#123;value&#125; `); // implicit return 7.Promises in ES6 Promises 是一个有争议的话题。因此有许多略微不同的promise 实现语法。Q，bluebird，deferred.js，vow, avow, jquery 一些可以列出名字的。也有人说我们不需要promises，仅仅使用异步，生成器，回调等就够了。但令人高兴的是，在ES6中有标准的Promise实现。 下面是一个简单的用setTimeout()实现的异步延迟加载函数: 123setTimeout(function()&#123; console.log(&apos;Yay!&apos;);&#125;, 1000); 在ES6中，我们可以用promise重写: 12345var wait1000 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 1000);&#125;).then(function() &#123; console.log(&apos;Yay!&apos;);&#125;); 或者用ES6的箭头函数： 12345var wait1000 = new Promise((resolve, reject)=&gt; &#123; setTimeout(resolve, 1000);&#125;).then(()=&gt; &#123; console.log(&apos;Yay!&apos;);&#125;); 到目前为止，代码的行数从三行增加到五行，并没有任何明显的好处。确实，如果我们有更多的嵌套逻辑在setTimeout()回调函数中，我们将发现更多好处： 123456setTimeout(function()&#123; console.log(&apos;Yay!&apos;); setTimeout(function()&#123; console.log(&apos;Wheeyee!&apos;); &#125;, 1000)&#125;, 1000); 在ES6中我们可以用promises重写： 123456789var wait1000 = ()=&gt; new Promise((resolve, reject)=&gt; &#123;setTimeout(resolve, 1000)&#125;);wait1000() .then(function() &#123; console.log(&apos;Yay!&apos;) return wait1000() &#125;) .then(function() &#123; console.log(&apos;Wheeyee!&apos;) &#125;); 还是不确信Promises 比普通回调更好？其实我也不确信，我认为一旦你有回调的想法，那么就没有必要额外增加promises的复杂性。 虽然，ES6 有让人崇拜的Promises 。Promises 是一个有利有弊的回调但是确实是一个好的特性，更多详细的信息关于promise:Introduction to ES6 Promises. 8.Block-Scoped Constructs Let and Const（块作用域和构造let和const）在ES6代码中，你可能已经看到那熟悉的身影let。在ES6里let并不是一个花俏的特性，它是更复杂的。Let是一种新的变量申明方式，它允许你把变量作用域控制在块级里面。我们用大括号定义代码块，在ES5中，块级作用域起不了任何作用： 1234567891011121314function calculateTotalAmount (vip) &#123; var amount = 0; if (vip) &#123; var amount = 1; &#125; &#123; // more crazy blocks! var amount = 100; &#123; var amount = 1000; &#125; &#125; return amount;&#125;console.log(calculateTotalAmount(true)); 结果将返回1000，这真是一个bug。在ES6中，我们用let限制块级作用域。而var是限制函数作用域。 123456789101112131415function calculateTotalAmount (vip) &#123; var amount = 0; // probably should also be let, but you can mix var and let if (vip) &#123; let amount = 1; // first amount is still 0 &#125; &#123; // more crazy blocks! let amount = 100; // first amount is still 0 &#123; let amount = 1000; // first amount is still 0 &#125; &#125; return amount;&#125; console.log(calculateTotalAmount(true)); 这个结果将会是0，因为块作用域中有了let。如果（amount=1）.那么这个表达式将返回1。谈到const，就更加容易了；它就是一个不变量，也是块级作用域就像let一样。下面是一个演示，这里有一堆常量，它们互不影响，因为它们属于不同的块级作用域: 1234567891011121314function calculateTotalAmount (vip) &#123; const amount = 0; if (vip) &#123; const amount = 1; &#125; &#123; // more crazy blocks! const amount = 100 ; &#123; const amount = 1000; &#125; &#125; return amount;&#125;console.log(calculateTotalAmount(true)); 从我个人看来，let 和const使这个语言变复杂了。没有它们的话，我们只需考虑一种方式，现在有许多种场景需要考虑。 9. Classes （类）in ES6如果你喜欢面向对象编程（OOP），那么你将喜爱这个特性。以后写一个类和继承将变得跟在facebook上写一个评论那么容易。 类的创建和使用真是一件令人头疼的事情在过去的ES5中，因为没有一个关键字class （它被保留，但是什么也不能做）。在此之上，大量的继承模型像pseudo classical, classical, functional 更加增加了混乱，JavaScript 之间的宗教战争只会更加火上浇油。 用ES5写一个类，有很多种方法，这里就先不说了。现在就来看看如何用ES6写一个类吧。ES6没有用函数, 而是使用原型实现类。我们创建一个类baseModel ，并且在这个类里定义了一个constructor 和一个 getName()方法： 123456789101112class baseModel &#123; constructor(options, data) &#123; // class constructor，node.js 5.6暂时不支持options = &#123;&#125;, data = []这样传参 this.name = &apos;Base&apos;; this.url = &apos;http://azat.co/api&apos;; this.data = data; this.options = options; &#125; getName() &#123; // class method console.log(`Class name: $&#123;this.name&#125;`); &#125;&#125; 注意我们对options 和data使用了默认参数值。此外方法名也不需要加function关键字，而且冒号(：)也不需要了。另外一个大的区别就是你不需要分配属性this。现在设置一个属性的值，只需简单的在构造函数中分配。 AccountModel 从类baseModel 中继承而来: 12class AccountModel extends baseModel &#123; constructor(options, data) &#123; 为了调用父级构造函数，可以毫不费力的唤起super()用参数传递： 1234super(&#123;private: true&#125;, [&apos;32113123123&apos;, &apos;524214691&apos;]); //call the parent method with super this.name = &apos;Account Model&apos;; this.url +=&apos;/accounts/&apos;; &#125; 如果你想做些更好玩的，你可以把 accountData 设置成一个属性： 12345get accountsData() &#123; //calculated attribute getter // ... make XHR return this.data; &#125;&#125; 那么，你如何调用他们呢？它是非常容易的： 123let accounts = new AccountModel(5);accounts.getName();console.log(&apos;Data is %s&apos;, accounts.accountsData); 结果令人惊讶，输出是： Class name: Account Model Data is 32113123123,524214691 10.Modules （模块）in ES6 众所周知，在ES6以前JavaScript并不支持本地的模块。人们想出了AMD，RequireJS，CommonJS以及其它解决方法。现在ES6中可以用模块import 和export 操作了。 在ES5中，你可以在 中直接写可以运行的代码（简称IIFE），或者一些库像AMD。然而在ES6中，你可以用export导入你的类。下面举个例子，在ES5中,module.js有port变量和getAccounts 方法: 123456module.exports = &#123; port: 3000, getAccounts: function() &#123; ... &#125;&#125; 在ES5中，main.js需要依赖require(‘module’) 导入module.js： 12var service = require(&apos;module.js&apos;);console.log(service.port); // 3000 但在ES6中，我们将用export and import。例如，这是我们用ES6 写的module.js文件库： 1234export var port = 3000;export function getAccounts(url) &#123; ...&#125; 如果用ES6来导入到文件main.js中，我们需用import {name} from ‘my-module’语法，例如： 12import &#123;port, getAccounts&#125; from &apos;module&apos;;console.log(port); // 3000 或者我们可以在main.js中把整个模块导入, 并命名为 service： 12import * as service from &apos;module&apos;;console.log(service.port); // 3000 从我个人角度来说，我觉得ES6模块是让人困惑的。但可以肯定的事，它们使语言更加灵活了。 并不是所有的浏览器都支持ES6模块，所以你需要使用一些像jspm去支持ES6模块。 更多的信息和例子关于ES6模块，请看 this text。不管怎样，请写模块化的JavaScript。 如何使用ES6 (Babel)ES6已经敲定，但并不是所有的浏览器都完全支持，详见：http://kangax.github.io/compat-table/es6/。要使用ES6，需要一个编译器例如：babel。你可以把它作为一个独立的工具使用，也可以把它放在构建中。grunt，gulp和webpack中都有可以支持babel的插件。 图片2 这是一个gulp案列，安装gulp-babel插件： 1$ npm install --save-dev gulp-babel 在gulpfile.js中，定义一个任务build，放入src/app.js，并且编译它进入构建文件中。 1234567var gulp = require(&apos;gulp&apos;), babel = require(&apos;gulp-babel&apos;);gulp.task(&apos;build&apos;, function () &#123; return gulp.src(&apos;src/app.js&apos;) .pipe(babel()) .pipe(gulp.dest(&apos;build&apos;));&#125;) Node.js and ES6 在nodejs中，你可以用构建工具或者独立的Babel模块 babel-core 来编译你的Node.js文件。安装如下： 1$ npm install --save-dev babel-core 然后在node.js中，你可以调用这个函数： 1require(&quot;babel-core&quot;).transform(ES5Code, options); ES6总结这里还有许多ES6的其它特性你可能会使用到，排名不分先后： 1、全新的Math, Number, String, Array 和 Object 方法 2、二进制和八进制数据类型 3、默认参数不定参数扩展运算符 4、Symbols符号 5、tail调用 6、Generators (生成器) 7、New data structures like Map and Set(新的数据构造对像MAP和set) 参考文献： ES6 Cheatsheet (FREE PDF) http://webapplog.com/ES6/comment-page-1/ Understanding ECMAScript 6 by Nicolas Zakas book http://ES6-features.org/#DateTimeFormatting IIFE：立刻运行的函数表达式 ## 转载自AlloyTeam： http://www.alloyteam.com/2016/03/es6-front-end-developers-will-have-to-know-the-top-ten-properties/","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"css3动画简介","slug":"css3动画简介","date":"2018-09-18T15:21:39.000Z","updated":"2018-09-18T16:14:49.858Z","comments":true,"path":"2018/09/18/css3动画简介/","link":"","permalink":"http://yoursite.com/2018/09/18/css3动画简介/","excerpt":"","text":"引言 都知道CSS 用于控制网页的样式和布局。而CSS3 是最新的 CSS 标准。 新特性在CSS3中新增的特性主要分为如下方面： 选择器的新增 选择符类型 表达式 描述 子串匹配的属性选择符 E[att^=”val”] 匹配具有att属性、且值以val开头的E元素 E[att$=”val”] 匹配具有att属性、且值以val结尾的E元素 E[att*=”val”] 匹配具有att属性、且值中含有val的E元素 结构性伪类 E:root 匹配文档的根元素。在HTML（标准通用标记语言下的一个应用）中，根元素永远是HTML E:nth-child(n) 匹配父元素中的第n个子元素E E:nth-last-child(n) 匹配父元素中的倒数第n个结构子元素E E:nth-of-type(n) 匹配同类型中的第n个同级兄弟元素E E:nth-last-of-type(n) 匹配同类型中的倒数第n个同级兄弟元素E E:last-child 匹配父元素中最后一个E元素 E:first-of-type 匹配同级兄弟元素中的第一个E元素 E:only-child 匹配属于父元素中唯一子元素的E E:only-of-type 匹配属于同类型中唯一兄弟元素的E E:empty 匹配没有任何子元素（包括text节点）的元素E 目标伪类 E:target 匹配相关URL指向的E元素 UI元素状态伪类 E:enabled 匹配所有用户界面（form表单）中处于可用状态的E元素 E:disabled 匹配所有用户界面（form表单）中处于不可用状态的E元素 E:checked 匹配所有用户界面（form表单）中处于选中状态的元素E E::selection 匹配E元素中被用户选中或处于高亮状态的部分 否定伪类 E:not(s) 匹配所有不匹配简单选择符s的元素E 通用兄弟元素选择器 E ~ F 匹配E元素之后的F元素 如果想尝试实现一个干净的、轻量级的标签以及结构与表现更好的分离，高级选择器是非常有用的，它们可以减少在标签中的class和ID的数量并让设计师更方便地维护样式表 ，不过需要注意的是，母亲在微信小程序中有些css3的选择器暂时是不支持的，具体参阅小程序开发文档（https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html） 文字颜色特性 属性 描述 CSS hanging-punctuation 规定标点字符是否位于线框之外。 3 punctuation-trim 规定是否对标点字符进行修剪。 3 text-align-last 设置如何对齐最后一行或紧挨着强制换行符之前的行。 3 text-emphasis 向元素的文本应用重点标记以及重点标记的前景色。 3 text-justify 规定当 text-align 设置为 “justify” 时所使用的对齐方法。 3 text-outline 规定文本的轮廓。 3 text-overflow 规定当文本溢出包含元素时发生的事情。 3 text-shadow 向文本添加阴影。 3 text-wrap 规定文本的换行规则。 3 word-break 规定非中日韩文本的换行规则。 3 word-wrap 允许对长的不可分割的单词进行分割并换行到下一行。 3 背景和边框 属性 说明 CSS border-image 设置所有边框图像的速记属性。 3 border-radius 一个用于设置所有四个边框- *-半径属性的速记属性 3 box-shadow 附加一个或多个下拉框的阴影 3 盒子模型css3中新增了怪异盒子和标准盒子的概念； 所谓的标准盒子就是我们平时计算盒子总宽度/高度=width/height+padding+border+margin 新增的怪异盒子就是盒子总宽度/高度=width/height + margin = 内容区宽度/高度 + padding + border + margin; 怪异盒子通常适用于移动端布局，即屏幕为定宽，根据内容显示； flex布局弹性盒子是 CSS3 的一种新的布局模式，可以说是非常强大的一个功能了，对于不同设备的显示起到了很大的帮助。 CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。 引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。 使用方法 display:flex; 属性 12345//设置主轴方向flex-direction:row //默认为row，水平方向 row-reverse //与row相同，顺序相反 column //垂直方向 column-reverse //与column相同，顺序相反 1234//设置换行flex-wrap:nowrap //默认值，表示不换行或不折列 wrap //换行 wrap-reverse //换行并且顺序相反 123456//设置主轴对齐方式justify-content:flex-start; //默认值 左对齐 flex-end; //右对齐 center; //居中 space-between; //元素与元素之间留白 space-around; //元素左右都留白 12345//设置侧轴对齐方式align-items:stretch; //默认值 拉伸到适应长度 center; //侧轴居中 flex-start/end //侧轴顶部/底部 baseline //基线对齐 以下是定义 在子项的元素上的属性 123456order //排序flex-grow:&lt;number&gt; //默认是0 放大比例flex-shrink:&lt;number&gt; //默认是1 缩小比例flex-basis:30px; //表示跟width或height一样的值flex: //以上三个的复合值align-self:auto/flex-start/flex-end/ //表示设置当前子项的对齐方式 注意：有时候设置的felx不生效，兼容不同浏览器的方式是加上对应浏览的前缀， ​ -webkit- chrome、safari 例display: -webkit-flex; ​ -moz- firefox ​ -ms- ie ​ -0- opera 过渡动画2D/3D转换","categories":[],"tags":[{"name":"css3 动画","slug":"css3-动画","permalink":"http://yoursite.com/tags/css3-动画/"}]},{"title":"微信小程序入门指南-（二）","slug":"微信小程序入门指南-（二）","date":"2018-09-14T13:11:46.000Z","updated":"2018-09-17T02:14:02.594Z","comments":true,"path":"2018/09/14/微信小程序入门指南-（二）/","link":"","permalink":"http://yoursite.com/2018/09/14/微信小程序入门指南-（二）/","excerpt":"","text":"微信小程序已经火了一段时间了，之前一直也在关注，就这半年的发展来看，相对原生APP大部分公司还是不愿意将主营业务放到微信平台上，以免受制于腾讯，不过就小程序的应用场景（用完即走和二维码分发等）还是很值得我们学习的，技术上面如果了解React的话，会发现他们在组件化上面有很多雷同之处。说白了，小程序就是基于微信平台的H5轻应用，微信将系统底层功能（设备、位置、媒体、文件等）和微信自身功能（登录、支付、分享等）封装成相应API供小程序调用。 根据官方文档写过一个DOME，借助和风天气开放API接口，实现天气预报，仅供学习交流使用，谢谢~ 一、小程序基本概念 1、开发工具：为了配合小程序开发，微信专门配备了自己的开发工具，自行选择对应版本安装。 2、创建项目应用：安装完成后，打开并扫码登录。小程序发布需要企业级的认证公众号，所以个人订阅号是不能发布的。所以我这里选择无AppID，创建项目选择一个本地空文件夹，勾选创建quick start 项目生成一个demo。 3、编写小程序：demo初始化并包含了一些简单的代码文件，其中app.js、app.json、app.wxss 这三个是必不可少的，小程序会读取这些文件初始化实例。 app.js是小程序的初始化脚本，可以在这个文件中监听小程序的生命周期，申请全局变量和调用API等 app.json是对小程序的全局配置，pages设置页面路径组成（默认第一条为首页），window设置默认页面的窗口表现等 app.wxss 是整个小程序的公共样式表。类似网站开发中的common.css 4、创建页面：在pages目录下，由一个文件夹中的四个同名不同类型文件组成。.js是脚本文件，.json是配置文件，.wxss是样式表文件，.wxml是页面结构文件，其中json和wxss文件为非必须（默认会继承app的json和wxss默认设置）。 二、小程序的框架 1、小程序的配置 app.json主要分为五个部分：pages：页面组，window：框架样式（状态栏、导航条、标题、窗口背景色），tabBar：底部菜单，networkTimeout：网络超时设置，debug：开启debug模式 page.json针对页面单独设置，层叠掉app.json的全局设置 12345678910111213//app.json&#123; &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:&#123; &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#000&quot;, &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;, &quot;navigationBarTextStyle&quot;:&quot;white&quot; &#125;&#125; 2、小程序的逻辑 使用App()来注册一个小程序，必须在app.js中注册，且不能注册多个 123456789App(&#123;//如下为小程序的生命周期 onLaunch: function() &#123; &#125;,//监听初始化 onShow: function() &#123; &#125;,//监听显示（进入前台） onHide: function() &#123; &#125;,//监听隐藏（进入后台：按home离开微信） onError: function(msg) &#123; &#125;,//监听错误 //如下为自定义的全局方法和全局变量 globalFun:function()&#123;&#125;, globalData: &apos;I am global data&apos;&#125;) 使用Page()注册一个页面，在每个页面的js文件中注册 123456789101112131415Page(&#123; data: &#123;text: &quot;This is page data.&quot;&#125;,//页面数据，用来维护视图，json格式 onLoad: function(options) &#123; &#125;,//监听加载 onReady: function() &#123; &#125;,//监听初次渲染完成 onShow: function() &#123; &#125;,//监听显示 onHide: function() &#123; &#125;,//监听隐藏 onUnload: function() &#123; &#125;,//监听卸载 onPullDownRefresh: function() &#123; &#125;,//监听下拉 onReachBottom: function() &#123; &#125;,//监听上拉触底 onShareAppMessage: function () &#123; &#125;,//监听右上角分享 //如下为自定义的事件处理函数（视图中绑定的） viewTap: function() &#123;//setData设置data值，同时将更新视图 this.setData(&#123;text: &apos;Set some data for updating view.&apos;&#125;) &#125;&#125;) 3、小程序的视图与事件绑定 在每个页面中的wxml文件中，对页面js中data进行数据绑定，以及自定义事件绑定 1234567891011121314151617181920&lt;!--&#123;&#123;&#125;&#125;绑定data中的指定数据并渲染到视图--&gt;&lt;view class=&quot;title&quot;&gt;&#123;&#123;text&#125;&#125;&lt;/view&gt;&lt;!--wx:for获取数组数据进行循环渲染，item为数组的每项--&gt;&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt;&lt;!--wx:if条件渲染--&gt;&lt;view wx:if=&quot;&#123;&#123;view == &apos;WEBVIEW&apos;&#125;&#125;&quot;&gt; WEBVIEW &lt;/view&gt;&lt;view wx:elif=&quot;&#123;&#123;view == &apos;APP&apos;&#125;&#125;&quot;&gt; APP &lt;/view&gt;&lt;view wx:else=&quot;&#123;&#123;view == &apos;MINA&apos;&#125;&#125;&quot;&gt; MINA &lt;/view&gt;&lt;!--模板--&gt;&lt;template name=&quot;staffName&quot;&gt; &lt;view&gt;FirstName: &#123;&#123;firstName&#125;&#125;, LastName: &#123;&#123;lastName&#125;&#125;&lt;/view&gt;&lt;/template&gt;&lt;template is=&quot;staffName&quot; data=&quot;&#123;&#123;...template.staffA&#125;&#125;&quot;&gt;&lt;/template&gt;&lt;template is=&quot;staffName&quot; data=&quot;&#123;&#123;...template.staffB&#125;&#125;&quot;&gt;&lt;/template&gt;&lt;!--bindtap指定tap事件处理函数为ViewTap--&gt;&lt;view bindtap=&quot;ViewTap&quot;&gt; 点我点我 &lt;/view&gt; 123456789101112Page(&#123; data: &#123;//data数据主要用于视图绑定 text:&quot;我是一条测试&quot;, array:[0,1,2,3,4], view:&quot;APP&quot;, template:&#123; staffA: &#123;firstName: &apos;Hulk&apos;, lastName: &apos;Hu&apos;&#125;, staffB: &#123;firstName: &apos;Shang&apos;, lastName: &apos;You&apos;&#125; &#125; &#125;, ViewTap:function()&#123;console.log(&apos;额，点到我了了~&apos;)&#125;//自定义事件，主要用于事件绑定&#125;) 4、小程序的样式 在每个页面中的wxss文件中，对wxml中的结构进行样式设置，等同于css，扩展了rpx单位。其中app.wxss默认为全局样式，作用所有页面。 三、小程序实战-天气预报（利用和风天气API） 先看看完成后的效果，一共三个页面，测试demo不求美观，不喜勿喷~ 1、设置底部菜单和页面 我们就在quick start生成的demo基础上进行修改即可，因为涉及图标icon，我们新建一个images文件夹来存放图片 在原先pages文件夹中，删除index和log页面文件夹，新建weather、city、about三个页面文件夹，及三个页面对应的四个文件类型，文件结构如下图 接下来配置app.json文件 123456789101112131415161718192021222324252627282930313233343536373839/*app.json,该文件不能含有任何注释，所以正式应用需删除所有注释内容*/&#123; &quot;pages&quot;:[//小程序的页面路径数组，第一条默认为首页，所有页面均需写在这里，否则不能加载 &quot;pages/weather/weather&quot;, &quot;pages/about/about&quot;, &quot;pages/city/city&quot; ], &quot;window&quot;:&#123;//小程序框架设置 &quot;navigationBarBackgroundColor&quot;: &quot;#000&quot;, &quot;navigationBarTitleText&quot;: &quot;天气预报&quot;, &quot;navigationBarTextStyle&quot;:&quot;#fff&quot;, &quot;backgroundColor&quot;:&quot;#666&quot;, &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;enablePullDownRefresh&quot;:true &#125;, &quot;tabBar&quot;: &#123;//小程序底部菜单设置 &quot;color&quot;: &quot;#666&quot;, &quot;selectedColor&quot;: &quot;#56abe4&quot;, &quot;backgroundColor&quot;: &quot;#ddd&quot;, &quot;borderStyle&quot;:&quot;black&quot;, &quot;list&quot;: [&#123; &quot;pagePath&quot;: &quot;pages/weather/weather&quot;, &quot;iconPath&quot;: &quot;images/tabbar/weather1.png&quot;, &quot;selectedIconPath&quot;: &quot;images/tabbar/weather2.png&quot;, &quot;text&quot;: &quot;天气预报&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/city/city&quot;, &quot;iconPath&quot;: &quot;images/tabbar/city1.png&quot;, &quot;selectedIconPath&quot;: &quot;images/tabbar/city2.png&quot;, &quot;text&quot;: &quot;设置城市&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/about/about&quot;, &quot;iconPath&quot;: &quot;images/tabbar/about1.png&quot;, &quot;selectedIconPath&quot;: &quot;images/tabbar/about2.png&quot;, &quot;text&quot;: &quot;关于我&quot; &#125;], &quot;position&quot;:&quot;bottom&quot; &#125;&#125; 2、注册小程序和整体样式 修改app.js和app.wxss两个文件如下 12345678910111213141516//app.jsApp(&#123; //1、系统事件部分 onLaunch: function () &#123;//小程序初始化时执行 var that=this; that.curid = wx.getStorageSync(&apos;curid&apos;) || that.curid;//API：获取本地缓存，若不存在设置为全局属性 that.setlocal(&apos;curid&apos;, that.curid);//调用全局方法 &#125;, //2、自定义全局方法部分 setlocal:function(id,val)&#123; wx.setStorageSync(id, val);//API：设置本地缓存 &#125;, //3、自定义全局属性部分 curid:&quot;CN101010100&quot;, version:&quot;1.0&quot;&#125;) 123/**app.wxss**/.container &#123;margin: 0; padding: 0;&#125;.title&#123;font-size: 14px; font-weight: bold;&#125; 3、页面的结构（wxml）、样式（wxss）、逻辑（js）和配置（json） 小程序中的wxml摒弃了HTML标签， 改用view（类似div）、text（类似span）、icon等等，class同html指定样式，bindtap绑定事件（类似onclick），该页面无特殊配置，json文件内容为空（非必须文件） 12345678&lt;!--weather.wxml--&gt;&lt;view class=&quot;container&quot;&gt; &lt;view class=&quot;city&quot; bindtap=&quot;bindViewTap&quot;&gt; &lt;text&gt;当前城市：&#123;&#123;basic.city&#125;&#125;&lt;/text&gt;&lt;!--&#123;&#123;&#125;&#125;用来获取同页js文件中注册页面data中的数据--&gt; &lt;text class=&quot;update&quot;&gt;&#123;&#123;basic.update.loc&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt;&lt;!--省略。。。--&gt; 1234/**weather.wxss**/.city &#123;padding: 3% 5%; background: #ddd;&#125;.city text&#123;font-size: 16px; color: #666;&#125;.city .update&#123; font-size: 12px; float: right;&#125; 1234567891011121314151617181920212223242526//weather.jsvar app = getApp();//获取当前小程序实例，方便使用全局方法和属性Page(&#123; //1、页面数据部分,将绑定到视图wxml中 data:&#123;cur_id:app.curid,basic:&quot;&quot;,now:&quot;&quot;&#125;,//设置页面数据，后面空值将在页面显示时通过请求服务器获取 //2、系统事件部分 onShow:function()&#123; var that = this; wx.showToast(&#123;title: &apos;加载中&apos;,icon: &apos;loading&apos;,duration: 10000&#125;)//设置加载模态框 that.getnow(function(d)&#123;//回调函数，根据数据设置页面data，更新到视图 wx.hideToast();//隐藏加载框 d.now.cond.src=&quot;http://files.heweather.com/cond_icon/&quot;+d.now.cond.code+&quot;.png&quot;; that.setData(&#123;basic:d.basic,now:d.now&#125;)//更新数据，视图将同步更新 &#125;)&#125;, //3、自定义页面方法：获取当前天气API getnow:function(fn)&#123; wx.request(&#123;//请求服务器，类似ajax url: &apos;https://free-api.heweather.com/v5/now&apos;, data: &#123;city:app.curid,key:&apos;01a7798b060b468abdad006ea3de4713&apos;&#125;,//和风天气提供用户key，可自行注册获得 header: &#123;&apos;Content-Type&apos;: &apos;application/json&apos;&#125;, success: function(res) &#123;fn(res.data.HeWeather5[0]);&#125;//成功后将数据传给回调函数执行 &#125;) &#125;, //4、页面事件绑定部分 bindViewTap:function()&#123;wx.switchTab(&#123;url: &apos;../city/city&apos;&#125;)&#125;//跳转菜单页面 &#125;) 其他页面代码略，项目源文件见GitHub：https://github.com/gavin125/wxtest 4、注意防坑 跳转并刷新页面：需使用onshow来代替onload执行逻辑，onload只在首次打开页面时执行一次。如：B页面操作全局数据并跳转A页面，A页面onshow中获取全局数据更新视图。","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"微信小程序入门指南-（准备篇）","slug":"微信小程序入门指南-（准备篇）","date":"2018-09-07T02:56:40.000Z","updated":"2018-09-07T03:43:19.097Z","comments":true,"path":"2018/09/07/微信小程序入门指南-（准备篇）/","link":"","permalink":"http://yoursite.com/2018/09/07/微信小程序入门指南-（准备篇）/","excerpt":"","text":"引言微信小程序，简称小程序，英文名Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。 小程序现在作为越来越多的企业或公司的选择，所以这门技术也是作为一个前端所必须掌握的一个开发技能。 简单介绍一下小程序的发展历程，让大家对小程序能有个更加清晰的了解，同时页是帮自己梳理知识网络。 2016年1月11日，微信之父张小龙时隔多年的公开亮相，解读了微信的四大价值观。张小龙指出，越来越多产品通过公众号来做，因为这里开发、获取用户和传播成本更低。拆分出来的服务号并没有提供更好的服务，所以微信内部正在研究新的形态，叫「微信小程序」。 2016年9月21日，微信小程序正式开启内测。在微信生态下，触手可及、用完即走的微信小程序引起广泛关注。腾讯云正式上线微信小程序解决方案，提供小程序在云端服务器的技术方案。 2017年1月9日0点，万众瞩目的微信第一批小程序正式低调上线，用户可以体验到各种各样小程序提供的服务。 2017年12月28日，微信更新的 6.6.1 版本开放了小游戏，微信启动页面还重点推荐了小游戏「跳一跳」，你可以通过「小程序」找到已经玩过的小游戏。 2018年1月18日，微信提供了电子化的侵权投诉渠道，用户或者企业可以在微信公众平台以及微信客户端入口进行投诉。 2018年1月25日，微信团队在“微信公众平台”发布公告称，“从移动应用分享至微信的小程序页面，用户访问时支持打开来源应用。同时，为提升用户使用体验，开发者可以设置小程序菜单的颜色风格，并根据业务需求，对小程序菜单外的标题栏区域进行自定义。 2018年3月，微信正式宣布小程序广告组件启动内测，内容还包括第三方可以快速创建并认证小程序、新增小程序插件管理接口和更新基础能力，开发者可以通过小程序来赚取广告收入。 [5] 除了公众号文中、朋友圈广告以及公众号底部的广告位都支持小程序落地页投放广告，小程序广告位也可以直达小程序。 2018年7月13日，小程序任务栏功能升级，新增“我的小程序”板块；而小程序原有的“星标”功能升级，可以将喜欢的小程序直接添加到“我的小程序”。 2018年8月10日，微信宣布，小程序后台数据分析及插件功能升级，开发者可查看已添加「我的小程序」的用户数。此外，2018年8月1日至12月31日期间，小程序（含小游戏）流量主的广告收入分成比例优化上调，单日广告流水10-100万区间的部分，开发者可获得的分成由原来流水的30%上调到50%，优质小程序流量主可获得更高收益。 好了，基本介绍就到这里，进入正题！ 小程序注册第一步：你必须得有一个自己的微信小程序账号，这个跟着官网一步一步往下走跟着注册就对了，完成注册后，微信小程序信息完善步骤和开发可同步进行。 第二步：选择注册的账号类型，不同的账号类型有各自的区别和优势。 第三步：填写邮箱和密码，然后激活邮箱。 第四步：完善主体信息和管理员信息（个人、企业、个体工商户、政府、媒体、其他组织），确认主体信息后不可更改，确认后完成注册流程。 小程序开发前准备第一步：登录小程序管理平台。在微信公众平台官网首页（mp.weixin.qq.com）的登录入口直接登录。 第二步：完善小程序信息，完成注册后，微信小程序信息完善步骤和开发此时都可以去执行了。 ​ 选择对公打款的用户，完成汇款验证后，可以补充小程序名称信息，上传小程序头像，填写小程序介绍并选择服务范围。 ​ 选择通过微信认证验证主体身份的用户，需先完成微信认证后，才可以补充小程序名称信息，上传小程序头像，填写小程序介绍并选择服务范围。 ​ 面向个人开发者开放的服务类目，会随着相关政策、法律法规以及平台规定的变化而变化，开发者以提交时开放的类目为准。 第三步：开发前准备，绑定开发者。 ​ 登录微信公众平台小程序，进入用户身份-开发者，新增绑定开发者。 ​ 个人主体小程序最多可绑定5个开发者，10个体验者。 ​ 未认证的组织类型小程序最多可绑定10个开发者，20个体验者 ​ 已认证的小程序最多可绑定20个开发者，40个体验者。 第四步：配置APPID，进入设置-开发设置，获取APPid信息。 第五步：登录微信公众平台小程序，进入开发管理，开发版本中展示已上传的代码，管理员可提交审核或是删除代码。 当小程序需要开发者提供测试帐号才能完成审核体验时，小程序在首次提交审核时将被打回，再次提交审核时将开放提供测试帐号的入口，该入口将由开发者提供帐号给微信审核人员审核微信小程序时登录使用。 第六步：完成提交，提交审核完成后，开发管理页中审核版本模块展示审核进度。 以上为小程序入门指南，简单介绍开发小程序需要做哪些准备，下篇文章介绍具体开发时使用技巧及原理。","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"JS基础知识整理（三）","slug":"JS基础知识整理（三）","date":"2018-09-01T03:48:17.000Z","updated":"2018-09-01T05:13:57.893Z","comments":true,"path":"2018/09/01/JS基础知识整理（三）/","link":"","permalink":"http://yoursite.com/2018/09/01/JS基础知识整理（三）/","excerpt":"","text":"引言前面介绍了JS中变量和对象的概念，这篇内容将描述JS实际的组成和一些核心操作。 JS由三部分组成ECMAScript: (3/5/6/7)它是JS语言的标准,规定了JS的编程语法和基础核心知识 DOM: document object model 文档对象模型,提供给JS很多操作页面中元素的属性和方法 BOM: browser object model 浏览器对象模型 ,提供了很多操作浏览器 的属性方法,而这些方法都存放在window浏览器对象上 ECMAScript(ES) ECMAScript是一种由Ecma国际(前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association)通过ECMA-262标准化的脚本程序设计语言。现在貌似已经更新到ES7了都，不过工作中其实用的最多的还是ES5和ES6的写法，后面可以单独抽出一篇讲讲ES6的一些新特性，这里不展开讨论。 BOM及其组成BOM其实就是浏览器对象模型，提供了一些操作浏览器对象的属性和方法，接下来将一个一个走近他们。 Window对象window对象一般作为浏览器的顶层对象，其下又包括document,history,location,navigator,screen对象。 Window 对象表示浏览器中打开的窗口。 如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对 象，并为每个框架创建一个额外的 window 对象。 注释：没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象。 window对象属性 属性 描述 closed 返回窗口是否已被关闭。 defaultStatus 设置或返回窗口状态栏中的默认文本。 document 对 Document 对象的只读引用。请参阅 Document 对象。 history 对 History 对象的只读引用。请参数 History 对象。 innerheight 返回窗口的文档显示区的高度。 innerwidth 返回窗口的文档显示区的宽度。 length 设置或返回窗口中的框架数量。 location 用于窗口或框架的 Location 对象。请参阅 Location 对象。 name 设置或返回窗口的名称。 Navigator 对 Navigator 对象的只读引用。请参数 Navigator 对象。 opener 返回对创建此窗口的窗口的引用。 outerheight 返回窗口的外部高度。 outerwidth 返回窗口的外部宽度。 pageXOffset 设置或返回当前页面相对于窗口显示区左上角的 X 位置。 pageYOffset 设置或返回当前页面相对于窗口显示区左上角的 Y 位置。 parent 返回父窗口。 Screen 对 Screen 对象的只读引用。请参数 Screen 对象。 self 返回对当前窗口的引用。等价于 Window 属性。 status 设置窗口状态栏的文本。 top 返回最顶层的先辈窗口。 window window 属性等价于 self 属性，它包含了对窗口自身的引用。 screenLeftscreenTopscreenXscreenY 只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。IE、Safari 和 Opera 支持 screenLeft 和 screenTop，而 Firefox 和 Safari 支持 screenX 和 screenY。 Window 对象方法 方法 描述 alert() 显示带有一段消息和一个确认按钮的警告框。 blur() 把键盘焦点从顶层窗口移开。 clearInterval() 取消由 setInterval() 设置的 timeout。 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 close() 关闭浏览器窗口。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 createPopup() 创建一个 pop-up 窗口。 focus() 把键盘焦点给予一个窗口。 moveBy() 可相对窗口的当前坐标把它移动指定的像素。 moveTo() 把窗口的左上角移动到一个指定的坐标。 open() 打开一个新的浏览器窗口或查找一个已命名的窗口。 print() 打印当前窗口的内容。 prompt() 显示可提示用户输入的对话框。 resizeBy() 按照指定的像素调整窗口的大小。 resizeTo() 把窗口的大小调整到指定的宽度和高度。 scrollBy() 按照指定的像素值来滚动内容。 scrollTo() 把内容滚动到指定的坐标。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 一般来说，Window 对象的方法都是对浏览器窗口或框架进行某种操作。而 alert() 方法、confirm() 方法和 prompt 方法则不同，它们通过简单的对话框与用户进行交互。 Navigator对象Navigator 对象包含有关浏览器的信息。 注释：没有应用于 navigator 对象的公开标准，不过所有浏览器都支持该对象。 Navigator 对象属性 属性 描述 appCodeName 返回浏览器的代码名。 appMinorVersion 返回浏览器的次级版本。 appName 返回浏览器的名称。 appVersion 返回浏览器的平台和版本信息。 browserLanguage 返回当前浏览器的语言。 cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值。 cpuClass 返回浏览器系统的 CPU 等级。 onLine 返回指明系统是否处于脱机模式的布尔值。 platform 返回运行浏览器的操作系统平台。 systemLanguage 返回 OS 使用的默认语言。 userAgent 返回由客户机发送服务器的 user-agent 头部的值。 userLanguage 返回 OS 的自然语言设置。 Navigator 对象方法 方法 描述 javaEnabled() 规定浏览器是否启用 Java。 taintEnabled() 规定浏览器是否启用数据污点 (data tainting)。 Navigator对象描述Navigator 对象包含的属性描述了正在使用的浏览器。可以使用这些属性进行平台专用的配置。 虽然这个对象的名称显而易见的是 Netscape 的 Navigator 浏览器，但其他实现了 JavaScript 的浏览器也支持这个对象。 Navigator 对象的实例是唯一的，可以用 Window 对象的 navigator 属性来引用它。 Location对象Location 对象包含有关当前 URL 的信息。 Location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。 Location 对象属性 属性 描述 hash 设置或返回从井号 (#) 开始的 URL（锚）。 host 设置或返回主机名和当前 URL 的端口号。 hostname 设置或返回当前 URL 的主机名。 href 设置或返回完整的 URL。 pathname 设置或返回当前 URL 的路径部分。 port 设置或返回当前 URL 的端口号。 protocol 设置或返回当前 URL 的协议。 search 设置或返回从问号 (?) 开始的 URL（查询部分）。 Location 对象方法 属性 描述 assign() 加载新的文档。 reload() 重新加载当前文档。 replace() 用新的文档替换当前文档。 Location 对象描述Location 对象存储在 Window 对象的 Location 属性中，表示那个窗口中当前显示的文档的 Web 地址。它的 href 属性存放的是文档的完整 URL，其他属性则分别描述了 URL 的各个部分。这些属性与 Anchor 对象（或 Area 对象）的 URL 属性非常相似。当一个 Location 对象被转换成字符串，href 属性的值被返回。这意味着你可以使用表达式 location 来替代 location.href。 不过 Anchor 对象表示的是文档中的超链接，Location 对象表示的却是浏览器当前显示的文档的 URL（或位置）。但是 Location 对象所能做的远远不止这些，它还能控制浏览器显示的文档的位置。如果把一个含有 URL 的字符串赋予 Location 对象或它的 href 属性，浏览器就会把新的 URL 所指的文档装载进来，并显示出来。 除了设置 location 或 location.href 用完整的 URL 替换当前的 URL 之外，还可以修改部分 URL，只需要给 Location 对象的其他属性赋值即可。这样做就会创建新的 URL，其中的一部分与原来的 URL 不同，浏览器会将它装载并显示出来。例如，假设设置了Location对象的 hash 属性，那么浏览器就会转移到当前文档中的一个指定的位置。同样，如果设置了 search 属性，那么浏览器就会重新装载附加了新的查询字符串的 URL。 除了 URL 属性外，Location 对象的 reload() 方法可以重新装载当前文档，replace() 可以装载一个新文档而无须为它创建一个新的历史记录，也就是说，在浏览器的历史列表中，新文档将替换当前文档。 History对象History 对象包含用户（在浏览器窗口中）访问过的 URL。 History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。 注释：没有应用于 History 对象的公开标准，不过所有浏览器都支持该对象。 History 对象属性 属性 描述 length 返回浏览器历史列表中的 URL 数量。 History 对象方法 方法 描述 back() 加载 history 列表中的前一个 URL。 forward() 加载 history 列表中的下一个 URL。 go() 加载 history 列表中的某个具体页面。 History 对象描述History 对象最初设计来表示窗口的浏览历史。但出于隐私方面的原因，History 对象不再允许脚本访问已经访问过的实际 URL。唯一保持使用的功能只有 back()、forward() 和 go() 方法。 Screen对象Screen 对象包含有关客户端显示屏幕的信息。 注释：没有应用于 screen 对象的公开标准，不过所有浏览器都支持该对象。 Screen 对象属性 属性 描述 availHeight 返回显示屏幕的高度 (除 Windows 任务栏之外)。 availWidth 返回显示屏幕的宽度 (除 Windows 任务栏之外)。 bufferDepth 设置或返回调色板的比特深度。 colorDepth 返回目标设备或缓冲器上的调色板的比特深度。 deviceXDPI 返回显示屏幕的每英寸水平点数。 deviceYDPI 返回显示屏幕的每英寸垂直点数。 fontSmoothingEnabled 返回用户是否在显示控制面板中启用了字体平滑。 height 返回显示屏幕的高度。 logicalXDPI 返回显示屏幕每英寸的水平方向的常规点数。 logicalYDPI 返回显示屏幕每英寸的垂直方向的常规点数。 pixelDepth 返回显示屏幕的颜色分辨率（比特每像素）。 updateInterval 设置或返回屏幕的刷新率。 width 返回显示器屏幕的宽度。 Screen 对象描述每个 Window 对象的 screen 属性都引用一个 Screen 对象。Screen 对象中存放着有关显示浏览器屏幕的信息。JavaScript 程序将利用这些信息来优化它们的输出，以达到用户的显示要求。例如，一个程序可以根据显示器的尺寸选择使用大图像还是使用小图像，它还可以根据显示器的颜色深度选择使用 16 位色还是使用 8 位色的图形。另外，JavaScript 程序还能根据有关屏幕尺寸的信息将新的浏览器窗口定位在屏幕中间。 DOM Document每个载入浏览器的 HTML 文档都会成为 Document 对象。 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 Document 对象集合 集合 描述 all[] 提供对文档中所有 HTML 元素的访问。 anchors[] 返回对文档中所有 Anchor 对象的引用。 applets 返回对文档中所有 Applet 对象的引用。 forms[] 返回对文档中所有 Form 对象引用。 images[] 返回对文档中所有 Image 对象引用。 links[] 返回对文档中所有 Area 和 Link 对象引用。 Document 对象属性 属性 描述 body 提供对 元素的直接访问。对于定义了框架集的文档，该属性引用最外层的 。 cookie 设置或返回与当前文档有关的所有 cookie。 domain 返回当前文档的域名。 lastModified 返回文档被最后修改的日期和时间。 referrer 返回载入当前文档的文档的 URL。 title 返回当前文档的标题。 URL 返回当前文档的 URL。 Document 对象方法 方法 描述 close() 关闭用 document.open() 方法打开的输出流，并显示选定的数据。 getElementById() 返回对拥有指定 id 的第一个对象的引用。 getElementsByName() 返回带有指定名称的对象集合。 getElementsByTagName() 返回带有指定标签名的对象集合。 getElementsByClassName() 返回带有指定类名的对象集合 querySelector() 返回符合选择器的第一个元素 querySelectorAll() 返回符合选择器的所有元素 open() 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。 write() 向文档写 HTML 表达式 或 JavaScript 代码。 writeln() 等同于 write() 方法，不同的是在每个表达式之后写一个换行符。 DOM对象及其组成DOM分类核心DOM 公用接口处理树结构 XML DOM 操作XML文档 HTML DOM 操作HTML文档 HTML DOM事件模型 事件响应，让页面具有交互能力 CSS DOM 操作CSS样式 节点的类型文档节点 document 元素节点 element 属性节点 attrobute 文本节点 text DOM节点对象遍历节点parentNode 返回父亲节点 childNodes 返回所有子节点的集合 firstElementChild 返回大儿子元素节点 lastElementChild 返回小儿子元素节点 nextElementChild 返回下一个兄弟元素节点 previousElement 返回上一个兄弟元素节点 删除节点父节点.removeChild(子节点) 要被删除的节点.remove() 父节点.hasChildNodes 有子节点返回true,否则false 添加节点创建元素节点 document.createElement(“标签名称”) 创建文本节点 document.createTextNode(“文本内容”) 设置属性 节点.setAttribute(“属性名称”,”属性值”) 获取属性 节点.getAttribute(“属性名”) 替换节点父节点.replaceChild(新节点,旧节点) 节点.innerHTML=”HTML内容” 节点.innerText=”文本内容” 复制节点目标节点.cloneNode(是否克隆子节点和属性)","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JS基础知识整理（二）","slug":"JS基础知识整理（二）","date":"2018-08-27T06:32:30.000Z","updated":"2018-08-28T08:14:08.004Z","comments":true,"path":"2018/08/27/JS基础知识整理（二）/","link":"","permalink":"http://yoursite.com/2018/08/27/JS基础知识整理（二）/","excerpt":"","text":"引言 前一篇博客在讲JS中的变量，涉及到很多非常基础的概念，这边将会着重讲到JS中的对象。 JS对象JS对象JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…，此外，JavaScript 允许自定义对象。 JavaScript 提供多个内建对象，比如 String、Date、Array 等等。 对象只是带有属性和方法的特殊数据类型。所以我们早探讨一个对象时，就主要从它的属性和方法上研究。 JavaScript Array对象数组对象的作用是：使用单独的变量名来存储一系列的值。 这里不去过多的讲基础概念，而是将平时回用到的方法和属性例举出来： constructor属性constructor 属性返回对创建此对象的数组函数的引用。 语法 object.constructor 实例 在本例中，我们将展示如何使用 constructor 属性： 1234567891011function employee(name,job,born)&#123;this.name=name;this.job=job;this.born=born;&#125;var bill=new employee(\"Bill Gates\",\"Engineer\",1985);document.write(bill.constructor);//输出//function employee(name, jobtitle, born)//&#123;this.name = name; this.jobtitle = job; this.born = born;&#125; length属性length 属性可设置或返回数组中元素的数目。 语法arrayObject.length 数组的 length 属性总是比数组中定义的最后一个元素的下标大 1。对于那些具有连续元 素，而且以元素 0 开始的常规数组而言，属性 length 声明了数组中的元素的个数。 数组的 length 属性在用构造函数 Array() 创建数组时被初始化。给数组添加新元素时，如 果必要，将更新 length 的值。 设置 length 属性可改变数组的大小。如果设置的值比其当前值小，数组将被截断，其尾部 的元素将丢失。如果设置的值比它的当前值大，数组将增大，新的元素被添加到数组的尾部， 它们的值为 undefined。 concat()方法concat() 方法用于连接两个或多个数组。 该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本 语法 arrayObject.concat(arrayX,arrayX,......,arrayX) 参数 描述 arrayX 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。 实例 12var a = [1,2,3];document.write(a.concat(4,5)); //1,2,3,4,5 join()方法join() 方法用于把数组中的所有元素放入一个字符串。 元素是通过指定的分隔符进行分隔的。 语法arrayObject.join(separator) 参数 描述 separator 可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。 返回值 返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字 符串连接起来，在两个元素之间插入 separator 字符串而生成的。 实例 12345var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr.join())//George,John,Thomas pop()方法pop() 方法用于删除并返回数组的最后一个元素。 语法 arrayObject.pop() 返回值 arrayObject 的最后一个元素 说明 pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素 的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。 push()方法push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 语法 arrayObject.push(newelement1,newelement2,....,newelementX) 参数 描述 newelement1 必需。要添加到数组的第一个元素。 newelement2 可选。要添加到数组的第二个元素。 newelementX 可选。可添加多个元素。 返回值 把指定的值添加到数组后的新长度 说明 push() 方法可把它的参数顺序添加到 arrayObject 的尾部。它直接修改 arrayObject，而不 是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。 shift()方法shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 语法 arrayObject.shift() 返回值 数组原来的第一个元素的值。 unshift()方法unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 语法arrayObject.unshift(newelement1,newelement2,....,newelementX) 参数 描述 newelement1 必需。向数组添加的第一个元素。 newelement2 可选。向数组添加的第二个元素。 newelementX 可选。可添加若干个元素。 返回值 arrayObject 的新长度。 小结：如果是删除元素，返回该元素值，如果是增加元素，返回新的长度值；都是操作原数组，不会产生新数组 reverse()方法reverse() 方法用于颠倒数组中元素的顺序。 语法 arrayObject.reverse() 提示 该方法回改变原来的数组，而不会创建新数组 实例 123456var arr = new Array(3)arr[0] = \"George\"arr[1] = \"John\"arr[2] = \"Thomas\"document.write(arr + \"&lt;br /&gt;\") //George,John,Thomasdocument.write(arr.reverse()) //Thomas,John,George sort()方法sort() 方法用于对数组的元素进行排序。 语法arrayObject.sort(sortby) 参数 描述 sortby 可选。规定排序顺序。必须是函数。 返回值 对数组的引用。 请注意，数组在原数组上进行排序，不生成副本。 说明 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点， 是按照字符编码的顺序进行排序(ASCII编码)。要实现这一点，首先应把数组的元素都转换成字符串（如 有必要），以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个 用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：  若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。  若 a 等于 b，则返回 0。  若 a 大于 b，则返回一个大于 0 的值 实例 创建一个数组，并按字母顺序进行排序： 123456789var arr = new Array(6)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;arr[3] = &quot;James&quot;arr[4] = &quot;Adrew&quot;arr[5] = &quot;Martin&quot;document.write(arr + &quot;&lt;br /&gt;&quot;) //George,John,Thomas,James,Adrew,Martindocument.write(arr.sort()) //Adrew,George,James,John,Martin,Thomas 例2 我们将创建一个数组，并按字母顺序进行排序： 123456789var arr = new Array(6)arr[0] = &quot;10&quot;arr[1] = &quot;5&quot;arr[2] = &quot;40&quot;arr[3] = &quot;25&quot;arr[4] = &quot;1000&quot;arr[5] = &quot;1&quot;document.write(arr + &quot;&lt;br /&gt;&quot;) //10,5,40,25,1000,1document.write(arr.sort()) //1,10,1000,25,40,5 若需要以数字大小排序，就必须使用一个排序函数 12345678910111213function sortNumber(a,b)&#123;return a - b&#125;var arr = new Array(6)arr[0] = &quot;10&quot;arr[1] = &quot;5&quot;arr[2] = &quot;40&quot;arr[3] = &quot;25&quot;arr[4] = &quot;1000&quot;arr[5] = &quot;1&quot;document.write(arr + &quot;&lt;br /&gt;&quot;) //10,5,40,25,1000,1document.write(arr.sort(sortNumber)) //1,5,10,25,40,1000 slice()方法slice() 方法可从已有的数组中返回选定的元素。 语法 arrayObject.slice(start,end) 参数 描述 start 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。 也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定 该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负 数，那么它规定的是从数组尾部开始算起的元素。 返回值 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。 说明 请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应 该使用方法 Array.splice()。 注释：您可使用负值从数组的尾部选取元素。 注释：如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。 实例 1234567var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr + &quot;&lt;br /&gt;&quot;) //George,John,Thomasdocument.write(arr.slice(1) + &quot;&lt;br /&gt;&quot;) //John,Thomasdocument.write(arr) //George,John,Thomas splice()方法splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目，该方法非常强大，既可以删除数组元素也可以增加数组元素 注释：该方法会改变原始数组。 语法 arrayObject.splice(index,howmany,item1,.....,itemX) 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规 定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX 可选。向数组添加的新项目 返回值 类型 Array 描述 包含被删除项目的新数组，如果有的话 说明 splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多 个值来替换那些被删除的元素。 如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。 实例 12345678910var arr = new Array(6)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;arr[3] = &quot;James&quot;arr[4] = &quot;Adrew&quot;arr[5] = &quot;Martin&quot;document.write(arr + &quot;&lt;br /&gt;&quot;) //George,John,Thomas,James,Adrew,Martinarr.splice(2,0,&quot;William&quot;)document.write(arr + &quot;&lt;br /&gt;&quot;) //George,John,William,Thomas,James,Adrew,Martin toString()方法toString() 方法可把数组转换为字符串，并返回结果 语法 arrayObject.toString() 返回值 arrayObject 的字符串表示。返回值与没有参数的 join() 方法返回的字符串相同。 说明 当数组用于字符串环境时，JavaScript 会调用这一方法将数组自动转换成字符串。但是在某 些情况下，需要显式地调用该方法。 提示和注释 注释：数组中的元素之间用逗号分隔。 实例 12345var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr.toString()) //George,John,Thomas toLocaleString()方法把数组转换为本地字符串。 语法 arrayObject.toLocaleString() 返回值 arrayObject 的本地字符串表示。 说明 首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符 串连接起来，形成一个字符串。 实例 12345var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr.toLocaleString()) //George, John, Thomas toString和toLocaleString的区别 toString()方法获取的是String(传统字符串),而toLocaleString()方法获取的是LocaleString(本地环境字符串)。 如果你开发的脚本在世界范围都有人使用，那么将对象转换成字符串时请使用toString()方法来完成。 LocaleString()会根据你机器的本地环境来返回字符串，它和toString()返回的值在不同的本地环境下使用的符号会有微妙的变化。 所以使用toString()是保险的，返回唯一值的方法,它不会因为本地环境的改变而发生变化。如果是为了返回时间类型的数据，推荐使用LocaleString()。若是在后台处理字符串，请务必使用toString()。 valueOf()方法valueOf() 方法返回 Array 对象的原始值。 该原始值由 Array 对象派生的所有对象继承。 valueOf() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。 语法arrayObject.valueOf() JavaScript String对象String 对象描述字符串是 JavaScript 的一种基本的数据类型。 String 对象的 length 属性声明了该字符串中的字符数。 String 类定义了大量操作字符串的方法，例如从字符串中提取字符或子串，或者检索字符或 子串。 需要注意的是，JavaScript 的字符串是不可变的（immutable），String 类定义的方法都不能 改变字符串的内容。像 String.toUpperCase() 这样的方法，返回的是全新的字符串，而不是 修改原始字符串。 在较早的 Netscape 代码基的 JavaScript 实现中（例如 Firefox 实现中），字符串的行为就像 只读的字符数组。例如，从字符串 s 中提取第三个字符，可以用 s[2] 代替更加标准的 s.charAt(2)。此外，对字符串应用 for/in 循环时，它将枚举字符串中每个字符的数组下标（但 要注意，ECMAScript 标准规定，不能枚举 length 属性）。因为字符串的数组行为不标准， 所以应该避免使用它。 length属性length 属性可返回字符串中的字符数目。 语法 stringObject.length charAt() 方法charAt() 方法可返回指定位置的字符。 请注意，JavaScript 并没有一种有别于字符串类型的字符数据类型，所以返回的字符是长度 为 1 的字符串。 语法stringObject.charAt(index) 参数 描述 index 必需。表示字符串中某个位置的数字，即字符在字符串中的下标。 注释：字符串中第一个字符的下标是 0。如果参数 index 不在 0 与 string.length 之间，该 方法将返回一个空字符串。 concat() 方法concat() 方法用于连接两个或多个字符串。 语法stringObject.concat(stringX,stringX,...,stringX) 参数 描述 stringX 必需。将被连接为一个字符串的一个或多个字符串对象。 concat() 方法将把它的所有参数转换成字符串，然后按顺序连接到字符串 stringObject 的尾 部，并返回连接后的字符串。请注意，stringObject 本身并没有被更改。 stringObject.concat() 与 Array.concat() 很相似。 提示：请注意，使用 “ + “ 运算符来进行字符串的连接运算通常会更简便一些。 indexOf() 方法indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 语法 stringObject.indexOf(searchvalue,fromindex) 参数 描述 searchvalue 必需。规定需检索的字符串值。 fromindex 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。 注释：indexOf() 方法对大小写敏感！ 注释：如果要检索的字符串值没有出现，则该方法返回 -1。 replace() 方法replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配 的子串。 语法stringObject.replace(regexp/substr,replacement) 参数 描述 regexp/substr 必需。规定子字符串或要替换的模式的 RegExp 对象。 请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而 不是首先被转换为 RegExp 对象。 replacement 必需。一个字符串值。规定了替换文本或生成替换文本的函数。 返回值 一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的 。 说明 字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中 查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有 全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串 替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得 到的字符串将用于替换。 字符 替换文本 $1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 直接量符号。 实例 12var str=&quot;Visit Microsoft!&quot;document.write(str.replace(/Microsoft/, &quot;world&quot;)) //Visit world! substr() 方法substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。 语法stringObject.substr(start,length) 参数 描述 start 必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字 符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数 第二个字符，以此类推。 length 可 选 。 子 串 中 的 字 符 数 。 必 须 是 数 值 。 如 果 省 略 了 该 参 数 ， 那 么 返 回 从 stringObject 的开始位置到结尾的字串 。 返回值 一个 新的字 符串，包 含从 stringObject 的 start（包 括 start 所指 的字符 ） 处开 始 的 length 个字符。如果没有指定 length，那么返回的字符串包含从 start 到 stringObject 的结 尾的字符。 substring() 方法substring() 方法用于提取字符串中介于两个指定下标之间的字符。 语法 stringObject.substring(start,stop) 参数 描述 start 必需。一个非负的整数，规定要提取的子串的第一个字符在 stringObject 中的位 置。 stop 可选。一个非负的整数，比要提取的子串的最后一个字符在 stringObject 中的位 置多 1。 如果省略该参数，那么返回的子串会一直到字符串的结尾。 返回值 一个新的字符串，该字符串值包含 stringObject 的一个子字符串，其内容是从 start 处到 stop-1 处的所有字符，其长度为 stop 减 start。 说明 substring() 方法返回的子串包括 start 处的字符，但不包括 stop 处的字符。 如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如 果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。 重要事项：与 slice() 和 substr() 方法不同的是，substring() 不接受负的参数。 Number对象在 JavaScript 中，数字是一种基本的数据类型。JavaScript 还支持 Number 对象，该对象是 原始数值的包装对象。在必要时，JavaScript 会自动地在原始数据和对象之间转换。在 JavaScript 1.1 中，可以用构造函数 Number() 明确地创建一个 Number 对象，尽管这样做 并没有什么必要。 构造函数 Number() 可以不与运算符 new 一起使用，而直接作为转化函数来使用。以这种 方式调用 Number() 时，它会把自己的参数转化成一个数字，然后返回转换后的原始数值（或 NaN）。 构造函数通常还用作 5 个有用的数字常量的占位符，这 5 个有用的数字常量分别是可表示 的最大数、可表示的最小数、正无穷大、负无穷大和特殊的 NaN 值。 注意，这些值是构 造函数 Number() 自身的属性，而不是单独的某个 Number 对象的属性。 constructor属性constructor 属性返回对创建此对象的 Boolean 函数的引用。 语法 object.constructor MAX_VALUE属性MAX_VALUE 属性是 JavaScript 中可表示的最大的数。它的近似值为 1.7976931348623157 x 10308。 语法 Number.MAX_VALUE MIN_VALUE属性MIN_VALUE 属性是 JavaScript 中可表示的最小的数（接近 0 ，但不是负数）。它的近似值 为 5 x 10-324。 语法 Number.MIN_VALUE NaN属性NaN 属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对 象设置为该值，来指示其不是数字值。 提示：请使用 isNaN() 全局函数来判断一个值是否是 NaN 值。 语法 Number.NaN 说明 Number.NaN 是一个特殊值，说明某些算术运算（如求负数的平方根）的结果不是数字。方 法 parseInt() 和 parseFloat() 在不能解析指定的字符串时就返回这个值。对于一些常规情况 下返回有效数字的函数，也可以采用这种方法，用 Number.NaN 说明它的错误情况。 JavaScript 以 NaN 的形式输出 Number.NaN。请注意，NaN 与其他数值进行比较的结果总 是不相等的，包括它自身在内。因此，不能与 Number.NaN 比较来检测一个值是不是数字， 而只能调用 isNaN() 来比较。 在 ECMAScript v1 和其后的版本中，还可以用预定义的全局属性 NaN 代替 Number.NaN。 提示和注释 提示：请使用 isNaN() 来判断一个值是否是数字。原因是 NaN 与所有值都不相等，包括它 自己。 toString()方法toString() 方法可把一个 Number 对象转换为一个字符串，并返回结果。 语法 NumberObject.toString(radix) 参数 描述 radix 可选。规定表示数字的基数，是2 ~ 36 之间的整数。若省略该参数，则使用基数 10。 但是要注意，如果该参数是 10 以外的其他值，则 ECMAScript 标准允许实现返回 任意值。 返回值 数字的字符串表示。例如，当 radix 为 2 时，NumberObject 会被转换为二进制值表示的字 符串。 抛出 当调用该方法的对象不是 Number 时抛出 TypeError 异常。 toLocaleString() 方法toLocaleString() 方法可把一个 Number 对象转换为本地格式的字符串。 语法 NumberObject.toLocaleString() 返回值 数字的字符串表示，由实现决定，根据本地规范进行格式化，可能影响到小数点或千分位分 隔符采用的标点符号。 抛出 当调用该方法的对象不是 Number 时抛出 TypeError 异常。 toFixed()方法toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。 语法 NumberObject.toFixed(num) 参数 描述 num 必需。规定小数的位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实现可以支持更 大的数值范围。如果省略了该参数，将用 0 代替。 返回值 返回 NumberObject 的字符串表示，不采用指数计数法，小数点后有固定的 num 位数字。 如果必要，该数字会被舍入，也可以用 0 补足，以便它达到指定的长度。如果 num 大于 le+21，则该方法只调用 NumberObject.toString()，返回采用指数计数法表示的字符串。 抛出 当 num 太小或太大时抛出异常 RangeError。0 ~ 20 之间的值不会引发该异常。有些实现支 持更大范围或更小范围内的值。 当调用该方法的对象不是 Number 时抛出 TypeError 异常。 toExponential() 方法toExponential() 方法可把对象的值转换成指数计数法。 语法 NumberObject.toExponential(num) 参数 描述 num 必需。规定指数计数法中的小数位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实 现可以支持更大的数值范围。如果省略了该参数，将使用尽可能多的数字。 返回值 返回 NumberObject 的字符串表示，采用指数计数法，即小数点之前有一位数字，小数点之 后有 num 位数字。该数字的小数部分将被舍入，必要时用 0 补足，以便它达到指定的长 度。 抛出 当 num 太小或太大时抛出异常 RangeError。0 ~ 20 之间的值不会引发该异常。有些实现支 持更大范围或更小范围内的值。 当调用该方法的对象不是 Number 时抛出 TypeError 异常。 实例 12var num = new Number(10000);document.write (num.toExponential(1)) //1.0e+4 Boolean 对象constructor属性constructor 属性返回对创建此对象的 Boolean 函数的引用。 语法 object.constructor toString()方法toString() 方法可把一个逻辑值转换为字符串，并返回结果。 语法 booleanObject.toString() 返回值 根据原始布尔值或者 booleanObject 对象的值返回字符串 “true” 或 “false”。 抛出 如果调用该方法的对象不是 Boolean，则抛出异常 TypeError。 注释：在 Boolean 对象被用于字符串环境中时，此方法会被自动调用。 toSource()方法toSource() 方法返回表示对象源代码的字符串。 语法 object.toSource() 提示和注释 注释：该方法在 Internet Explorer 中无效。 实例 12345678function employee(name,job,born)&#123;this.name=name;this.job=job;this.born=born;&#125;var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);document.write(bill.toSource()); //(&#123;name:&quot;Bill Gates&quot;, job:&quot;Engineer&quot;, born:1985&#125;) valueOf()方法valueOf() 方法可返回 Boolean 对象的原始值。 语法 booleanObject.valueOf() 返回值 booleanObject 的原始布尔值。 抛出 如果调用该方法的对象不是 Boolean，则抛出异常 TypeError。 Date 对象Date 对象用于处理日期和时间。 创建 Date 对象的语法： var myDate=new Date() 注释：Date 对象会自动把当前日期和时间保存为其初始值。 Date 对象方法 方法 描述 Date() 返回当日的日期和时间。 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getFullYear() 从 Date 对象以四位数字返回年份。 getYear() 请使用 getFullYear() 方法代替。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。 getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。 getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。 getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。 getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。 getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。 parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。 setMonth() 设置 Date 对象中月份 (0 ~ 11)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setYear() 请使用 setFullYear() 方法代替。 setHours() 设置 Date 对象中的小时 (0 ~ 23)。 setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setTime() 以毫秒设置 Date 对象。 setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。 setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。 setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。 setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。 setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。 setUTCSeconds() 根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。 setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。 toSource() 返回该对象的源代码。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toDateString() 把 Date 对象的日期部分转换为字符串。 toGMTString() 请使用 toUTCString() 方法代替。 toUTCString() 根据世界时，把 Date 对象转换为字符串。 toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串。 toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 UTC() 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 valueOf() 返回 Date 对象的原始值。 Math对象Math 对象用于执行数学任务。 使用 Math 的属性和方法的语法： var pi_value=Math.PI; var sqrt_value=Math.sqrt(15); 注释：Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，不是某个对象的方法。您无需创建它，通过把 Math 作为 对象使用就可以调用其所有属性和方法。 Math 对象方法 方法 描述 abs(x) 返回数的绝对值。 acos(x) 返回数的反余弦值。 asin(x) 返回数的反正弦值。 atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。 ceil(x) 对数进行上舍入。 cos(x) 返回数的余弦。 exp(x) 返回 e 的指数。 floor(x) 对数进行下舍入。 log(x) 返回数的自然对数（底为e）。 max(x,y) 返回 x 和 y 中的最高值。 min(x,y) 返回 x 和 y 中的最低值。 pow(x,y) 返回 x 的 y 次幂。 random() 返回 0 ~ 1 之间的随机数。 round(x) 把数四舍五入为最接近的整数。 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根。 tan(x) 返回角的正切。 toSource() 返回该对象的源代码。 valueOf() 返回 Math 对象的原始值。","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JS基础知识整理（一）","slug":"JS基础知识整理（一）","date":"2018-08-20T11:44:31.000Z","updated":"2018-08-27T09:00:49.142Z","comments":true,"path":"2018/08/20/JS基础知识整理（一）/","link":"","permalink":"http://yoursite.com/2018/08/20/JS基础知识整理（一）/","excerpt":"","text":"引言发现很多东西一段事件不使用的话，总会模糊，所以学习最好的方式就是自己形成系统的思路~ 自己也想通过博客的方式重头系统的整理一些知识，有不对的希望大家可以互相交流。 变量变量热身，数据存储在哪里？生活中越来越多的数据存储到计算机中，然而数据存储的位置又有所不同； 当变量存储在内存中时，是起到临时存储的作用，方便下次使用； 存储在硬盘中的变量，则是起到永久存储的作用； 还有数据库中变量，也是永久存储的一种方式，让调用时更加方便； 什么是变量？变量简单的说就是用于存储程序中变化的数据（也可以是常量，即值不变的数据） 变量介绍ECMAScript的变量是松散类型的，所谓松散型就是可以用来保存任何类型的数据,换句话说，每个变量仅仅是一个用于保存值的占位符而已。定义变量时使用var操作符，后跟变量名， 变量的命名规则区分大小写； 不能以数字开头，不能使用特殊字符； 不能使用保留字和关键词； 变量类型undefined类型undefined类型只有一个值，就是特殊的undefined，在使用var声明变量但未对其加以初始化的这个变量的值就是undefined; 123var meassage;alert(message); //undefinedalert(age); //产生错误 age is not defined Null类型Null是第二个只有一个值的数据类型，这个特殊的值就是null.从逻辑角度来看，null值表只是一个空对象指针，而这也正是使用typeof null 返回object的原因。 123var car=null;alert(typeof(car)); //objectalert(null == undefined); //true Boolean类型Boolean类型是ECMAScript中使用得最多得一种类型，该类型只有两个值：true和false. 在 JavaScript 中，布尔值是一种基本的数据类型。Boolean 对象是一个将布尔值打包的布尔对象。Boolean 对象主要用于提供将布尔值转换成字符串的 toString() 方法。 当调用 toString() 方法将布尔值转换成字符串时（通常是由 JavaScript 隐式地调用），JavaScript 会内在地将这个布尔值转换成一个临时的 Boolean 对象，然后调用这个对象的 toString() 方法。 Number类型Number 对象是 Number 原始类型的引用类型。要创建 Number 对象，采用下列代码： 1var oNumberObject = new Number(68); 所有特殊值都是 Number 对象的静态属性。 要得到数字对象的 Number 原始值，只需要使用 valueOf() 方法： 1var iNumber = oNumberObject.valueOf(); 当然，Number 类也有 toString() 方法，在讨论类型转换的小节中详细讨论该方法。 除了从 Object 对象继承的标准方法外，Number 对象还有几个处理数值的专用方法。 toFixed() 方法toFixed() 方法返回的是具有指定位数小数的数字的字符串表示。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toFixed(2)); //输出 &quot;68.00&quot; 在这里，toFixed() 方法的参数是 2，说明应该显示两位小数。该方法返回 “68.00”，空的字符串位由 0 来补充。对于处理货币的应用程序，该方法非常有用。toFixed() 方法能表示具有 0 到 20 位小数的数字，超过这个范围的值会引发错误。 toExponential() 方法与格式化数字相关的另一个方法是 toExponential()，它返回的是用科学计数法表示的数字的字符串形式。 与 toFixed() 方法相似，toExponential() 方法也有一个参数，指定要输出的小数的位数。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toExponential(1)); //输出 &quot;6.8e+1&quot; 这段代码的结果是 “6.8e+1”，前面解释过，它表示 6.8x101。问题是，如果不知道要用哪种形式（预定形式或指数形式）表示数字怎么办？可以用 toPrecision() 方法。 toPrecision() 方法toPrecision() 方法根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。例如， 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(1)); //输出 &quot;7e+1&quot; 这段代码的任务是用一位数字表示数字 68，结果为 “7e+1”，以另外的形式表示即 70。的确，toPrecision() 方法会对数进行舍入。不过，如果用 2 位数字表示 68，就容易多了： 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(2)); //输出 &quot;68&quot; 当然，输出的是 “68”，因为这正是该数的准确表示。不过，如果指定的位数多于需要的位数又如何呢？ 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(3)); //输出 &quot;68.0&quot; 在这种情况下，toPrecision(3) 等价于 toFixed(1)，输出的是 “68.0”。 toFixed()、toExponential() 和 toPrecision() 方法都会进行舍入操作，以便用正确的小数位数正确地表示一个数。 String类型String 对象的 valueOf() 方法和 toString() 方法都会返回 String 类型的原始值： 1alert(oStringObject.valueOf() == oStringObject.toString()); //输出 &quot;true&quot; 首先，两个方法 charAt() 和 charCodeAt() 访问的是字符串中的单个字符。这两个方法都有一个参数，即要操作的字符的位置。 charAt() 方法返回的是包含指定位置处的字符的字符串： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.charAt(1)); //输出 &quot;e&quot; 在字符串 “hello world” 中，位置 1 处的字符是 “e”。在“ECMAScript 原始类型”这一节中我们讲过，第一个字符的位置是 0，第二个字符的位置是 1，依此类推。因此，调用 charAt(1) 返回的是 “e”。 如果想得到的不是字符，而是字符代码，那么可以调用 charCodeAt() 方法： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.charCodeAt(1)); //输出 &quot;101&quot; 这个例子输出 “101”，即小写字母 “e” 的字符代码。 concat() 方法接下来是 concat() 方法，用于把一个或多个字符串连接到 String 对象的原始值上。该方法返回的是 String 原始值，保持原始的 String 对象不变： 1234var oStringObject = new String(&quot;hello &quot;);var sResult = oStringObject.concat(&quot;world&quot;);alert(sResult); //输出 &quot;hello world&quot;alert(oStringObject); //输出 &quot;hello &quot; 在上面这段代码中，调用 concat() 方法返回的是 “hello world”，而 String 对象存放的仍然是 “hello “。出于这种原因，较常见的是用加号（+）连接字符串，因为这种形式从逻辑上表明了真正的行为： 1234var oStringObject = new String(&quot;hello &quot;);var sResult = oStringObject + &quot;world&quot;;alert(sResult); //输出 &quot;hello world&quot;alert(oStringObject); //输出 &quot;hello &quot; indexOf() 和 lastIndexOf() 方法如果无法确定在某个字符串中是否确实存在一个字符，应该调用什么方法呢？这时，可调用 indexOf() 和 lastIndexOf() 方法。 indexOf() 和 lastIndexOf() 方法返回的都是指定的子串在另一个字符串中的位置，如果没有找不到子串，则返回 -1。 这两个方法的不同之处在于，indexOf() 方法是从字符串的开头（位置 0）开始检索字符串，而 lastIndexOf() 方法则是从字符串的结尾开始检索子串。例如 123var oStringObject = new String(&quot;hello world!&quot;);alert(oStringObject.indexOf(&quot;o&quot;)); 输出 &quot;4&quot;alert(oStringObject.lastIndexOf(&quot;o&quot;)); 输出 &quot;7&quot; 在这里，第一个 “o” 字符串出现在位置 4，即 “hello” 中的 “o”；最后一个 “o” 出现在位置 7，即 “world” 中的 “o”。如果该字符串中只有一个 “o” 字符串，那么 indexOf() 和 lastIndexOf() 方法返回的位置相同。 slice() 和 substring()ECMAScript 提供了两种方法从子串创建字符串值，即 slice() 和 substring()。这两种方法返回的都是要处理的字符串的子串，都接受一个或两个参数。第一个参数是要获取的子串的起始位置，第二个参数（如果使用的话）是要获取子串终止前的位置（也就是说，获取终止位置处的字符不包括在返回的值内）。如果省略第二个参数，终止位就默认为字符串的长度。 与 concat() 方法一样，slice() 和 substring() 方法都不改变 String 对象自身的值。它们只返回原始的 String 值，保持 String 对象不变。 12345var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.slice(&quot;3&quot;)); //输出 &quot;lo world&quot;alert(oStringObject.substring(&quot;3&quot;)); //输出 &quot;lo world&quot;alert(oStringObject.slice(&quot;3&quot;, &quot;7&quot;)); //输出 &quot;lo w&quot;alert(oStringObject.substring(&quot;3&quot;, &quot;7&quot;)); //输出 &quot;lo w&quot; instanceof 运算符在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。 instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。例如： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject instanceof String); //输出 &quot;true&quot; 这段代码问的是“变量 oStringObject 是否为 String 对象的实例？”oStringObject 的确是 String 对象的实例，因此结果是 “true”。尽管不像 typeof 方法那样灵活，但是在 typeof 方法返回 “object” 的情况下，instanceof 方法还是很有用的。 Object类型Object（对象）是在所有的编程语言中都十分重要的一个概念，对于事物我们可以把他们看作是一个对象，而每一个事物都有自己的表示的属性和对于某一信息作出的相应的操作。而这些东西就变成了事物的属性和方法。 在JS中我们可以见到的对象常量有如下的形式： 12345678910111213 1 var obj= &#123; 2 3 name:&quot;Arvin&quot;, 4 5 lastName:&quot;Huang&quot; , 6 7 whatsName:function()&#123; 8 9 alert(this.name+&quot; &quot;+this.lastName); 10 11 &#125;,12 13 &#125; 由上面的代码我们可以看出实际上在JS中的对象就是一个以键值对形式存储属性的一个集合，每一个属性有一个特定的名称，并与名称相对应的值。其实这种关系是有一个专有名称的，我们可以称之为映射，当然对于对象来说，除了可以通过这种方式来保持自有属性，还可以通过继承的方式来获取继承属性。这种方式我们称作“原型式继承”。 关于对象可以衍生的知识太多，不在这里做过多阐述，后续单独分出一节讲JS对象。 变量分类变量按照类型又可以分为基本数据类型和复杂数据类型 基本类型：ECMAScript中有5种简单数据类型（也称为基本数据类型），分别是：undefined,null,boolean,number和string。还有一种复杂数据类型—object,object本质上是由一组无序的名值对组成的。ECMAScript不支持任何创建自定义类型的机制，所有值都是上述6种数据类型之一。 区别基本类型和复杂数据类型的方式 第一：它们在内存种存放的位置不同。基本数据类型存储在内存的栈中，而反观复杂数据类型则不同，它的键名存储在栈中，而它的值存储在栈所对应的指针所指向的堆中，在这里也就形成了深浅拷贝的问题，即当我们复制一个复杂类型的数据时，操作的是堆中的同一个数据，下图可以很好的说明这点关系 第二：基本类型的数据不能新增属性和方法，引用类型可以 第三：使用类型判断方法。 ​ typeof操作符：使用方法typeof(变量) ​ “undefined”——-这个值未定义； ​ “boolean”——–这个值是布尔值； ​ “string”——–这个值是字符串； ​ “number”———这个值是数值； ​ “object”——–这个值是对象或者null； ​ “function”——–这个值是函数； 123var message = &quot;some string&quot;;alert(typeof(message)); //&quot;string&quot;alert(typeof(45)); //&quot;number&quot; 有些时候，typeof操作符会返回一些令人迷惑但技术上却正确的值，比如调用typeof null会返回“object”,因为特殊值null被认为一个空的对用引用。Safari5及之前版本,Chrome7及之前版本在对正则表达式调用typeof操作会返回“function”，而在其他浏览器会返回”object”。 数据类型的转换在JS中，数据类型的转换又分为强制转换和隐式转换。 强制转换方法： parseInt(变量名)：把数字部分转换为整数（开头字符不是数字，返回NAN） parseFloat(变量名):把数字部分转换为小数（开头字符不是数字，返回NAN） Number(变量名)：把纯数字字符串转换为数字（包含非数字，返回NAN） Boolean(变量名)：转换成布尔值 String(变量名)：转换成字符串 隐式转换方式由运算符控制（比如-,*,/）。 表作为参考, 来自js权威指南, 看过书的应该都记得这表： 原始类型和对象类型 转换成String: 转换成Number 转换成Boolean 转换成Object undefined “undefined” NaN false throws TypeError null “null” 0 false throws TypeError true “true” 1 new Boolean(true) false “false” 0 new Boolean(false) “” (empty string) 0 false new String(“”);Object(“”) “1.2” (nonempty, numeric) 1.2 true new String(“1.2”);Object(“1.2”) “one” (nonempty, non-numeric) NaN true new String(“one”);Object(“one”) 0 “0” false new Number(0);Object(0) -0 “0” false new Number(-0);Object(-0) NaN “undefined” false new Number(NaN);Object(NaN) Infinity “Infinity” true new Number(Infinity);Object(Infinity) -Infinity “-Infinity” true new Number(-Infinity);Object(-Infinity) 1 (finite, non-zero) “1” true new Number(1);Object(1) {} (any object) NaN true [] (empty array) “” 0 true [9] (1 numeric elt) “9” 9 true [‘a’] (any other array) use join() method NaN true function(){} (any function “undefined” NaN true","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"canvas基础","slug":"canvas基础","date":"2018-08-16T07:27:31.000Z","updated":"2018-08-16T08:51:04.167Z","comments":true,"path":"2018/08/16/canvas基础/","link":"","permalink":"http://yoursite.com/2018/08/16/canvas基础/","excerpt":"","text":"什么是 canvas? canvas是 HTML5 新增的，一个可以使用脚本(通常为JavaScript)在其中绘制图像的 HTML元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。 它最初由苹果内部使用自己MacOS X WebKit推出，供应用程序使用像仪表盘的构件和 Safari 浏览器使用。 后来，有人通过Gecko内核的浏览器 (尤其是Mozilla和Firefox)，Opera和Chrome和超文本网络应用技术工作组建议为下一代的网络技术使用该元素。 Canvas是由HTML代码配合高度和宽度属性而定义出的可绘制区域。JavaScript代码可以访问该区域，类似于其他通用的二维API，通过一套完整的绘图函数来动态生成图形。 Mozilla 程序从 Gecko 1.8 (Firefox 1.5)开始支持 canvas, Internet Explorer 从IE9开始canvas 。Chrome和Opera 9+ 也支持 canvas。 对于不能支持canvas的浏览器，可以采用提示的方法：123&lt;canvas id=&quot;clock&quot; width=&quot;150&quot; height=&quot;150&quot;&gt; &lt;img src=&quot;images/clock.png&quot; width=&quot;150&quot; height=&quot;150&quot; alt=&quot;&quot;/&gt;&lt;/canvas&gt; canvas基础使用一个画布在网页中是一个矩形框，通过 canvas元素来绘制.注意: 默认情况下 canvas元素没有边框和内容。 第一步：创建canvas实例&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;注意: 标签通常需要指定一个id属性 (脚本中经常引用), width 和 height 属性定义的画布的大小.提示:你可以在HTML页面中使用多个 canvas元素.使用 style 属性来添加边框:1&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;border:1px solid #000000;&quot;&gt; &lt;/canvas&gt; 第二步：找到canvas元素,创建context对象canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成：12var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); getContext(“2d”) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法，我们重点研究 2D渲染上下文 。（有机会再研究3D,又是截然不同的一种方式） 第三步：定义绘制方法 12ctx.fillStyle=&quot;#FF0000&quot;;ctx.fillRect(0,0,150,75); 设置fillStyle属性可以是CSS颜色，渐变，或图案。fillStyle 默认设置是#000000（黑色）。fillRect(x,y,width,height) 方法定义了矩形当前的填充方式。 Canvas 坐标canvas 是一个二维网格。canvas 的左上角坐标为 (0,0)上面的 fillRect 方法拥有参数 (0,0,150,75)。意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0)。 Canvas - 路径在Canvas上画线，我们将使用以下两种方法： moveTo(x,y) 定义线条开始坐标 lineTo(x,y) 定义线条结束坐标绘制线条我们必须使用到 “ink” 的方法，就像stroke().在canvas中绘制圆形, 我们将使用以下方法:1arc(x,y,r,start,stop) 实际上我们在绘制圆形时使用了 “ink” 的方法, 比如 stroke()描边 或者 fill()填充. Canvas - 文本使用 canvas 绘制文本，重要的属性和方法如下： font - 定义字体 fillText(text,x,y) - 在 canvas 上绘制实心的文本 strokeText(text,x,y) - 在 canvas 上绘制空心的文本使用 fillText():1234var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;);ctx.font=&quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,10,50); Canvas - 渐变渐变可以填充在矩形, 圆形, 线条, 文本等等, 各种形状可以自己定义不同的颜色。以下有两种不同的方式来设置Canvas渐变： createLinearGradient(x,y,x1,y1) - 创建线条渐变 createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变当我们使用渐变对象，必须使用两种或两种以上的停止颜色。addColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1.使用渐变，设置fillStyle或strokeStyle的值为 渐变，然后绘制形状，如矩形，文本，或一条线。使用 createLinearGradient():创建一个线性渐变。使用渐变填充矩形:123456789var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);// 创建渐变var grd=ctx.createLinearGradient(0,0,200,0);grd.addColorStop(0,&quot;red&quot;); grd.addColorStop(1,&quot;white&quot;); // 填充渐变ctx.fillStyle=grd;ctx.fillRect(10,10,150,80); 创建一个径向/圆渐变。使用渐变填充矩形：123456789var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);// 创建渐变var grd=ctx.createRadialGradient(75,50,5,90,60,100);grd.addColorStop(0,&quot;red&quot;); grd.addColorStop(1,&quot;white&quot;);// 填充渐变ctx.fillStyle=grd;ctx.fillRect(10,10,150,80); Canvas - 图像把一幅图像放置到画布上, 使用以下方法: drawImage(image,x,y)1234var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var img=document.getElementById(&quot;scream&quot;);ctx.drawImage(img,10,10);","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"移动端开发的兼容问题","slug":"移动端开发的兼容问题","date":"2018-08-12T10:44:18.000Z","updated":"2018-09-01T04:01:33.220Z","comments":true,"path":"2018/08/12/移动端开发的兼容问题/","link":"","permalink":"http://yoursite.com/2018/08/12/移动端开发的兼容问题/","excerpt":"","text":"前言这里总结一下移动端开发在android和ios不同情况下会遇到的兼容问题~后期陆续跟新补上 示例1、ios下input设置type=button属性disabled设置true,会出现样式文字和背景异常问题，使用opacity=1来解决 2、一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发，css增加cursor:pointer就搞定了 3、1px边框问题使用xx:before{content:’’;position: absolute;top: 0;left: 0;border: 1px solid #ccc;width: 200%;height: 200%;box-sizing:border-box;-webkit-box-sizing:border-box;-webkit-transform: scale(0.5);transform: scale(0.5);-webkit-transform-origin: left top;transform-origin: left top;} 4、input为fixed定位在ios下的bug问题，点击焦点input，input跳到中间位置，可以使用内容滚动框也是fixed来设置 5、移动端字体小于12px使用四周边框或者背景色块，安卓文字偏上bug问题，可以使用整体放大1倍再缩放，而且字体不要是奇数 6、在移动端图片上传图片 使用accept=”image/*” multiple,兼容低端机的问题 7、在h5嵌入app中，ios如果出现垂直滚动条时，手指滑动页面滚动之后，滚动很快停下来，好像踩着刹车在开车，有“滚动很吃力”的感觉self.webView.scrollView.decelerationRate = UIScrollViewDecelerationRateNormal;对webview设置了更低的“减速率” 8、click 300ms 延时响应 使用 Fastclickwindow.addEventListener( “load”, function() {FastClick.attach( document.body );}, false ); 9、input 有placeholder情况下不要设置行高，否则会偏上 10、移动端适配可以使用lib-flexible CSS伪类:active如果你想使用元素的伪类来实现 按下激活 状态，那么你需要知道以下问题： iOS上的几乎任何浏览器，定义元素的伪类 :active 都是无效； Android上，Android Browser 和 Chrome 都支持伪类 :active ，其它第三方浏览器有部分不支持； 定义了 :active 并且当前浏览器环境支持，当手指在滚动或者无意间的划过时，:active 状态都会被激活； 为了规避上述所有的问题，如果需要 按下激活 状态，推荐使用 js 新增一个 className 清除输入框内阴影iOS上的几乎任何浏览器输入框（input, textarea）默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭： 12345678910111213input,textarea &#123; /* 方法1: 去掉边框 */ border: 0; /* 方法2: 边框色透明 */ border-color: transparent; /* 方法3: 重置输入框默认外观 */ -webkit-appearance: none; appearance: none;&#125;复制代码 修正iOS输入框禁用文本色在 iOS 上，如果将输入框 disabled，此时输入框内的文字颜色将比 color 所定义的要浅，并且无法通过给输入框的伪类 :disabled 定义 color 来修正。 想解决这个问题，可以作如下设置，定义输入框的文本填充色： 1234input:disabled &#123; -webkit-text-fill-color: #000;&#125;复制代码 需要注意的是，在 Mac 上的 Safari 也有同样的问题。 Samsung S4圆角BugSamsung S4 手机在 Android Browser4.4.2 上（其他版本未测），如果你使用了 border-radius，并且使用了 -webkit-transform 属性，当使用了 translatez 或者 translate3d 值，圆角会出现问题： 1234567891011.test &#123; border: 2px solid red; width: 50px; height: 50px; border-radius: 50%; background-color: gray; box-shadow: 0 2px 5px rgba(0, 0, 0, .3); -webkit-transform: translate(0, 0) translatez(0); transform: translate(0, 0) translatez(0);&#125;复制代码 12&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;复制代码 如上代码，-webkit-transform: translate(0, 0) translatez(0) 将会导致圆角无法包裹住 background-color。 当然，-webkit-transform: translate3d(0, 0, 0) 也是一样的，所以如果你的某个场景是这样的，那么可以直接使用 -webkit-transform: translate(0, 0) 来避免这个问题。 边框圆角致背景溢出在红米和OPPO等手机某些版本的 Android Webview 中，如果一个元素定义了 border + border-radius，这时如果该元素有背景，那么背景将会溢出圆角之外。 之所以会出现这个问题：其主要原因是因为CSS对背景裁剪（background-clip）有不同的处理方式，通常它可以是 border-box | padding-box | content-box 这3种方式。 浏览器的默认裁减方式是 border-box，即溢出 border 之外的背景都将被裁减。 对于上述无法裁减边框之外背景的手机，将值定义为 padding-box | content-box 都能fix这问题，不过更推荐使用 padding-box。因为使用 content-box，如果定义了 padding 不为 0，背景将无法铺满元素。 fixed在IOS中不生效问题相信大家在做移动端项目时都会遇到fixed失效的问题，就是底部的按钮随着页面的滑动一起抖动，看起来像是抽搐一般，这个时候肯定就需要想办法解决了，在这里我们说的是在ios 下 。那么如何解决这个问题呢？这里有个小诀窍分享给大家。 其实有两种解决方案可以实现： 一种是将滚动区域和固定区域分开，不过要注意将按钮放在滚动区域外侧，代码如下 123456789101112131415&lt;body&gt; &lt;div class=\"header\"&gt;头部&lt;/div&gt; &lt;div class=\"main\"&gt; &lt;div class=\"content\"&gt; &lt;!-- 内容区域（可以滚动的区域） --&gt; &lt;/div&gt; &lt;/div&gt; &lt;footer class=\"footer\"&gt; &lt;!-- fixed定位的底部 --&gt; &lt;input type=\"text\" placeholder=\"请输入姓名\"&gt; &lt;/footer&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930313233343536.header,.footer,.main &#123; display: block; &#125; .header &#123; position: fixed; top: 0; left: 0; right: 0; height: 100px; &#125; .footer &#123; position: fixed; bottom: 0; left: 0; right: 0; height: 30px; &#125; .main &#123; /*main绝对定位，进行内部滚动*/ position: absolute; /*top是头部的高度*/ top: 100px; /*bottom是底部的高度*/ bottom: 30px; /*使之可以滚动*/ overflow-y: scroll; /*增加弹性滚动,解决滚动不流畅的问题*/ -webkit-overflow-scrolling: touch; &#125; .main .content &#123; height: 2000px; &#125; 另一种因为fixed在IOS中兼容不好，需要定位的话你可以采取absolute的方式进行定位。就不会出现该问题了。","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"兼容","slug":"兼容","permalink":"http://yoursite.com/tags/兼容/"}]},{"title":"Vue和微信小程序的区别和比较","slug":"Vue和微信小程序的区别和比较","date":"2018-08-04T14:47:23.000Z","updated":"2018-08-04T14:48:48.641Z","comments":true,"path":"2018/08/04/Vue和微信小程序的区别和比较/","link":"","permalink":"http://yoursite.com/2018/08/04/Vue和微信小程序的区别和比较/","excerpt":"","text":"引言写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。 一、生命周期先贴两张图： vue生命周期 小程序生命周期 相比之下，小程序的钩子函数要简单得多。 ue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。onLoad：页面加载 一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow：页面显示 每次打开页面都会调用一次。 onReady：页面初次渲染完成 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。 对界面的设置如 wx.setNavigationBarTitle请在 onReady之后设置。详见生命周期。 onHide：页面隐藏 当 navigateTo或底部tab切换时调用。 onUnload：页面卸载 当 redirectTo或 navigateBack的时候调用。 数据请求在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在 created或者 mounted中请求数据，而在小程序，会在 onLoad或者 onShow中请求数据。 二、数据绑定vue：vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例： 1&lt;img :src=&quot;imgSrc&quot;/&gt; 小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例： 1&lt;image src=&quot;&#123;&#123;imgSrc&#125;&#125;&quot;&gt;&lt;/image&gt; 三、列表渲染直接贴代码，两者还是有些相似： vue： 1&lt;ul id=&quot;example-1&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;var example1 = new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; items: [ &#123; message: &apos;Foo&apos; &#125;, &#123; message: &apos;Bar&apos; &#125; ] &#125;&#125;) 小程序： 1Page(&#123; data: &#123; items: [ &#123; message: &apos;Foo&apos; &#125;, &#123; message: &apos;Bar&apos; &#125; ] &#125;&#125;)&lt;text wx:for=&quot;&#123;&#123;items&#125;&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt; 四、显示与隐藏元素vue中，使用 v-if 和 v-show控制元素的显示和隐藏。 小程序中，使用 wx-if和 hidden控制元素的显示和隐藏。 五、事件处理vue：使用 v-on:event绑定事件，或者使用 @event绑定事件，例如： 1&lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;&lt;button v-on:click.stop=&quot;counter+=1&quot;&gt;Add1&lt;/button&gt; //阻止事件冒泡 小程序中，全用 bindtap(bind+event)，或者 catchtap(catch+event)绑定事件，例如： 1&lt;button bindtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt;&lt;button catchtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt; //阻止事件冒泡 六、数据双向绑定1、设置值在vue中，只需要再表单元素上加上 v-model,然后再绑定 data中对应的一个值，当表单元素内容发生变化时， data中对应的值也会相应改变，这是vue非常nice的一点。 1&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;reason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos;/&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#app&apos;, data: &#123; reason:&apos;&apos; &#125;&#125;) 但是在小程序中，却没有这个功能。那怎么办呢？ 当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过 this.setData({key:value})来将表单上的值赋值给 data中的对应值。 下面是代码，可以感受一下： 1&lt;input bindinput=&quot;bindReason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos; value=&apos;&#123;&#123;reason&#125;&#125;&apos; name=&quot;reason&quot; /&gt;Page(&#123;data:&#123; reason:&apos;&apos;&#125;,bindReason(e) &#123; this.setData(&#123; reason: e.detail.value &#125;) &#125;&#125;) 当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的 v-model简直爽的不要不要的。 2、取值vue中，通过 this.reason取值。 小程序中，通过 this.data.reason取值。 七、绑定事件传参 在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如： 1&lt;button @click=&quot;say(&apos;明天不上班&apos;)&quot;&gt;&lt;/button&gt;new Vue(&#123; el: &apos;#app&apos;, methods:&#123; say(arg)&#123; consloe.log(arg) &#125; &#125;&#125;) 在 小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的 data-属性上，然后在方法中，通过 e.currentTarget.dataset.*的方式获取，从而完成参数的传递，很麻烦有没有… 1&lt;view class=&apos;tr&apos; bindtap=&apos;toApprove&apos; data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt;&lt;/view&gt;Page(&#123;data:&#123; reason:&apos;&apos;&#125;,toApprove(e) &#123; let id = e.currentTarget.dataset.id; &#125;&#125;) 八、父子组件通信1、子组件的使用在vue中，需要： 1、编写子组件 2、在需要使用的父组件中通过 import引入 3、在 vue的 components中注册 4、在模板中使用 1//子组件 bar.vue&lt;template&gt; &lt;div class=&quot;search-box&quot;&gt; &lt;div @click=&quot;say&quot; :title=&quot;title&quot; class=&quot;icon-dismiss&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123;props:&#123; title:&#123; type:String, default:&apos;&apos; &#125; &#125;&#125;,methods:&#123; say()&#123; console.log(&apos;明天不上班&apos;); this.$emit(&apos;helloWorld&apos;) &#125;&#125;&lt;/script&gt;// 父组件 foo.vue&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;bar :title=&quot;title&quot; @helloWorld=&quot;helloWorld&quot;&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bar from &apos;./bar.vue&apos;export default&#123;data:&#123; title:&quot;我是标题&quot;&#125;,methods:&#123; helloWorld()&#123; console.log(&apos;我接收到子组件传递的事件了&apos;) &#125;&#125;,components:&#123; Bar&#125;&lt;/script&gt; 在小程序中，需要： 1、编写子组件 2、在子组件的 json文件中，将该文件声明为组件 1&#123; &quot;component&quot;: true &#125; 3、在需要引入的父组件的 json文件中，在 usingComponents填写引入组件的组件名以及路径 1&quot;usingComponents&quot;: &#123; &quot;tab-bar&quot;: &quot;../../components/tabBar/tabBar&quot; &#125; 4、在父组件中，直接引入即可 1&lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt; 具体代码： 1// 子组件 &lt;!--components/tabBar/tabBar.wxml--&gt; &lt;view class=&apos;tabbar-wrapper&apos;&gt; &lt;view class=&apos;left-bar &#123;&#123;currentpage===&quot;index&quot;?&quot;active&quot;:&quot;&quot;&#125;&#125;&apos; bindtap=&apos;jumpToIndex&apos;&gt; &lt;text class=&apos;iconfont icon-shouye&apos;&gt;&lt;/text&gt; &lt;view&gt;首页&lt;/view&gt; &lt;/view&gt; &lt;view class=&apos;right-bar &#123;&#123;currentpage===&quot;setting&quot;?&quot;active&quot;:&quot;&quot;&#125;&#125;&apos; bindtap=&apos;jumpToSetting&apos;&gt; &lt;text class=&apos;iconfont icon-shezhi&apos;&gt;&lt;/text&gt; &lt;view&gt;设置&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 2、父子组件间通信在vue中 父组件向子组件传递数据，只需要在子组件通过 v-bind传入一个值，在子组件中，通过 props接收，即可完成数据的传递，示例： 1// 父组件 foo.vue&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;bar :title=&quot;title&quot;&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bar from &apos;./bar.vue&apos;export default&#123;data:&#123; title:&quot;我是标题&quot;&#125;,components:&#123; Bar&#125;&lt;/script&gt;// 子组件bar.vue&lt;template&gt; &lt;div class=&quot;search-box&quot;&gt; &lt;div :title=&quot;title&quot; &gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123;props:&#123; title:&#123; type:String, default:&apos;&apos; &#125; &#125;&#125;&lt;/script&gt; 子组件和父组件通信可以通过 this.$emit将方法和数据传递给父组件。 在小程序中 父组件向子组件通信和vue类似，但是小程序没有通过 v-bind，而是直接将值赋值给一个变量，如下： 1&lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt; 此处， “index”就是要向子组件传递的值。 在子组件 properties中，接收传递的值。 1properties: &#123; // 弹窗标题 currentpage: &#123; // 属性名 type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型） value: &apos;index&apos; // 属性初始值（可选），如果未指定则会根据类型选择一个 &#125; &#125; 子组件向父组件通信和 vue也很类似，代码如下： 1//子组件中methods: &#123; // 传递给父组件 cancelBut: function (e) &#123; var that = this; var myEventDetail = &#123; pickerShow: false, type: &apos;cancel&apos; &#125; // detail对象，提供给事件监听函数 this.triggerEvent(&apos;myevent&apos;, myEventDetail) //myevent自定义名称事件，父组件中使用 &#125;,&#125;//父组件中&lt;bar bind:myevent=&quot;toggleToast&quot;&gt;&lt;/bar&gt;// 获取子组件信息toggleToast(e)&#123; console.log(e.detail)&#125; 如果父组件想要调用子组件的方法vue会给子组件添加一个 ref属性，通过 this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如： 1//子组件&lt;bar ref=&quot;bar&quot;&gt;&lt;/bar&gt;//父组件this.$ref.bar.子组件的方法 小程序是给子组件添加 id或者 class，然后通过 this.selectComponent找到子组件，然后再调用子组件的方法,示例： 1//子组件&lt;bar id=&quot;bar&quot;&gt;&lt;/bar&gt;// 父组件this.selectComponent(&apos;#id&apos;).syaHello() 小程序和vue在这点上还是很相似的。 好了，关于微信小程序和VUE的对比就写到这里，未来微信小程序会越来越好，应用到更多成熟的技术。","categories":[],"tags":[{"name":"framework7","slug":"framework7","permalink":"http://yoursite.com/tags/framework7/"}]},{"title":"framework7学习总结-2","slug":"framework7学习总结-2","date":"2018-08-04T14:44:00.000Z","updated":"2018-08-04T14:45:15.921Z","comments":true,"path":"2018/08/04/framework7学习总结-2/","link":"","permalink":"http://yoursite.com/2018/08/04/framework7学习总结-2/","excerpt":"","text":"前言前面几篇介绍了 framework7的一些基础知识，现在介绍一下自己在使用过程中遇到的一些坑的地方，也能叫踩坑日记吧。 事件多次绑定问题不知道有没有在使用framework7的时候遇到过这个问题，从A页面开始，跳转到B页面，再次返回A页面的时候，页面绑定的事件会触发两次，这时候我就蒙蔽了，一开始我是以为出于页面机制原因，再次返回该页面的时候DOM重新加载，页面又存在缓存的问题，就会导致DOM节点存在多个，也就会触发多次事件，然后我就打印事件源节点，最终发现并不是这个原因。后来通过反复的找，最终发现是绑定事件时机不对，妈呀，这个坑可烦了我好一段时间，后来发现，每次返回页面都会重新绑定事件，就会导致页面点击时多次触发事件，触发次数决定于第几次加载此页，这个时候重新刷新页面可以解决这个问题，但是不可能每次都刷新页面，于是就把点击事件绑定时机由之前的pagereinit换为pageinit,问题也就迎刃而解了。 总之，绑定事件时，由于f7机制的不同，为了避免重复绑定事件，必需保证事件只绑定一次！而将绑定的回调放在除pageinit的其他时机，要么是导致页面触发多次事件，要么是导致事件绑定失败。","categories":[],"tags":[{"name":"framework7","slug":"framework7","permalink":"http://yoursite.com/tags/framework7/"}]},{"title":"framework7学习总结(1)","slug":"framework7学习总结-1","date":"2018-07-29T03:17:20.000Z","updated":"2018-07-29T04:09:28.810Z","comments":true,"path":"2018/07/29/framework7学习总结-1/","link":"","permalink":"http://yoursite.com/2018/07/29/framework7学习总结-1/","excerpt":"","text":"引言本篇主要讨论framework7的page和路由 page页面结构使用framework有着严格的布局要求，依次body&gt;div class=&quot;views&quot;&gt;div class=&quot;view&quot;&gt;div class=&quot;pages&gt;div class=&quot;page&quot;&gt;div class=&quot;page-content&quot;;必须依据此布局格式进行布局，否则会遇到很多意想不到的bug,比如页面不能正常返回和切换等等； 1234567891011121314151617181920212223242526272829&lt;body&gt; ... &lt;!-- Views --&gt; &lt;div class=&quot;views&quot;&gt; &lt;!-- Your main view --&gt; &lt;div class=&quot;view view-main&quot;&gt; &lt;!-- Pages --&gt; &lt;div class=&quot;pages&quot;&gt; &lt;div class=&quot;page&quot; data-page=&quot;home&quot;&gt; &lt;div class=&quot;page-content&quot;&gt; ... page content goes here ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Another view --&gt; &lt;div class=&quot;view another-view&quot;&gt; &lt;!-- Pages --&gt; &lt;div class=&quot;pages&quot;&gt; &lt;div class=&quot;page&quot; data-page=&quot;home-another&quot;&gt; &lt;div class=&quot;page-content&quot;&gt; ... page content goes here ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ...&lt;/body&gt; page事件掌握了常见了page事件能帮助我们更高效的开发app，现在我们看看页面浏览的时候最重要的一部分 - Page 事件。这些事件可以让我们通过JS来操作加载好的Page。 Event Target Description pageBeforeInit Page Element 当Framework7把新页面插入DOM的时候会触发 pageInit Page Element 当Framework7初始化页面的组件的时候会触发 pageReinit Page Element 当缓存页面可见时，将触发此事件。它只适用于内联页面（DOM缓存页）。 pageBeforeAnimation Page Element 当页面初始化完成并且可以做动画的时候触发 pageAfterAnimation Page Element 在页面动画完成之后触发 pageBeforeRemove Page Element Page从DOM中移除之前就会触发这个事件。如果你希望做一些解除事件绑定或者销毁一些插件的时候，这个方法是很有用的。 pageBack Page Element 在返回上一页动画执行之前就会触发这个事件。和 “pageBeforeAnimation” 的不同之处在于，这个事件在老页面上也会触发，也就是那个从中间滑动到右边的页面。 pageAfterBack Page Element 返回上一页动画执行完成之后触发这个事件。同样，区别于”pageAfterAnimation”，他也会在老页面上触发。 有两种方式可以使用这些事件： 12345678910// Option 1. Using one &apos;pageInit&apos; handler for all pages (recommended way):$$(document).on(&apos;pageInit&apos;, function (e) &#123; // Do something here when page loaded and initialized &#125;) // Option 2. Using live &apos;pageInit&apos; event handlers for each page (not recommended)$$(document).on(&apos;pageInit&apos;, &apos;.page[data-page=&quot;about&quot;]&apos;, function (e) &#123; // Do something here when page with data-page=&quot;about&quot; attribute loaded and initialized&#125;) 视图中页面切换的方法在视图中切换是非常常见的功能，官方也给我们提供了对应的API 在视图中主要有两个路由器方法: mainView.router.load(options) - 把一个页面加载到当前视图 mainView.router.back(options) - 这个方法会触发一个反向的动画并回到上一个页面，也就是浏览历史上的回退 上面这些方法都接受一个 options 对象作为参数，这个参数有如下属性: 参数 类型 说明 url string 需要加载的页面的URL content string or HTMLElement or [jQuery/Zepto/DOM7 collection] or [array of HTMLElement] 需要加载的动态页面的内容 pageName string 需要加载的页面的名称(data-page)。只用在内联页面(DOM cached)。 template function (Template7 compiled template) 需要加载并渲染的模板 context object or array 渲染Template7 模板时需要的上下文。这里有更多说明Template7 Pages。 contextName string 可选的。用来渲染 Template7 的 templatesData 的上下文名称/路径。这里查看更多说明 Template7 Pages query object Object with additionall query parameters that could be retreived in query object of Page Data force boolean 可选的。只对 back 方法有效。如果设置为 true，那么会忽略浏览历史中的上一个页面，而是直接加载指定的页面。 ignoreCache boolean 可选的。如果设置为 true ，那么会忽略URL对应的缓存，并且再次通过XHR来加载。 animatePages boolean 可选的。可以覆盖在 View 中的相同参数，打开/关闭页面切换的动画。 reload boolean 可选的。如果设置为 true，那么不会当做新页面加载，而是直接替换当前视图的当前页面。并且在视图浏览历史中替换最后一条历史。 reloadPrevious boolean 可选的。和 reload 一样，不过是对上一个页面。 pushState boolean 可选的。是否把浏览历史存储在浏览器的浏览历史中。(这样可以使用浏览器的后退/前进按钮） 注意， url, content, pageName 这三个参数，你只能同时使用一个。 视图中页面切换的快捷方式加载新页面的方法:mainView.router.loadPage(url) - 加载指定的页面到视图中。其实和你在页面中点击一个链接是一样的效果。 url - 需要加载的页面的URL mainView..router.loadContent(content) - 把动态生成的内容当做一个页面加载 content - string or HTMLElement or [jQuery/Zepto/DOM7 collection] or [array of HTMLElement] - 需要加载的内容 重新加载当前页面的方法:mainView.router.reloadPage(url) - 重新加载指定的页面到视图的当前页面。同时也会修改视图的浏览历史，把最后一条记录替换成指定的URL。 url - 需要加载页面的URL mainView.router.reloadContent(content) - 重新加载指定的内容到视图的当前页面。同时也会修改视图的浏览历史，把最后一条记录替换成指定的URL。 content - string or HTMLElement or [jQuery/Zepto/DOM7 collection] or [array of HTMLElement] - 需要加载的内容 重新加载上一个页面的方法（如果视图的DOM中有两个页面）：mainView.router.reloadPreviousPage(url) - 重新加载指定的页面到视图的上一个页面。同时也会修改视图的浏览历史，把最后一条记录替换成指定的URL。 url - 需要加载页面的URL mainView.router.reloadPreviousContent(content) - 重新加载指定的内容到视图的上一个页面。同时也会修改视图的浏览历史，把最后一条记录替换成指定的URL。 content - string or HTMLElement or [jQuery/Zepto/DOM7 collection] or [array of HTMLElement] - 需要加载内容 刷新页面的方法:mainView.router.refreshPage() - 刷新视图的当前页面。和你调用 .reloadPage 方法并且传入当前页面的URL是一样的效果 mainView.router.refreshPreviousPage() - 刷新视图的上一个页面。和你调用 .reloadPreviousPage 方法并且传入上一个页面的URL是一样的效果 路由Ajax Page我们有了一个有View和Page的应用结构，现在我们需要理解如何创建新的Page，以及Framework7是如何加载他们的。 下面有两个重要的地方请注意： p 默认情况下 Framework7 会使用 Ajax 加载所有的页面，除了带有 external class的链接（）和没有正确 href 值的链接（比如是空的或者是 #）。 p 在 初始化 时候传递不同的 ajaxLinks 参数可以改变这个行为。 所以我们如果需要创建一个链接指向 about.html，我们只需要按照平时一样写 &lt;a&gt;标签就可以： 1&lt;a href=&quot;about.html&quot;&gt;Go to About page&lt;/a&gt; 当我们点击这个链接的时候，Framework7会通过Ajax获取 about.html，解析它的内容，然后把它插入到DOM中，并且做一个动画切换到这个新页面。 Page 内部的结构因为Framework7有一个非常聪明的解析器，所以在内部页面中我们不需要完整的HTML结构（head,body,views,pages等)。比如 about.html 的内容： 1234&lt;-- That is all we have in about.html file --&gt;&lt;div class=&quot;page&quot; data-page=&quot;about&quot;&gt;... About page content goes here&lt;/div&gt; 重点是，Framework7 解析器会尝试在ajax加载的页面中寻找 &lt;div class=&quot;page&quot;&gt;，所以我们不需要完整的HTML结构。当然这不是强制的，你可以写出完整的页面结构。 取消/增加页面切换动画有时候你在加载页面或者后退的时候需要立刻执行，不想要一个切换的动画效果，可以通过增加一个 “no-animation” class 在链接上即可。 1234567&lt;div class=&quot;page&quot; data-page=&quot;about&quot;&gt; &lt;-- Add additional &quot;no-anmation&quot; class to link to diable animated page transition --&gt; &lt;a href=&quot;about.html&quot; class=&quot;no-animation&quot;&gt; Load About page immediately &lt;/a&gt; &lt;-- The same rule for back link --&gt; &lt;a href=&quot;index.html&quot; class=&quot;back no-animation&quot;&gt; Go back immediately &lt;/a&gt;&lt;/div&gt; 如果我们已经全局禁用了动画，但是在某些链接上希望启用这些动画，那么我们可以给链接加上 “with-animation” class。 1234567&lt;div class=&quot;page&quot; data-page=&quot;about&quot;&gt; &lt;!-- Add additional &quot;with-anmation&quot; class to link to enable animated page transition --&gt; &lt;a href=&quot;about.html&quot; class=&quot;with-animation&quot;&gt; Load About page with animation &lt;/a&gt; &lt;!-- The same rule for back link --&gt; &lt;a href=&quot;index.html&quot; class=&quot;back with-animation&quot;&gt; Go back with animation &lt;/a&gt;&lt;/div&gt; 通过 data 标签配置更多选项有时候我们希望在某些链接上有更多的配置，我们可以使用作为 data-属性来配置所有在 视图链接方法中的参数，比如： 12345678&lt;!-- Refresh currently active page (reload from server) --&gt;&lt;a href=&quot;about.html&quot; data-reload=&quot;true&quot; data-ignore-cache=&quot;true&quot;&gt;Refresh page&lt;/a&gt; &lt;!-- Go back but to another page, not to actual previous page in history. Such method also allows to jump back in history: --&gt;&lt;a href=&quot;about.html&quot; class=&quot;back&quot; data-force=&quot;true&quot;&gt;Back to About&lt;/a&gt; &lt;!-- Load new page without animation --&gt;&lt;a href=&quot;about.html&quot; data-animate-pages=&quot;false&quot;&gt;&lt;/a&gt; 结论Framework7 中，页面之间的链接和路由都是很简单的，你只需要记住： 你需要使用普通的 &lt;a&gt; 标签，她有一个href属性指向你需要加载的页面。 通过ajax加载的页面不需要有完整的HTML结构。只需要有 (和 如果你需要动态的滚动条) 如果你在同一个文件中有多个Page，把他们用 包裹起来，并且给每一个View设置好正确的class。 只需给一个链接加上 back class ()，她就会自动变成一个后退链接。 ###","categories":[],"tags":[{"name":"framework7","slug":"framework7","permalink":"http://yoursite.com/tags/framework7/"}]},{"title":"Hybrid App 和Native App开发对比","slug":"Hybrid-App-和Native-App开发对比","date":"2018-07-28T02:40:22.000Z","updated":"2018-07-29T02:37:23.092Z","comments":true,"path":"2018/07/28/Hybrid-App-和Native-App开发对比/","link":"","permalink":"http://yoursite.com/2018/07/28/Hybrid-App-和Native-App开发对比/","excerpt":"","text":"引言目前app开发市场需求量越来越大，此片文章主要涉及开发技术展开讨论。 智能手机之普及不用多说，手机APP渗投到各个行业：电商（淘宝、京东等）、金融（各手机行业、P2P借贷等）、医疗（智慧医疗）、交通（滴滴、Uber等）、教育（慕课网等）、餐饮（饿了吗、美团等）……反正只要是个企业，无论规模大小，都已经订制或将要订制自己的APP。这么多APP无外乎就三种模式：Native App、Web App、Hybrid App。 app的开发技术，目前流行的无非就是两种开发方式，原生和Html5。原生又分为安卓平台和IOS平台。 背景目前争论不休的问题，在早先前争论CS，BS架构的软件系统是一样一样的。原先BS，CS对用户而言的区别是需不需要安装客户端。BS是通过浏览器来访问，用PC，平板，Win，Mac都能访问，用户不需要下载额外的客户端，同时运维和升级提供很大的便利。CS则需要下载客户端软件，安装，然后登录使用，升级的话，要么升级链接库，要么重新安装升级包，比较不方便，优势是很多算法在本地运行，对服务器要求不高。 CS、BS之争是在PC端，那么现在原生和H5之争是在移动端。 那么评判一个APP用什么技术来开发呢？经过总结，可以有如下判断依据： 1.如果APP中出现大段文字（如新闻、攻略等），且格式比较丰富（如加粗，字体多样），那么用H5会比较方便。原因是原生开发解析json对字符串格式处理不算很好。 2.如果讲究APP反应速度（含页面切换流畅性），则选用原生开发，因为H5其本质是网页，换页时，基本要加载整个页面，就像是浏览器打开一个新页面一样，显得较慢，而原生系统则只加载变化部分。 3.如果APP对有无网络、网络优劣敏感（譬如有离线操作，在线操作），那么，基本选用原生开发，虽然H5可以做到，但是很复杂。 4.如果APP需要频繁调用硬件（摄像头、麦克风、未来的湿度检测仪等等）那么，基本选用原生开发，这样支持硬件更多，更容易扩展，且调用速度更快，H5就望尘莫及了。 5.如果APP用户常见页面频换，如（淘宝首页各种不同活动），那么用H5，维护起来更容易。 6.如果预算有限（H5开发一套可跨平台覆盖安卓、ios，黑莓、塞班），不是很讲究用户体验，不在乎加载速度，那非H5不可。 列举那么多，实际上有个采阴补阳的方法是H5+原生混合开发，对于固定格式、页面速度要求高，的模块（如PDB的即时通讯、宝典、我的项目）采用原生开发，对于新闻、大段文字、资讯类的（如信息广场、发表、问吧等）用H5页面来加载，将其嵌入到原生框架中那么，可以达到比较良好的体验。那么到底什么时混合式开发了，终于可以切入主题了。 三种开发方式1. Native AppNative App，原生APP，使用原生（即Android或iOS）开发的APP。两年多以前这非常流行，到现在为止，原生开发人员数量众多，一抓一大票，技术成熟，好多培训机构都抱着老掉牙的API翻来覆去的讲——尤其是Android。Sorry，说错话了……使用原生开发有其优势：应用的性能好，适配起来相对容易。学习成本要看人，个人觉得技术点不多，门槛相对稍高，但入门后学习起来就很轻松——网络资料实在是太多了。 但原生APP最头疼的有三个问题： 1、无法跨平台：Android和iOS都需要开发各自平台的版本——开发成本高； 2、升级麻烦：每次升级都要下载安装包，Android还好，反正不需要审核，下载就下载吧，但iOS就麻烦了，发布每个版本还得经过App Store的审核，这导致第三个问题； 3、Android和iOS很难同步发布。 2.Web App所谓的Web App，就是把手机当做一个浏览器（Android使用WebView，iOS使用UIWebView），做几个页面挂在服务器端，类似于一个小网站。这样说虽然不太贴切，但实际上给人的感觉就是这样的。虽然开发成本大大降低，但页面访问速度慢、操作体验差。于是第三种模式诞生了。 3.Hybrid App乍一看和Web App没啥差别，但涉及到的技术成本、开发成本、学习成本比Web App高，它综合了Web App的开发速度和Native App的高性能体验。之所以说学习成本高，是因为开发高性能的Hybrid App有难度，网络资料少。如何做好屏幕适配、提高UI响应速度、如何最大化使用原生功能等内容，网络几乎没有资料。网上能搜索到的都是很粗略的东西，或者就是Hello World级别的东西，涉及到稍微细节一点的东西几乎没有。由于本系列文章都只讲Hybrid，故在此不再啰嗦了。 在网上搜集到了关于三种开发方式的详细对比，如下表 特性 Native App Hybrid App Web App 开发语言 只用Native开发语言 Native和Web开发语言或只用Web开发语言 只用Web开发语言 代码移植性和优化 无 高 高 访问针对特定设备的特性 高 中 低 充分利用现有知识 低 高 高 高级图形 高 中 中 升级灵活性 低，总是通过应用升级 中，部分更新可不通过应用商店升级 高 安装体验 高，从应用商店安装 高，从应用商店安装 中，通过浏览器安装 混合开发概述Hybrid App主要以JS+Native两者相互调用为主，从开发层面实现“一次开发，多处运行”的机制，成为真正适合跨平台的开发。Hybrid App兼具了Native App良好用户体验的优势，也兼具了Web App使用HTML5跨平台开发低成本的优势。 目前已经有众多Hybrid App开发成功应用，比如美团、爱奇艺、微信等知名移动应用，都是采用Hybrid App开发模式。 混合开发应用场景 （1）折中考虑——如果企业使用 Hybrid 开发方法，就能集Native 和web两者之所长。一方面，Native 让开发者可以充分利用现代移动设备所提供的全部不同的特性和功能。另一方面，使用 Web 语言编写的所有代码都可以在不同的移动平台之间共享，使得开发和日常维护过程变得集中式、更简短、更经济高效。 （2）内部技能——许多企业都拥有Web 开发技能。如果选择 Hybrid 开发方法，在合适解决方案的支持下，Web 开发者只要仅仅运用 HTML、CSS 和 JavaScript 等 Web 技能，就能构建 App，同时提供 Native 用户体验。 （3）考虑未来——HTML5的可用性和功能都在迅速改进。许多分析师预测，它可能会成为开发前端 App 的默认技术。如果用 HTML 来编写 App 的大部分代码，并且只有在需要时才使用 Native 代码，公司就能确保他们今天的投入在明天不会变得过时，因为 HTML 功能变得更丰富，可以满足现代企业一系列更广泛的移动要求。 总结起来两句话： 纯Native的迭代太慢，不能动态更新，且不能跨平台 纯Web页，有很功能无法实现，有些动画效果实现其体验太差 因此我们需要Hybrid ps：怎样判断一个App的页面是native的还是web的？ Android手机 设置-&gt;开发者选项-&gt;显示布局边界 即可 混合开发app技术Hybrid App所需技术Hybrid App由于需要保证运行性能与开发速度，需要如下技术支持，本系列博文均会按照Demo的开发顺序依次描述本人的开发心得和教训，希望能起到一个抛砖引玉的作用。 Native技术Native技术主要用于提供原生支持，要做到跨平台，就需要掌握部分Android和iOS的知识，除了多线程，文件存储等基础知识，Android需要非常熟练的掌握WebView**、WebSettings、WebChromeClient、WebClient四大对象。iOS需要非常熟练掌握UIWebView**对象。 Web技术1、 HTML5熟练掌握HTML5的各个标签，如何编写最优的文档结构。 2、 CSS熟练掌握CSS2和CSS3的新特性，能按照效果图编写最高性能的样式。 使用SCSS生成CSS，将CSS可编程化。 3、 JavaScript实现业务逻辑控制。个人理解JavaScript主要包含两大内容：DOM编程和面向对象编程。大部分JS开发人员就只掌握DOM编程，诸如document.getElementById()等，但面向对象是很重要的一个方面。 4、 性能和开发模块化编程：编写可复用的组建； CSS渲染：了解浏览器的CSS渲染引擎才能编写更高效率的样式； JS解析：了解浏览器的JS解析引擎才能优化JS脚本； HTTP**协议**：熟练掌握HTTP请求的各个内容； AJAX：和服务器端的交互大都采用AJAX。 流行框架Hybrid 框架Cordova/PhoneGap：侧重于JS与原生的交互，开发简单，但性能差，如触摸时反应不灵敏。 AppCan：性能还行，使用简单，但要提交代码给AppCan的服务器才能打包，相信有追求的企业是不会把自己的代码提交给第三方，把打包权利交给第三方的。 Ionic Framework：在Cordova的基础上增加一些UI/JS方面的东西，样式还不错，但同样具有Cordova的不足。 UI/JS框架jQuery Mobile：上手简单，组件丰富，但性能超级差，闪屏现象严重。 Senche Touch：简单看过，没有使用过，貌似UI很漂亮，学习成本高。 React Native：FB推出的，当年FB是最早尝试Hybrid的，但性能超差，于是APP放弃了Hybrid，走原生的道路。在大家都不看好H5时，FB暗中深入挖掘H5，三年之后推出了这个框架，非常推荐各位去学习其中的思想。 GMU：百度推出的，这个不错。 Framework7 是一个开源免费的框架可以用来开发混合移动应用（原生和HTML混合）或者开发iOS7风格的WEB APP。也可以用来作为原型开发工具，可以迅速创建一个应用的原型。Framework7 最主要的功能是可以使用HTML、CSS和JS来开发iOS7应用。Framework7 是完全免费开源的。 Framework7 并不能兼容所有的设备。她只专注于为iOS7 提供最好的体验。 Framework7 或者叫 F7 是全功能的绑定 iOS 7 应用的 HTML 框架。Framework7 是免费开源的 HTML 移动端框架，用来开发混合移动端应用或者 iOS 7 的 Web 应用，并且带有 iOS 7 的原生外观和感觉。Framework7 也是独立的原型应用工具。 Framework7 使用 Javascript，CSS 和 HTML 来创建 iOS 7 应用，支持多个平台的迁移（PhoneGap），但是不是支持所有平台，主要还是针对 iOS 7。 UI/JS库这个就多了，jQuery、Zepto、Swiper、iScroll、RequireJS、AngularJS…… 个人建议由于移动端是一个重视性能和用户体验的终端，大量采用框架存在一些问题： 1、 扩展、维护、定制成本，这个非常需要考虑，或许框架提供的UI风格和自己设计的UI风格差异大，导致设计围绕框架转，不符合产品的需求。 2、 既然是框架，强调的是覆盖面广度和功能的全面，会有很多无用的东西，带来累赘； 3、 框架本身存在BUG，或许需要开发人员面对一些能力之外的问题。 好了，本篇文章就先介绍到这里，下篇文章再介绍关于Framework7一些使用中容易踩坑的地方。","categories":[],"tags":[{"name":"hybridApp 框架","slug":"hybridApp-框架","permalink":"http://yoursite.com/tags/hybridApp-框架/"}]},{"title":"整理一下framework7零散知识","slug":"framework7学习总结（入门篇）","date":"2018-07-21T04:35:13.000Z","updated":"2018-07-21T05:52:30.038Z","comments":true,"path":"2018/07/21/framework7学习总结（入门篇）/","link":"","permalink":"http://yoursite.com/2018/07/21/framework7学习总结（入门篇）/","excerpt":"","text":"引言最近在工作时遇到一个以前都没接触过的框架，Framework7,这里简单介绍一下最近一个月左右自己的理解。希望有理解不对的大家可以纠正。 之所以大家会选择Framework7，最根本的原因还是Framework7 是一个开源免费的框架。可以用来开发混合移动应用（原生和 HTML 混合）或者开发 iOS &amp; Android 风格的 WEB APP。也可以用来作为原型开发工具，可以迅速创建一个应用的原型。 开发自己的app是当前互联网公司必不可少的一种战略方式，而不同的公司考虑的角度和使用的用户又各有不同，这里再网上找到一副整理的很好的当前开发app的框架对比图，大家可以通过仔细对比，找到符合公司文化，最适合公司的移动端混合式开发框架，废话不多说了，上图 再来对于开发者而言，快速上手也算得上框架的一种优势，使用时只需要一个基本的 HTML 布局，并且把 Framework7 的 CSS 和 JS 文件引入即可！Framework7 不会强制你写任何自定义的标签，也不会通过 JS 来生成任何额外的内容。你不需要通过 JS 或者 JSON 来写页面，只需要普通的 HTML 就可以。 同时，Framework7 有大量可以直接使用的 UI 组件和工具，比如导航栏、侧边栏、弹出层、标签页、虚拟列表、日期控件、手风琴等。大部分的组件你都完全不需要写任何 JS 代码。具体参看官方文档,注意：现在Framework7已经更新到3.x的版本，目前用的最多的应该依然是2.x的版本，毋庸置疑，新出来的东西大多开发者都不会选择直接使用，而是等社区成熟，避免踩坑，不过这也是开发者边工作边进步的一种方式。走远了，现在回到正题，介绍一下Framework7框架的简单使用 入门级使用使用Framework7可以很方便创建你的web应用，有两种快速上手的办法： 你可以从example或者demo apps中选择一个应用并做修改成为自己的应用。也可以从头开始创建应用。 让我们看看如何从头开始创建一个应用: 下载安装Framework7首先，我们需要下载Framework7需要的所有文件： 可以从 Framework7 GitHub repository 上下载代码。 或者通过bower来安装: bower install framework7 在下载/安装好的目录下，我们需要的文件都在 dist 目录下 基本布局在这个基本APP中我们使用iOS主题。Android/Material 应用布局请参考App Layout 我们首选需要创建一个 index.html 文件。这是一个 iOS 单页应用，有一个 view, left panel 和 动态穿透布局的navbar 和 toolbar: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!-- Required meta tags--&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt; &lt;!-- Your app title --&gt; &lt;title&gt;My App&lt;/title&gt; &lt;!-- Path to Framework7 iOS CSS theme styles--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/framework7.ios.min.css&quot;&gt; &lt;!-- Path to Framework7 iOS related color styles --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/framework7.ios.colors.min.css&quot;&gt; &lt;!-- Path to your custom app styles--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/my-app.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- Status bar overlay for full screen mode (PhoneGap) --&gt; &lt;div class=&quot;statusbar-overlay&quot;&gt;&lt;/div&gt; &lt;!-- Panels overlay--&gt; &lt;div class=&quot;panel-overlay&quot;&gt;&lt;/div&gt; &lt;!-- Left panel with reveal effect--&gt; &lt;div class=&quot;panel panel-left panel-reveal&quot;&gt; &lt;div class=&quot;content-block&quot;&gt; &lt;p&gt;Left panel content goes here&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Views --&gt; &lt;div class=&quot;views&quot;&gt; &lt;!-- Your main view, should have &quot;view-main&quot; class --&gt; &lt;div class=&quot;view view-main&quot;&gt; &lt;!-- Top Navbar--&gt; &lt;div class=&quot;navbar&quot;&gt; &lt;div class=&quot;navbar-inner&quot;&gt; &lt;!-- We need cool sliding animation on title element, so we have additional &quot;sliding&quot; class --&gt; &lt;div class=&quot;center sliding&quot;&gt;Awesome App&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;!-- Right link contains only icon - additional &quot;icon-only&quot; class Additional &quot;open-panel&quot; class tells app to open panel when we click on this link --&gt; &lt;a href=&quot;#&quot; class=&quot;link icon-only open-panel&quot;&gt;&lt;i class=&quot;icon icon-bars-blue&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Pages container, because we use fixed-through navbar and toolbar, it has additional appropriate classes--&gt; &lt;div class=&quot;pages navbar-through toolbar-through&quot;&gt; &lt;!-- Page, &quot;data-page&quot; contains page name --&gt; &lt;div data-page=&quot;index&quot; class=&quot;page&quot;&gt; &lt;!-- Scrollable page content --&gt; &lt;div class=&quot;page-content&quot;&gt; &lt;p&gt;Page content goes here&lt;/p&gt; &lt;!-- Link to another page --&gt; &lt;a href=&quot;about.html&quot;&gt;About app&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Bottom Toolbar--&gt; &lt;div class=&quot;toolbar&quot;&gt; &lt;div class=&quot;toolbar-inner&quot;&gt; &lt;!-- Toolbar links --&gt; &lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;Link 1&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;Link 2&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Path to Framework7 Library JS--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;path/to/framework7.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Path to your app js--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;path/to/my-app.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 初始化APP我们写好布局，引用了 Framework7 的JS和CSS之后，我们需要初始化 APP 和 View. 在我们的 my-app.js 文件中这样写： 1234567891011// Initialize appvar myApp = new Framework7();// If we need to use custom DOM library, let's save it to $$ variable:var $$ = Framework7.$;// Add viewvar mainView = myApp.addView('.view-main', &#123; // Because we want to use dynamic navbar, we need to enable it for this view: dynamicNavbar: true&#125;); 再添加一个Page我们添加一个 “about app”页面，放在 about.html 文件中 这里需要注意的几个地方，避免大家踩坑 &lt;div class=&quot;pages&quot;&gt; 是page在同一个View中的容器. Pages 是必须的，因为所有的页面切换都在这里 ； 在 main layout(index.html) 中，每一个 Page 都应该放在 Pages 容器中(&lt;div class=&quot;pages&quot;&gt;)，而 Pages 必须是 View 的子元素(&lt;div class=&quot;view&quot;&gt;)。 你会发现每一个 page 都有一个 data-page 属性，存储了一个唯一的page名。这个属性不是必须的，但是强烈推荐使用。 这个属性在 page 事件中或者在page 回调函数中会非常有用，可以用来帮助我们确定加载的是哪一个页面。 所有的可见的内容，比如列表和表单等，都应该放在 &lt;div class=&quot;page-content&quot;&gt; 中，她是 &lt;div class=&quot;page&quot;&gt; 的子元素。这样才能保证正确的样式，布局和滚动。 12345678910111213141516171819202122232425&lt;!-- Top Navbar--&gt;&lt;div class=&quot;navbar&quot;&gt; &lt;div class=&quot;navbar-inner&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;back link&quot;&gt; &lt;i class=&quot;icon icon-back-blue&quot;&gt;&lt;/i&gt; &lt;span&gt;Back&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;center sliding&quot;&gt;About&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;link icon-only open-panel&quot;&gt;&lt;i class=&quot;icon icon-bars-blue&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;pages&quot;&gt; &lt;div data-page=&quot;about&quot; class=&quot;page&quot;&gt; &lt;div class=&quot;page-content&quot;&gt; &lt;div class=&quot;content-block&quot;&gt; &lt;p&gt;Here is About page!&lt;/p&gt; &lt;p&gt;Fusce eros lectus, accumsan eget mi vel, iaculis tincidunt felis. Nulla tincidunt pharetra sagittis. Fusce in felis eros. Nulla sit amet aliquam lorem, et gravida ipsum. Mauris consectetur nisl non sollicitudin tristique. Praesent vitae metus ac quam rhoncus mattis vel et nisi. Aenean aliquet, felis quis dignissim iaculis, lectus quam tincidunt ligula, et venenatis turpis risus sed lorem. Morbi eu metus elit. Ut vel diam dolor.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 给about页面添加JS代码假设我们需要在 about 页面中执行JS代码。因为 about.html 页面是通过JS加载的，我们不能通过在 about.html 中添加 script 标签的方式来添加JS代码，因为script标签会直接被忽略。Framework7 提供了简单的回调函数，我们可以在 my-app.js中使用： 12345678910111213141516171819202122232425262728293031// 初始化应用程序并将其存储到MyApp变量以进一步访问其方法var myApp = new Framework7();// 我们需要使用自定义DOM库，让我们把它保存到$$变量:var $$ = Framework7.$;// 添加视图var mainView = myApp.addView('.view-main', &#123; // Because we want to use dynamic navbar, we need to enable it for this view: dynamicNavbar: true&#125;);// 现在我们需要运行只针对页面执行的代码// 对于这种情况，我们需要为“pageInit”事件添加事件监听器// Option 1. 对所有页面使用“pageInit”事件处理程序（推荐方式）:$$(document).on('pageInit', function (e) &#123; // 从事件数据获取页面数据 var page = e.detail.page; if (page.name === 'about') &#123; // 下面的代码将针对data-page等于“about”的页执行 myApp.alert('Here comes About page'); &#125;&#125;)// Option 2. 对每个页面的“pageInit”事件注册处理程序$$(document).on('pageInit', '.page[data-page=\"about\"]', function (e) &#123; // 下面的代码将针对data-page等于“about”的页执行 myApp.alert('Here comes About page');&#125;) 打开页面 我们只需要在浏览器中输入 index.html 的地址即可。 因为Framework7是通过Ajax在不同页面间跳转的，所以你需要启动一个 http 服务器才可以（不要直接打开本地文件) 好了，到这一步就证明你已经学会初步使用framework7了，至于组件的使用的和其他核心库我们放到下一篇文章再讲。","categories":[],"tags":[{"name":"framework7","slug":"framework7","permalink":"http://yoursite.com/tags/framework7/"}]},{"title":"Markdown中文版编辑器Tyora","slug":"Markdown中文版编辑器Tyora","date":"2018-07-20T06:24:53.000Z","updated":"2018-07-20T06:24:59.920Z","comments":true,"path":"2018/07/20/Markdown中文版编辑器Tyora/","link":"","permalink":"http://yoursite.com/2018/07/20/Markdown中文版编辑器Tyora/","excerpt":"","text":"Typora(markdown编辑器)前言无意中发现了 Typora 这款 Markdown 编辑器。第一眼看上去它就像任何一款 Markdown 编辑器的同类，尤其是 Mou，但再看一眼，你就发现，它是如此的不同。 因为它将「写字」和「预览」这两件事情合并了，你输入的地方，也是输出的地方，即现在很流行的 WYSIWYG（What You See Is What You Get）。其实转念一想，这不就是回到了 Office Word 嘛，只不过编辑文本时不用再去工具栏上点选，一切的格式都能通过符号来控制。 用 Typora 官方的介绍视频，你就懂这一切是多么的自然。没错，所有的行内元素（如加粗、斜体）都会根据当前是否在编辑态而智能地在编辑态和预览态切换，而区块级元素（如标题、列表）则会在按下 Enter 后即时渲染，不能再次编辑。一切都变得如此干净、纯粹。接下来一起了解一下吧~ 概述Typora, the missing Markdown editor for web developers. 语法加粗强调strong or strong ( Cmd + B ) emphasize or emphasize ( Cmd + I ) Sometimes I want a lot of text to be bold.Like, seriously, a LOT of text 块引用 Right angle brackets &gt; are used for block quotes. 链接和电子邮件An email &#101;&#120;&#x61;&#x6d;&#112;&#108;&#101;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#x65;&#46;&#99;&#111;&#x6d; link. Simple inline link http://chenluois.com, another inline link Smaller, one more inline link with title Resize. A reference style link. Input id, then anywhere in the doc, define the link with corresponding id: Titles ( or called tool tips ) in the links are optional. 图片An inline image , title is optional. A reference style image. 行内代码和块代码Inline code are surround by backtick key. To create a block code: Indent each line by at least 1 tab, or 4 spaces. var Mou = exactlyTheAppIwant; 有序列表Ordered lists are created using “1.” + Space: Ordered list item Ordered list item Ordered list item 无序列表Unordered list are created using “*” + Space: Unordered list item Unordered list item Unordered list item Or using “-“ + Space: Unordered list item Unordered list item Unordered list item Hard LinebreakEnd a line with two or more spaces will create a hard linebreak, called &lt;br /&gt; in HTML. ( Control + Return )Above line ended with 2 spaces. 水平线Three or more asterisks or dashes: 标题Setext-style: This is H1This is H2atx-style: This is H1This is H2This is H3This is H4This is H5This is H6附加语法Footnotes脚注主要像参考样式链接。一个脚注由两个东西组成：文本中的一个标记将成为一个上标数字；一个脚注定义，将放在文档结尾的脚注列表中。脚注看起来像这样： That’s some text with a footnote.[^1] [^1]: And that’s the footnote. 删除线Wrap with 2 tilde characters: Strikethrough 栅栏代码块Start with a line containing 3 or more backticks, and ends with the first line with the same number of backticks: 123Fenced code blocks are like Stardard Markdown’s regular codeblocks, except that they’re not indented and instead rely ona start and end fence lines to delimit the code block. 表格A simple table looks like this: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell If you wish, you can add a leading and tailing pipe to each line of the table: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell Specify alignment for each column by adding colons to separator lines: First Header Second Header Third Header Left Center Right Left Center Right","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"编辑器","slug":"编辑器","permalink":"http://yoursite.com/tags/编辑器/"}]},{"title":"Markdown简明版使用指南","slug":"Markdown简明版使用指南","date":"2018-07-19T04:53:53.000Z","updated":"2018-07-19T10:00:42.254Z","comments":true,"path":"2018/07/19/Markdown简明版使用指南/","link":"","permalink":"http://yoursite.com/2018/07/19/Markdown简明版使用指南/","excerpt":"","text":"简介Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 ###使用指南 标题标题能显示出文章的结构。行首插入1-6个 # ，每增加一个 # 表示更深入层次的内容，对应到标题的深度由 1-6 阶 文本样式（带“”星号的文本样式，在原版Markdown标准中不存在，但在其大部分衍生标准中被添加）链接 :Title加粗 :Bold斜体字 :Italics 高亮 :==text==段落 : 段落之间空一行换行符 : 一行结束时输入两个空格列表 :* 添加星号成为一个新的列表项。引用 :&gt; 引用内容内嵌代码 : alert(&#39;Hello World&#39;);画水平线 (HR) :——– 图片使用Markdown将图像插入文章，你需要在Markdown编辑器输入 。 这时在预览面板中会自动创建一个图像上传框。你可以从电脑桌面拖放图片(.png, .gif, .jpg)到上传框, 或者点击图片上传框使用标准的图像上传方式。 如果你想通过链接插入网络上已经存在的图片，只要单击图片上传框的左下角的“链接”图标，这时就会呈现图像URL的输入框。想给图片添加一个标题, 你需要做的是将标题文本插图中的方括号，e.g;. 插入图片有两种方式：行内式和参数式行内式 参数式[图片2]:(图片地址)用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的 ####区块引用比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句 语法 在之前加上“&gt;” 代码框这个就比较重要了，很多时候都需要展示出一些代码alert(&quot;nice ti meet you!&quot;)如果代码量比较少，只有单行的话，可以用单反引号包起来 多行用三个反引号，如果要写注释，可以在反引号后面写123function sum(a,b)&#123; return a+b;&#125; 华丽的分割线分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以 删除线只需要在文字前后加上两个~~ 使用链接就是这么简单 代码部分1234567891011//撤销申购$$(&quot;.clickbutton .waitfirstTrial&quot;).click(function()&#123; console.log(&quot;当前id&quot;,location.href.split(&quot;=&quot;)[1]); var orderId=location.href.split(&quot;=&quot;)[1]; Server.revokeApplypurchase(&#123;orderId:orderId&#125;,function(data)&#123; console.log(111111); &#125;); // Server.getShopcarNum(&#123; farmId: SYKTools.cookie(Server.currentFarmId) &#125;, // function (data) &#123;console.log(data)&#125; // )&#125;)","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-16T14:19:34.280Z","updated":"2018-07-16T14:19:34.280Z","comments":true,"path":"2018/07/16/hello-world/","link":"","permalink":"http://yoursite.com/2018/07/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}