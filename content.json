{"meta":{"title":"小日的博客","subtitle":null,"description":null,"author":"XiaoRI","url":"http://yoursite.com"},"pages":[{"title":"pagetest","date":"2018-07-21T03:50:30.000Z","updated":"2018-07-21T04:10:20.807Z","comments":true,"path":"pagetest/index.html","permalink":"http://yoursite.com/pagetest/index.html","excerpt":"","text":"使用HEXO的page模板显示引言我其实也不知道是什么样子，就是用来测试一下page模板，基本语法还是一致 还有补充一下现在头脑里充满的全是迷惑！ 这个文件就是问了测试看page模板的显示效果。别无其他用处~"}],"posts":[{"title":"移动端开发的兼容问题","slug":"移动端开发的兼容问题","date":"2018-08-12T10:44:18.000Z","updated":"2018-08-12T13:33:48.840Z","comments":true,"path":"2018/08/12/移动端开发的兼容问题/","link":"","permalink":"http://yoursite.com/2018/08/12/移动端开发的兼容问题/","excerpt":"","text":"前言这里总结一下移动端开发在android和ios不同情况下会遇到的兼容问题~后期陆续跟新补上 示例1、ios下input设置type=button属性disabled设置true,会出现样式文字和背景异常问题，使用opacity=1来解决 2、一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发，css增加cursor:pointer就搞定了 3、1px边框问题使用xx:before{content:’’;position: absolute;top: 0;left: 0;border: 1px solid #ccc;width: 200%;height: 200%;box-sizing:border-box;-webkit-box-sizing:border-box;-webkit-transform: scale(0.5);transform: scale(0.5);-webkit-transform-origin: left top;transform-origin: left top;} 4、input为fixed定位在ios下的bug问题，点击焦点input，input跳到中间位置，可以使用内容滚动框也是fixed来设置 5、移动端字体小于12px使用四周边框或者背景色块，安卓文字偏上bug问题，可以使用整体放大1倍再缩放，而且字体不要是奇数 6、在移动端图片上传图片 使用accept=”image/*” multiple,兼容低端机的问题 7、在h5嵌入app中，ios如果出现垂直滚动条时，手指滑动页面滚动之后，滚动很快停下来，好像踩着刹车在开车，有“滚动很吃力”的感觉self.webView.scrollView.decelerationRate = UIScrollViewDecelerationRateNormal;对webview设置了更低的“减速率” 8、click 300ms 延时响应 使用 Fastclickwindow.addEventListener( “load”, function() {FastClick.attach( document.body );}, false ); 9、input 有placeholder情况下不要设置行高，否则会偏上 10、移动端适配可以使用lib-flexible CSS伪类:active如果你想使用元素的伪类来实现 按下激活 状态，那么你需要知道以下问题： iOS上的几乎任何浏览器，定义元素的伪类 :active 都是无效； Android上，Android Browser 和 Chrome 都支持伪类 :active ，其它第三方浏览器有部分不支持； 定义了 :active 并且当前浏览器环境支持，当手指在滚动或者无意间的划过时，:active 状态都会被激活； 为了规避上述所有的问题，如果需要 按下激活 状态，推荐使用 js 新增一个 className 清除输入框内阴影iOS上的几乎任何浏览器输入框（input, textarea）默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭： 12345678910111213input,textarea &#123; /* 方法1: 去掉边框 */ border: 0; /* 方法2: 边框色透明 */ border-color: transparent; /* 方法3: 重置输入框默认外观 */ -webkit-appearance: none; appearance: none;&#125;复制代码 修正iOS输入框禁用文本色在 iOS 上，如果将输入框 disabled，此时输入框内的文字颜色将比 color 所定义的要浅，并且无法通过给输入框的伪类 :disabled 定义 color 来修正。 想解决这个问题，可以作如下设置，定义输入框的文本填充色： 1234input:disabled &#123; -webkit-text-fill-color: #000;&#125;复制代码 需要注意的是，在 Mac 上的 Safari 也有同样的问题。 Samsung S4圆角BugSamsung S4 手机在 Android Browser4.4.2 上（其他版本未测），如果你使用了 border-radius，并且使用了 -webkit-transform 属性，当使用了 translatez 或者 translate3d 值，圆角会出现问题： 1234567891011.test &#123; border: 2px solid red; width: 50px; height: 50px; border-radius: 50%; background-color: gray; box-shadow: 0 2px 5px rgba(0, 0, 0, .3); -webkit-transform: translate(0, 0) translatez(0); transform: translate(0, 0) translatez(0);&#125;复制代码 12&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;复制代码 如上代码，-webkit-transform: translate(0, 0) translatez(0) 将会导致圆角无法包裹住 background-color。 当然，-webkit-transform: translate3d(0, 0, 0) 也是一样的，所以如果你的某个场景是这样的，那么可以直接使用 -webkit-transform: translate(0, 0) 来避免这个问题。 边框圆角致背景溢出在红米和OPPO等手机某些版本的 Android Webview 中，如果一个元素定义了 border + border-radius，这时如果该元素有背景，那么背景将会溢出圆角之外。 之所以会出现这个问题：其主要原因是因为CSS对背景裁剪（background-clip）有不同的处理方式，通常它可以是 border-box | padding-box | content-box 这3种方式。 浏览器的默认裁减方式是 border-box，即溢出 border 之外的背景都将被裁减。 对于上述无法裁减边框之外背景的手机，将值定义为 padding-box | content-box 都能fix这问题，不过更推荐使用 padding-box。因为使用 content-box，如果定义了 padding 不为 0，背景将无法铺满元素。","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"兼容","slug":"兼容","permalink":"http://yoursite.com/tags/兼容/"}]},{"title":"Vue和微信小程序的区别和比较","slug":"Vue和微信小程序的区别和比较","date":"2018-08-04T14:47:23.000Z","updated":"2018-08-04T14:48:48.641Z","comments":true,"path":"2018/08/04/Vue和微信小程序的区别和比较/","link":"","permalink":"http://yoursite.com/2018/08/04/Vue和微信小程序的区别和比较/","excerpt":"","text":"引言写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。 一、生命周期先贴两张图： vue生命周期 小程序生命周期 相比之下，小程序的钩子函数要简单得多。 ue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。onLoad：页面加载 一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow：页面显示 每次打开页面都会调用一次。 onReady：页面初次渲染完成 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。 对界面的设置如 wx.setNavigationBarTitle请在 onReady之后设置。详见生命周期。 onHide：页面隐藏 当 navigateTo或底部tab切换时调用。 onUnload：页面卸载 当 redirectTo或 navigateBack的时候调用。 数据请求在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在 created或者 mounted中请求数据，而在小程序，会在 onLoad或者 onShow中请求数据。 二、数据绑定vue：vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例： 1&lt;img :src=&quot;imgSrc&quot;/&gt; 小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例： 1&lt;image src=&quot;&#123;&#123;imgSrc&#125;&#125;&quot;&gt;&lt;/image&gt; 三、列表渲染直接贴代码，两者还是有些相似： vue： 1&lt;ul id=&quot;example-1&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;var example1 = new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; items: [ &#123; message: &apos;Foo&apos; &#125;, &#123; message: &apos;Bar&apos; &#125; ] &#125;&#125;) 小程序： 1Page(&#123; data: &#123; items: [ &#123; message: &apos;Foo&apos; &#125;, &#123; message: &apos;Bar&apos; &#125; ] &#125;&#125;)&lt;text wx:for=&quot;&#123;&#123;items&#125;&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt; 四、显示与隐藏元素vue中，使用 v-if 和 v-show控制元素的显示和隐藏。 小程序中，使用 wx-if和 hidden控制元素的显示和隐藏。 五、事件处理vue：使用 v-on:event绑定事件，或者使用 @event绑定事件，例如： 1&lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;&lt;button v-on:click.stop=&quot;counter+=1&quot;&gt;Add1&lt;/button&gt; //阻止事件冒泡 小程序中，全用 bindtap(bind+event)，或者 catchtap(catch+event)绑定事件，例如： 1&lt;button bindtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt;&lt;button catchtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt; //阻止事件冒泡 六、数据双向绑定1、设置值在vue中，只需要再表单元素上加上 v-model,然后再绑定 data中对应的一个值，当表单元素内容发生变化时， data中对应的值也会相应改变，这是vue非常nice的一点。 1&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;reason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos;/&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#app&apos;, data: &#123; reason:&apos;&apos; &#125;&#125;) 但是在小程序中，却没有这个功能。那怎么办呢？ 当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过 this.setData({key:value})来将表单上的值赋值给 data中的对应值。 下面是代码，可以感受一下： 1&lt;input bindinput=&quot;bindReason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos; value=&apos;&#123;&#123;reason&#125;&#125;&apos; name=&quot;reason&quot; /&gt;Page(&#123;data:&#123; reason:&apos;&apos;&#125;,bindReason(e) &#123; this.setData(&#123; reason: e.detail.value &#125;) &#125;&#125;) 当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的 v-model简直爽的不要不要的。 2、取值vue中，通过 this.reason取值。 小程序中，通过 this.data.reason取值。 七、绑定事件传参 在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如： 1&lt;button @click=&quot;say(&apos;明天不上班&apos;)&quot;&gt;&lt;/button&gt;new Vue(&#123; el: &apos;#app&apos;, methods:&#123; say(arg)&#123; consloe.log(arg) &#125; &#125;&#125;) 在 小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的 data-属性上，然后在方法中，通过 e.currentTarget.dataset.*的方式获取，从而完成参数的传递，很麻烦有没有… 1&lt;view class=&apos;tr&apos; bindtap=&apos;toApprove&apos; data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt;&lt;/view&gt;Page(&#123;data:&#123; reason:&apos;&apos;&#125;,toApprove(e) &#123; let id = e.currentTarget.dataset.id; &#125;&#125;) 八、父子组件通信1、子组件的使用在vue中，需要： 1、编写子组件 2、在需要使用的父组件中通过 import引入 3、在 vue的 components中注册 4、在模板中使用 1//子组件 bar.vue&lt;template&gt; &lt;div class=&quot;search-box&quot;&gt; &lt;div @click=&quot;say&quot; :title=&quot;title&quot; class=&quot;icon-dismiss&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123;props:&#123; title:&#123; type:String, default:&apos;&apos; &#125; &#125;&#125;,methods:&#123; say()&#123; console.log(&apos;明天不上班&apos;); this.$emit(&apos;helloWorld&apos;) &#125;&#125;&lt;/script&gt;// 父组件 foo.vue&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;bar :title=&quot;title&quot; @helloWorld=&quot;helloWorld&quot;&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bar from &apos;./bar.vue&apos;export default&#123;data:&#123; title:&quot;我是标题&quot;&#125;,methods:&#123; helloWorld()&#123; console.log(&apos;我接收到子组件传递的事件了&apos;) &#125;&#125;,components:&#123; Bar&#125;&lt;/script&gt; 在小程序中，需要： 1、编写子组件 2、在子组件的 json文件中，将该文件声明为组件 1&#123; &quot;component&quot;: true &#125; 3、在需要引入的父组件的 json文件中，在 usingComponents填写引入组件的组件名以及路径 1&quot;usingComponents&quot;: &#123; &quot;tab-bar&quot;: &quot;../../components/tabBar/tabBar&quot; &#125; 4、在父组件中，直接引入即可 1&lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt; 具体代码： 1// 子组件 &lt;!--components/tabBar/tabBar.wxml--&gt; &lt;view class=&apos;tabbar-wrapper&apos;&gt; &lt;view class=&apos;left-bar &#123;&#123;currentpage===&quot;index&quot;?&quot;active&quot;:&quot;&quot;&#125;&#125;&apos; bindtap=&apos;jumpToIndex&apos;&gt; &lt;text class=&apos;iconfont icon-shouye&apos;&gt;&lt;/text&gt; &lt;view&gt;首页&lt;/view&gt; &lt;/view&gt; &lt;view class=&apos;right-bar &#123;&#123;currentpage===&quot;setting&quot;?&quot;active&quot;:&quot;&quot;&#125;&#125;&apos; bindtap=&apos;jumpToSetting&apos;&gt; &lt;text class=&apos;iconfont icon-shezhi&apos;&gt;&lt;/text&gt; &lt;view&gt;设置&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 2、父子组件间通信在vue中 父组件向子组件传递数据，只需要在子组件通过 v-bind传入一个值，在子组件中，通过 props接收，即可完成数据的传递，示例： 1// 父组件 foo.vue&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;bar :title=&quot;title&quot;&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bar from &apos;./bar.vue&apos;export default&#123;data:&#123; title:&quot;我是标题&quot;&#125;,components:&#123; Bar&#125;&lt;/script&gt;// 子组件bar.vue&lt;template&gt; &lt;div class=&quot;search-box&quot;&gt; &lt;div :title=&quot;title&quot; &gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123;props:&#123; title:&#123; type:String, default:&apos;&apos; &#125; &#125;&#125;&lt;/script&gt; 子组件和父组件通信可以通过 this.$emit将方法和数据传递给父组件。 在小程序中 父组件向子组件通信和vue类似，但是小程序没有通过 v-bind，而是直接将值赋值给一个变量，如下： 1&lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt; 此处， “index”就是要向子组件传递的值。 在子组件 properties中，接收传递的值。 1properties: &#123; // 弹窗标题 currentpage: &#123; // 属性名 type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型） value: &apos;index&apos; // 属性初始值（可选），如果未指定则会根据类型选择一个 &#125; &#125; 子组件向父组件通信和 vue也很类似，代码如下： 1//子组件中methods: &#123; // 传递给父组件 cancelBut: function (e) &#123; var that = this; var myEventDetail = &#123; pickerShow: false, type: &apos;cancel&apos; &#125; // detail对象，提供给事件监听函数 this.triggerEvent(&apos;myevent&apos;, myEventDetail) //myevent自定义名称事件，父组件中使用 &#125;,&#125;//父组件中&lt;bar bind:myevent=&quot;toggleToast&quot;&gt;&lt;/bar&gt;// 获取子组件信息toggleToast(e)&#123; console.log(e.detail)&#125; 如果父组件想要调用子组件的方法vue会给子组件添加一个 ref属性，通过 this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如： 1//子组件&lt;bar ref=&quot;bar&quot;&gt;&lt;/bar&gt;//父组件this.$ref.bar.子组件的方法 小程序是给子组件添加 id或者 class，然后通过 this.selectComponent找到子组件，然后再调用子组件的方法,示例： 1//子组件&lt;bar id=&quot;bar&quot;&gt;&lt;/bar&gt;// 父组件this.selectComponent(&apos;#id&apos;).syaHello() 小程序和vue在这点上还是很相似的。 好了，关于微信小程序和VUE的对比就写到这里，未来微信小程序会越来越好，应用到更多成熟的技术。","categories":[],"tags":[{"name":"framework7","slug":"framework7","permalink":"http://yoursite.com/tags/framework7/"}]},{"title":"framework7学习总结-2","slug":"framework7学习总结-2","date":"2018-08-04T14:44:00.000Z","updated":"2018-08-04T14:45:15.921Z","comments":true,"path":"2018/08/04/framework7学习总结-2/","link":"","permalink":"http://yoursite.com/2018/08/04/framework7学习总结-2/","excerpt":"","text":"前言前面几篇介绍了 framework7的一些基础知识，现在介绍一下自己在使用过程中遇到的一些坑的地方，也能叫踩坑日记吧。 事件多次绑定问题不知道有没有在使用framework7的时候遇到过这个问题，从A页面开始，跳转到B页面，再次返回A页面的时候，页面绑定的事件会触发两次，这时候我就蒙蔽了，一开始我是以为出于页面机制原因，再次返回该页面的时候DOM重新加载，页面又存在缓存的问题，就会导致DOM节点存在多个，也就会触发多次事件，然后我就打印事件源节点，最终发现并不是这个原因。后来通过反复的找，最终发现是绑定事件时机不对，妈呀，这个坑可烦了我好一段时间，后来发现，每次返回页面都会重新绑定事件，就会导致页面点击时多次触发事件，触发次数决定于第几次加载此页，这个时候重新刷新页面可以解决这个问题，但是不可能每次都刷新页面，于是就把点击事件绑定时机由之前的pagereinit换为pageinit,问题也就迎刃而解了。 总之，绑定事件时，由于f7机制的不同，为了避免重复绑定事件，必需保证事件只绑定一次！而将绑定的回调放在除pageinit的其他时机，要么是导致页面触发多次事件，要么是导致事件绑定失败。","categories":[],"tags":[{"name":"framework7","slug":"framework7","permalink":"http://yoursite.com/tags/framework7/"}]},{"title":"framework7学习总结(1)","slug":"framework7学习总结-1","date":"2018-07-29T03:17:20.000Z","updated":"2018-07-29T04:09:28.810Z","comments":true,"path":"2018/07/29/framework7学习总结-1/","link":"","permalink":"http://yoursite.com/2018/07/29/framework7学习总结-1/","excerpt":"","text":"引言本篇主要讨论framework7的page和路由 page页面结构使用framework有着严格的布局要求，依次body&gt;div class=&quot;views&quot;&gt;div class=&quot;view&quot;&gt;div class=&quot;pages&gt;div class=&quot;page&quot;&gt;div class=&quot;page-content&quot;;必须依据此布局格式进行布局，否则会遇到很多意想不到的bug,比如页面不能正常返回和切换等等； 1234567891011121314151617181920212223242526272829&lt;body&gt; ... &lt;!-- Views --&gt; &lt;div class=&quot;views&quot;&gt; &lt;!-- Your main view --&gt; &lt;div class=&quot;view view-main&quot;&gt; &lt;!-- Pages --&gt; &lt;div class=&quot;pages&quot;&gt; &lt;div class=&quot;page&quot; data-page=&quot;home&quot;&gt; &lt;div class=&quot;page-content&quot;&gt; ... page content goes here ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Another view --&gt; &lt;div class=&quot;view another-view&quot;&gt; &lt;!-- Pages --&gt; &lt;div class=&quot;pages&quot;&gt; &lt;div class=&quot;page&quot; data-page=&quot;home-another&quot;&gt; &lt;div class=&quot;page-content&quot;&gt; ... page content goes here ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ...&lt;/body&gt; page事件掌握了常见了page事件能帮助我们更高效的开发app，现在我们看看页面浏览的时候最重要的一部分 - Page 事件。这些事件可以让我们通过JS来操作加载好的Page。 Event Target Description pageBeforeInit Page Element 当Framework7把新页面插入DOM的时候会触发 pageInit Page Element 当Framework7初始化页面的组件的时候会触发 pageReinit Page Element 当缓存页面可见时，将触发此事件。它只适用于内联页面（DOM缓存页）。 pageBeforeAnimation Page Element 当页面初始化完成并且可以做动画的时候触发 pageAfterAnimation Page Element 在页面动画完成之后触发 pageBeforeRemove Page Element Page从DOM中移除之前就会触发这个事件。如果你希望做一些解除事件绑定或者销毁一些插件的时候，这个方法是很有用的。 pageBack Page Element 在返回上一页动画执行之前就会触发这个事件。和 “pageBeforeAnimation” 的不同之处在于，这个事件在老页面上也会触发，也就是那个从中间滑动到右边的页面。 pageAfterBack Page Element 返回上一页动画执行完成之后触发这个事件。同样，区别于”pageAfterAnimation”，他也会在老页面上触发。 有两种方式可以使用这些事件： 12345678910// Option 1. Using one &apos;pageInit&apos; handler for all pages (recommended way):$$(document).on(&apos;pageInit&apos;, function (e) &#123; // Do something here when page loaded and initialized &#125;) // Option 2. Using live &apos;pageInit&apos; event handlers for each page (not recommended)$$(document).on(&apos;pageInit&apos;, &apos;.page[data-page=&quot;about&quot;]&apos;, function (e) &#123; // Do something here when page with data-page=&quot;about&quot; attribute loaded and initialized&#125;) 视图中页面切换的方法在视图中切换是非常常见的功能，官方也给我们提供了对应的API 在视图中主要有两个路由器方法: mainView.router.load(options) - 把一个页面加载到当前视图 mainView.router.back(options) - 这个方法会触发一个反向的动画并回到上一个页面，也就是浏览历史上的回退 上面这些方法都接受一个 options 对象作为参数，这个参数有如下属性: 参数 类型 说明 url string 需要加载的页面的URL content string or HTMLElement or [jQuery/Zepto/DOM7 collection] or [array of HTMLElement] 需要加载的动态页面的内容 pageName string 需要加载的页面的名称(data-page)。只用在内联页面(DOM cached)。 template function (Template7 compiled template) 需要加载并渲染的模板 context object or array 渲染Template7 模板时需要的上下文。这里有更多说明Template7 Pages。 contextName string 可选的。用来渲染 Template7 的 templatesData 的上下文名称/路径。这里查看更多说明 Template7 Pages query object Object with additionall query parameters that could be retreived in query object of Page Data force boolean 可选的。只对 back 方法有效。如果设置为 true，那么会忽略浏览历史中的上一个页面，而是直接加载指定的页面。 ignoreCache boolean 可选的。如果设置为 true ，那么会忽略URL对应的缓存，并且再次通过XHR来加载。 animatePages boolean 可选的。可以覆盖在 View 中的相同参数，打开/关闭页面切换的动画。 reload boolean 可选的。如果设置为 true，那么不会当做新页面加载，而是直接替换当前视图的当前页面。并且在视图浏览历史中替换最后一条历史。 reloadPrevious boolean 可选的。和 reload 一样，不过是对上一个页面。 pushState boolean 可选的。是否把浏览历史存储在浏览器的浏览历史中。(这样可以使用浏览器的后退/前进按钮） 注意， url, content, pageName 这三个参数，你只能同时使用一个。 视图中页面切换的快捷方式加载新页面的方法:mainView.router.loadPage(url) - 加载指定的页面到视图中。其实和你在页面中点击一个链接是一样的效果。 url - 需要加载的页面的URL mainView..router.loadContent(content) - 把动态生成的内容当做一个页面加载 content - string or HTMLElement or [jQuery/Zepto/DOM7 collection] or [array of HTMLElement] - 需要加载的内容 重新加载当前页面的方法:mainView.router.reloadPage(url) - 重新加载指定的页面到视图的当前页面。同时也会修改视图的浏览历史，把最后一条记录替换成指定的URL。 url - 需要加载页面的URL mainView.router.reloadContent(content) - 重新加载指定的内容到视图的当前页面。同时也会修改视图的浏览历史，把最后一条记录替换成指定的URL。 content - string or HTMLElement or [jQuery/Zepto/DOM7 collection] or [array of HTMLElement] - 需要加载的内容 重新加载上一个页面的方法（如果视图的DOM中有两个页面）：mainView.router.reloadPreviousPage(url) - 重新加载指定的页面到视图的上一个页面。同时也会修改视图的浏览历史，把最后一条记录替换成指定的URL。 url - 需要加载页面的URL mainView.router.reloadPreviousContent(content) - 重新加载指定的内容到视图的上一个页面。同时也会修改视图的浏览历史，把最后一条记录替换成指定的URL。 content - string or HTMLElement or [jQuery/Zepto/DOM7 collection] or [array of HTMLElement] - 需要加载内容 刷新页面的方法:mainView.router.refreshPage() - 刷新视图的当前页面。和你调用 .reloadPage 方法并且传入当前页面的URL是一样的效果 mainView.router.refreshPreviousPage() - 刷新视图的上一个页面。和你调用 .reloadPreviousPage 方法并且传入上一个页面的URL是一样的效果 路由Ajax Page我们有了一个有View和Page的应用结构，现在我们需要理解如何创建新的Page，以及Framework7是如何加载他们的。 下面有两个重要的地方请注意： p 默认情况下 Framework7 会使用 Ajax 加载所有的页面，除了带有 external class的链接（）和没有正确 href 值的链接（比如是空的或者是 #）。 p 在 初始化 时候传递不同的 ajaxLinks 参数可以改变这个行为。 所以我们如果需要创建一个链接指向 about.html，我们只需要按照平时一样写 &lt;a&gt;标签就可以： 1&lt;a href=&quot;about.html&quot;&gt;Go to About page&lt;/a&gt; 当我们点击这个链接的时候，Framework7会通过Ajax获取 about.html，解析它的内容，然后把它插入到DOM中，并且做一个动画切换到这个新页面。 Page 内部的结构因为Framework7有一个非常聪明的解析器，所以在内部页面中我们不需要完整的HTML结构（head,body,views,pages等)。比如 about.html 的内容： 1234&lt;-- That is all we have in about.html file --&gt;&lt;div class=&quot;page&quot; data-page=&quot;about&quot;&gt;... About page content goes here&lt;/div&gt; 重点是，Framework7 解析器会尝试在ajax加载的页面中寻找 &lt;div class=&quot;page&quot;&gt;，所以我们不需要完整的HTML结构。当然这不是强制的，你可以写出完整的页面结构。 取消/增加页面切换动画有时候你在加载页面或者后退的时候需要立刻执行，不想要一个切换的动画效果，可以通过增加一个 “no-animation” class 在链接上即可。 1234567&lt;div class=&quot;page&quot; data-page=&quot;about&quot;&gt; &lt;-- Add additional &quot;no-anmation&quot; class to link to diable animated page transition --&gt; &lt;a href=&quot;about.html&quot; class=&quot;no-animation&quot;&gt; Load About page immediately &lt;/a&gt; &lt;-- The same rule for back link --&gt; &lt;a href=&quot;index.html&quot; class=&quot;back no-animation&quot;&gt; Go back immediately &lt;/a&gt;&lt;/div&gt; 如果我们已经全局禁用了动画，但是在某些链接上希望启用这些动画，那么我们可以给链接加上 “with-animation” class。 1234567&lt;div class=&quot;page&quot; data-page=&quot;about&quot;&gt; &lt;!-- Add additional &quot;with-anmation&quot; class to link to enable animated page transition --&gt; &lt;a href=&quot;about.html&quot; class=&quot;with-animation&quot;&gt; Load About page with animation &lt;/a&gt; &lt;!-- The same rule for back link --&gt; &lt;a href=&quot;index.html&quot; class=&quot;back with-animation&quot;&gt; Go back with animation &lt;/a&gt;&lt;/div&gt; 通过 data 标签配置更多选项有时候我们希望在某些链接上有更多的配置，我们可以使用作为 data-属性来配置所有在 视图链接方法中的参数，比如： 12345678&lt;!-- Refresh currently active page (reload from server) --&gt;&lt;a href=&quot;about.html&quot; data-reload=&quot;true&quot; data-ignore-cache=&quot;true&quot;&gt;Refresh page&lt;/a&gt; &lt;!-- Go back but to another page, not to actual previous page in history. Such method also allows to jump back in history: --&gt;&lt;a href=&quot;about.html&quot; class=&quot;back&quot; data-force=&quot;true&quot;&gt;Back to About&lt;/a&gt; &lt;!-- Load new page without animation --&gt;&lt;a href=&quot;about.html&quot; data-animate-pages=&quot;false&quot;&gt;&lt;/a&gt; 结论Framework7 中，页面之间的链接和路由都是很简单的，你只需要记住： 你需要使用普通的 &lt;a&gt; 标签，她有一个href属性指向你需要加载的页面。 通过ajax加载的页面不需要有完整的HTML结构。只需要有 (和 如果你需要动态的滚动条) 如果你在同一个文件中有多个Page，把他们用 包裹起来，并且给每一个View设置好正确的class。 只需给一个链接加上 back class ()，她就会自动变成一个后退链接。 ###","categories":[],"tags":[{"name":"framework7","slug":"framework7","permalink":"http://yoursite.com/tags/framework7/"}]},{"title":"Hybrid App 和Native App开发对比","slug":"Hybrid-App-和Native-App开发对比","date":"2018-07-28T02:40:22.000Z","updated":"2018-07-29T02:37:23.092Z","comments":true,"path":"2018/07/28/Hybrid-App-和Native-App开发对比/","link":"","permalink":"http://yoursite.com/2018/07/28/Hybrid-App-和Native-App开发对比/","excerpt":"","text":"引言目前app开发市场需求量越来越大，此片文章主要涉及开发技术展开讨论。 智能手机之普及不用多说，手机APP渗投到各个行业：电商（淘宝、京东等）、金融（各手机行业、P2P借贷等）、医疗（智慧医疗）、交通（滴滴、Uber等）、教育（慕课网等）、餐饮（饿了吗、美团等）……反正只要是个企业，无论规模大小，都已经订制或将要订制自己的APP。这么多APP无外乎就三种模式：Native App、Web App、Hybrid App。 app的开发技术，目前流行的无非就是两种开发方式，原生和Html5。原生又分为安卓平台和IOS平台。 背景目前争论不休的问题，在早先前争论CS，BS架构的软件系统是一样一样的。原先BS，CS对用户而言的区别是需不需要安装客户端。BS是通过浏览器来访问，用PC，平板，Win，Mac都能访问，用户不需要下载额外的客户端，同时运维和升级提供很大的便利。CS则需要下载客户端软件，安装，然后登录使用，升级的话，要么升级链接库，要么重新安装升级包，比较不方便，优势是很多算法在本地运行，对服务器要求不高。 CS、BS之争是在PC端，那么现在原生和H5之争是在移动端。 那么评判一个APP用什么技术来开发呢？经过总结，可以有如下判断依据： 1.如果APP中出现大段文字（如新闻、攻略等），且格式比较丰富（如加粗，字体多样），那么用H5会比较方便。原因是原生开发解析json对字符串格式处理不算很好。 2.如果讲究APP反应速度（含页面切换流畅性），则选用原生开发，因为H5其本质是网页，换页时，基本要加载整个页面，就像是浏览器打开一个新页面一样，显得较慢，而原生系统则只加载变化部分。 3.如果APP对有无网络、网络优劣敏感（譬如有离线操作，在线操作），那么，基本选用原生开发，虽然H5可以做到，但是很复杂。 4.如果APP需要频繁调用硬件（摄像头、麦克风、未来的湿度检测仪等等）那么，基本选用原生开发，这样支持硬件更多，更容易扩展，且调用速度更快，H5就望尘莫及了。 5.如果APP用户常见页面频换，如（淘宝首页各种不同活动），那么用H5，维护起来更容易。 6.如果预算有限（H5开发一套可跨平台覆盖安卓、ios，黑莓、塞班），不是很讲究用户体验，不在乎加载速度，那非H5不可。 列举那么多，实际上有个采阴补阳的方法是H5+原生混合开发，对于固定格式、页面速度要求高，的模块（如PDB的即时通讯、宝典、我的项目）采用原生开发，对于新闻、大段文字、资讯类的（如信息广场、发表、问吧等）用H5页面来加载，将其嵌入到原生框架中那么，可以达到比较良好的体验。那么到底什么时混合式开发了，终于可以切入主题了。 三种开发方式1. Native AppNative App，原生APP，使用原生（即Android或iOS）开发的APP。两年多以前这非常流行，到现在为止，原生开发人员数量众多，一抓一大票，技术成熟，好多培训机构都抱着老掉牙的API翻来覆去的讲——尤其是Android。Sorry，说错话了……使用原生开发有其优势：应用的性能好，适配起来相对容易。学习成本要看人，个人觉得技术点不多，门槛相对稍高，但入门后学习起来就很轻松——网络资料实在是太多了。 但原生APP最头疼的有三个问题： 1、无法跨平台：Android和iOS都需要开发各自平台的版本——开发成本高； 2、升级麻烦：每次升级都要下载安装包，Android还好，反正不需要审核，下载就下载吧，但iOS就麻烦了，发布每个版本还得经过App Store的审核，这导致第三个问题； 3、Android和iOS很难同步发布。 2.Web App所谓的Web App，就是把手机当做一个浏览器（Android使用WebView，iOS使用UIWebView），做几个页面挂在服务器端，类似于一个小网站。这样说虽然不太贴切，但实际上给人的感觉就是这样的。虽然开发成本大大降低，但页面访问速度慢、操作体验差。于是第三种模式诞生了。 3.Hybrid App乍一看和Web App没啥差别，但涉及到的技术成本、开发成本、学习成本比Web App高，它综合了Web App的开发速度和Native App的高性能体验。之所以说学习成本高，是因为开发高性能的Hybrid App有难度，网络资料少。如何做好屏幕适配、提高UI响应速度、如何最大化使用原生功能等内容，网络几乎没有资料。网上能搜索到的都是很粗略的东西，或者就是Hello World级别的东西，涉及到稍微细节一点的东西几乎没有。由于本系列文章都只讲Hybrid，故在此不再啰嗦了。 在网上搜集到了关于三种开发方式的详细对比，如下表 特性 Native App Hybrid App Web App 开发语言 只用Native开发语言 Native和Web开发语言或只用Web开发语言 只用Web开发语言 代码移植性和优化 无 高 高 访问针对特定设备的特性 高 中 低 充分利用现有知识 低 高 高 高级图形 高 中 中 升级灵活性 低，总是通过应用升级 中，部分更新可不通过应用商店升级 高 安装体验 高，从应用商店安装 高，从应用商店安装 中，通过浏览器安装 混合开发概述Hybrid App主要以JS+Native两者相互调用为主，从开发层面实现“一次开发，多处运行”的机制，成为真正适合跨平台的开发。Hybrid App兼具了Native App良好用户体验的优势，也兼具了Web App使用HTML5跨平台开发低成本的优势。 目前已经有众多Hybrid App开发成功应用，比如美团、爱奇艺、微信等知名移动应用，都是采用Hybrid App开发模式。 混合开发应用场景 （1）折中考虑——如果企业使用 Hybrid 开发方法，就能集Native 和web两者之所长。一方面，Native 让开发者可以充分利用现代移动设备所提供的全部不同的特性和功能。另一方面，使用 Web 语言编写的所有代码都可以在不同的移动平台之间共享，使得开发和日常维护过程变得集中式、更简短、更经济高效。 （2）内部技能——许多企业都拥有Web 开发技能。如果选择 Hybrid 开发方法，在合适解决方案的支持下，Web 开发者只要仅仅运用 HTML、CSS 和 JavaScript 等 Web 技能，就能构建 App，同时提供 Native 用户体验。 （3）考虑未来——HTML5的可用性和功能都在迅速改进。许多分析师预测，它可能会成为开发前端 App 的默认技术。如果用 HTML 来编写 App 的大部分代码，并且只有在需要时才使用 Native 代码，公司就能确保他们今天的投入在明天不会变得过时，因为 HTML 功能变得更丰富，可以满足现代企业一系列更广泛的移动要求。 总结起来两句话： 纯Native的迭代太慢，不能动态更新，且不能跨平台 纯Web页，有很功能无法实现，有些动画效果实现其体验太差 因此我们需要Hybrid ps：怎样判断一个App的页面是native的还是web的？ Android手机 设置-&gt;开发者选项-&gt;显示布局边界 即可 混合开发app技术Hybrid App所需技术Hybrid App由于需要保证运行性能与开发速度，需要如下技术支持，本系列博文均会按照Demo的开发顺序依次描述本人的开发心得和教训，希望能起到一个抛砖引玉的作用。 Native技术Native技术主要用于提供原生支持，要做到跨平台，就需要掌握部分Android和iOS的知识，除了多线程，文件存储等基础知识，Android需要非常熟练的掌握WebView**、WebSettings、WebChromeClient、WebClient四大对象。iOS需要非常熟练掌握UIWebView**对象。 Web技术1、 HTML5熟练掌握HTML5的各个标签，如何编写最优的文档结构。 2、 CSS熟练掌握CSS2和CSS3的新特性，能按照效果图编写最高性能的样式。 使用SCSS生成CSS，将CSS可编程化。 3、 JavaScript实现业务逻辑控制。个人理解JavaScript主要包含两大内容：DOM编程和面向对象编程。大部分JS开发人员就只掌握DOM编程，诸如document.getElementById()等，但面向对象是很重要的一个方面。 4、 性能和开发模块化编程：编写可复用的组建； CSS渲染：了解浏览器的CSS渲染引擎才能编写更高效率的样式； JS解析：了解浏览器的JS解析引擎才能优化JS脚本； HTTP**协议**：熟练掌握HTTP请求的各个内容； AJAX：和服务器端的交互大都采用AJAX。 流行框架Hybrid 框架Cordova/PhoneGap：侧重于JS与原生的交互，开发简单，但性能差，如触摸时反应不灵敏。 AppCan：性能还行，使用简单，但要提交代码给AppCan的服务器才能打包，相信有追求的企业是不会把自己的代码提交给第三方，把打包权利交给第三方的。 Ionic Framework：在Cordova的基础上增加一些UI/JS方面的东西，样式还不错，但同样具有Cordova的不足。 UI/JS框架jQuery Mobile：上手简单，组件丰富，但性能超级差，闪屏现象严重。 Senche Touch：简单看过，没有使用过，貌似UI很漂亮，学习成本高。 React Native：FB推出的，当年FB是最早尝试Hybrid的，但性能超差，于是APP放弃了Hybrid，走原生的道路。在大家都不看好H5时，FB暗中深入挖掘H5，三年之后推出了这个框架，非常推荐各位去学习其中的思想。 GMU：百度推出的，这个不错。 Framework7 是一个开源免费的框架可以用来开发混合移动应用（原生和HTML混合）或者开发iOS7风格的WEB APP。也可以用来作为原型开发工具，可以迅速创建一个应用的原型。Framework7 最主要的功能是可以使用HTML、CSS和JS来开发iOS7应用。Framework7 是完全免费开源的。 Framework7 并不能兼容所有的设备。她只专注于为iOS7 提供最好的体验。 Framework7 或者叫 F7 是全功能的绑定 iOS 7 应用的 HTML 框架。Framework7 是免费开源的 HTML 移动端框架，用来开发混合移动端应用或者 iOS 7 的 Web 应用，并且带有 iOS 7 的原生外观和感觉。Framework7 也是独立的原型应用工具。 Framework7 使用 Javascript，CSS 和 HTML 来创建 iOS 7 应用，支持多个平台的迁移（PhoneGap），但是不是支持所有平台，主要还是针对 iOS 7。 UI/JS库这个就多了，jQuery、Zepto、Swiper、iScroll、RequireJS、AngularJS…… 个人建议由于移动端是一个重视性能和用户体验的终端，大量采用框架存在一些问题： 1、 扩展、维护、定制成本，这个非常需要考虑，或许框架提供的UI风格和自己设计的UI风格差异大，导致设计围绕框架转，不符合产品的需求。 2、 既然是框架，强调的是覆盖面广度和功能的全面，会有很多无用的东西，带来累赘； 3、 框架本身存在BUG，或许需要开发人员面对一些能力之外的问题。 好了，本篇文章就先介绍到这里，下篇文章再介绍关于Framework7一些使用中容易踩坑的地方。","categories":[],"tags":[{"name":"hybridApp 框架","slug":"hybridApp-框架","permalink":"http://yoursite.com/tags/hybridApp-框架/"}]},{"title":"整理一下framework7零散知识","slug":"framework7学习总结（入门篇）","date":"2018-07-21T04:35:13.000Z","updated":"2018-07-21T05:52:30.038Z","comments":true,"path":"2018/07/21/framework7学习总结（入门篇）/","link":"","permalink":"http://yoursite.com/2018/07/21/framework7学习总结（入门篇）/","excerpt":"","text":"引言最近在工作时遇到一个以前都没接触过的框架，Framework7,这里简单介绍一下最近一个月左右自己的理解。希望有理解不对的大家可以纠正。 之所以大家会选择Framework7，最根本的原因还是Framework7 是一个开源免费的框架。可以用来开发混合移动应用（原生和 HTML 混合）或者开发 iOS &amp; Android 风格的 WEB APP。也可以用来作为原型开发工具，可以迅速创建一个应用的原型。 开发自己的app是当前互联网公司必不可少的一种战略方式，而不同的公司考虑的角度和使用的用户又各有不同，这里再网上找到一副整理的很好的当前开发app的框架对比图，大家可以通过仔细对比，找到符合公司文化，最适合公司的移动端混合式开发框架，废话不多说了，上图 再来对于开发者而言，快速上手也算得上框架的一种优势，使用时只需要一个基本的 HTML 布局，并且把 Framework7 的 CSS 和 JS 文件引入即可！Framework7 不会强制你写任何自定义的标签，也不会通过 JS 来生成任何额外的内容。你不需要通过 JS 或者 JSON 来写页面，只需要普通的 HTML 就可以。 同时，Framework7 有大量可以直接使用的 UI 组件和工具，比如导航栏、侧边栏、弹出层、标签页、虚拟列表、日期控件、手风琴等。大部分的组件你都完全不需要写任何 JS 代码。具体参看官方文档,注意：现在Framework7已经更新到3.x的版本，目前用的最多的应该依然是2.x的版本，毋庸置疑，新出来的东西大多开发者都不会选择直接使用，而是等社区成熟，避免踩坑，不过这也是开发者边工作边进步的一种方式。走远了，现在回到正题，介绍一下Framework7框架的简单使用 入门级使用使用Framework7可以很方便创建你的web应用，有两种快速上手的办法： 你可以从example或者demo apps中选择一个应用并做修改成为自己的应用。也可以从头开始创建应用。 让我们看看如何从头开始创建一个应用: 下载安装Framework7首先，我们需要下载Framework7需要的所有文件： 可以从 Framework7 GitHub repository 上下载代码。 或者通过bower来安装: bower install framework7 在下载/安装好的目录下，我们需要的文件都在 dist 目录下 基本布局在这个基本APP中我们使用iOS主题。Android/Material 应用布局请参考App Layout 我们首选需要创建一个 index.html 文件。这是一个 iOS 单页应用，有一个 view, left panel 和 动态穿透布局的navbar 和 toolbar: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!-- Required meta tags--&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt; &lt;!-- Your app title --&gt; &lt;title&gt;My App&lt;/title&gt; &lt;!-- Path to Framework7 iOS CSS theme styles--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/framework7.ios.min.css&quot;&gt; &lt;!-- Path to Framework7 iOS related color styles --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/framework7.ios.colors.min.css&quot;&gt; &lt;!-- Path to your custom app styles--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/my-app.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- Status bar overlay for full screen mode (PhoneGap) --&gt; &lt;div class=&quot;statusbar-overlay&quot;&gt;&lt;/div&gt; &lt;!-- Panels overlay--&gt; &lt;div class=&quot;panel-overlay&quot;&gt;&lt;/div&gt; &lt;!-- Left panel with reveal effect--&gt; &lt;div class=&quot;panel panel-left panel-reveal&quot;&gt; &lt;div class=&quot;content-block&quot;&gt; &lt;p&gt;Left panel content goes here&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Views --&gt; &lt;div class=&quot;views&quot;&gt; &lt;!-- Your main view, should have &quot;view-main&quot; class --&gt; &lt;div class=&quot;view view-main&quot;&gt; &lt;!-- Top Navbar--&gt; &lt;div class=&quot;navbar&quot;&gt; &lt;div class=&quot;navbar-inner&quot;&gt; &lt;!-- We need cool sliding animation on title element, so we have additional &quot;sliding&quot; class --&gt; &lt;div class=&quot;center sliding&quot;&gt;Awesome App&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;!-- Right link contains only icon - additional &quot;icon-only&quot; class Additional &quot;open-panel&quot; class tells app to open panel when we click on this link --&gt; &lt;a href=&quot;#&quot; class=&quot;link icon-only open-panel&quot;&gt;&lt;i class=&quot;icon icon-bars-blue&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Pages container, because we use fixed-through navbar and toolbar, it has additional appropriate classes--&gt; &lt;div class=&quot;pages navbar-through toolbar-through&quot;&gt; &lt;!-- Page, &quot;data-page&quot; contains page name --&gt; &lt;div data-page=&quot;index&quot; class=&quot;page&quot;&gt; &lt;!-- Scrollable page content --&gt; &lt;div class=&quot;page-content&quot;&gt; &lt;p&gt;Page content goes here&lt;/p&gt; &lt;!-- Link to another page --&gt; &lt;a href=&quot;about.html&quot;&gt;About app&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Bottom Toolbar--&gt; &lt;div class=&quot;toolbar&quot;&gt; &lt;div class=&quot;toolbar-inner&quot;&gt; &lt;!-- Toolbar links --&gt; &lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;Link 1&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;Link 2&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Path to Framework7 Library JS--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;path/to/framework7.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Path to your app js--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;path/to/my-app.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 初始化APP我们写好布局，引用了 Framework7 的JS和CSS之后，我们需要初始化 APP 和 View. 在我们的 my-app.js 文件中这样写： 1234567891011// Initialize appvar myApp = new Framework7();// If we need to use custom DOM library, let's save it to $$ variable:var $$ = Framework7.$;// Add viewvar mainView = myApp.addView('.view-main', &#123; // Because we want to use dynamic navbar, we need to enable it for this view: dynamicNavbar: true&#125;); 再添加一个Page我们添加一个 “about app”页面，放在 about.html 文件中 这里需要注意的几个地方，避免大家踩坑 &lt;div class=&quot;pages&quot;&gt; 是page在同一个View中的容器. Pages 是必须的，因为所有的页面切换都在这里 ； 在 main layout(index.html) 中，每一个 Page 都应该放在 Pages 容器中(&lt;div class=&quot;pages&quot;&gt;)，而 Pages 必须是 View 的子元素(&lt;div class=&quot;view&quot;&gt;)。 你会发现每一个 page 都有一个 data-page 属性，存储了一个唯一的page名。这个属性不是必须的，但是强烈推荐使用。 这个属性在 page 事件中或者在page 回调函数中会非常有用，可以用来帮助我们确定加载的是哪一个页面。 所有的可见的内容，比如列表和表单等，都应该放在 &lt;div class=&quot;page-content&quot;&gt; 中，她是 &lt;div class=&quot;page&quot;&gt; 的子元素。这样才能保证正确的样式，布局和滚动。 12345678910111213141516171819202122232425&lt;!-- Top Navbar--&gt;&lt;div class=&quot;navbar&quot;&gt; &lt;div class=&quot;navbar-inner&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;back link&quot;&gt; &lt;i class=&quot;icon icon-back-blue&quot;&gt;&lt;/i&gt; &lt;span&gt;Back&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;center sliding&quot;&gt;About&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;link icon-only open-panel&quot;&gt;&lt;i class=&quot;icon icon-bars-blue&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;pages&quot;&gt; &lt;div data-page=&quot;about&quot; class=&quot;page&quot;&gt; &lt;div class=&quot;page-content&quot;&gt; &lt;div class=&quot;content-block&quot;&gt; &lt;p&gt;Here is About page!&lt;/p&gt; &lt;p&gt;Fusce eros lectus, accumsan eget mi vel, iaculis tincidunt felis. Nulla tincidunt pharetra sagittis. Fusce in felis eros. Nulla sit amet aliquam lorem, et gravida ipsum. Mauris consectetur nisl non sollicitudin tristique. Praesent vitae metus ac quam rhoncus mattis vel et nisi. Aenean aliquet, felis quis dignissim iaculis, lectus quam tincidunt ligula, et venenatis turpis risus sed lorem. Morbi eu metus elit. Ut vel diam dolor.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 给about页面添加JS代码假设我们需要在 about 页面中执行JS代码。因为 about.html 页面是通过JS加载的，我们不能通过在 about.html 中添加 script 标签的方式来添加JS代码，因为script标签会直接被忽略。Framework7 提供了简单的回调函数，我们可以在 my-app.js中使用： 12345678910111213141516171819202122232425262728293031// 初始化应用程序并将其存储到MyApp变量以进一步访问其方法var myApp = new Framework7();// 我们需要使用自定义DOM库，让我们把它保存到$$变量:var $$ = Framework7.$;// 添加视图var mainView = myApp.addView('.view-main', &#123; // Because we want to use dynamic navbar, we need to enable it for this view: dynamicNavbar: true&#125;);// 现在我们需要运行只针对页面执行的代码// 对于这种情况，我们需要为“pageInit”事件添加事件监听器// Option 1. 对所有页面使用“pageInit”事件处理程序（推荐方式）:$$(document).on('pageInit', function (e) &#123; // 从事件数据获取页面数据 var page = e.detail.page; if (page.name === 'about') &#123; // 下面的代码将针对data-page等于“about”的页执行 myApp.alert('Here comes About page'); &#125;&#125;)// Option 2. 对每个页面的“pageInit”事件注册处理程序$$(document).on('pageInit', '.page[data-page=\"about\"]', function (e) &#123; // 下面的代码将针对data-page等于“about”的页执行 myApp.alert('Here comes About page');&#125;) 打开页面 我们只需要在浏览器中输入 index.html 的地址即可。 因为Framework7是通过Ajax在不同页面间跳转的，所以你需要启动一个 http 服务器才可以（不要直接打开本地文件) 好了，到这一步就证明你已经学会初步使用framework7了，至于组件的使用的和其他核心库我们放到下一篇文章再讲。","categories":[],"tags":[{"name":"framework7","slug":"framework7","permalink":"http://yoursite.com/tags/framework7/"}]},{"title":"Markdown中文版编辑器Tyora","slug":"Markdown中文版编辑器Tyora","date":"2018-07-20T06:24:53.000Z","updated":"2018-07-20T06:24:59.920Z","comments":true,"path":"2018/07/20/Markdown中文版编辑器Tyora/","link":"","permalink":"http://yoursite.com/2018/07/20/Markdown中文版编辑器Tyora/","excerpt":"","text":"Typora(markdown编辑器)前言无意中发现了 Typora 这款 Markdown 编辑器。第一眼看上去它就像任何一款 Markdown 编辑器的同类，尤其是 Mou，但再看一眼，你就发现，它是如此的不同。 因为它将「写字」和「预览」这两件事情合并了，你输入的地方，也是输出的地方，即现在很流行的 WYSIWYG（What You See Is What You Get）。其实转念一想，这不就是回到了 Office Word 嘛，只不过编辑文本时不用再去工具栏上点选，一切的格式都能通过符号来控制。 用 Typora 官方的介绍视频，你就懂这一切是多么的自然。没错，所有的行内元素（如加粗、斜体）都会根据当前是否在编辑态而智能地在编辑态和预览态切换，而区块级元素（如标题、列表）则会在按下 Enter 后即时渲染，不能再次编辑。一切都变得如此干净、纯粹。接下来一起了解一下吧~ 概述Typora, the missing Markdown editor for web developers. 语法加粗强调strong or strong ( Cmd + B ) emphasize or emphasize ( Cmd + I ) Sometimes I want a lot of text to be bold.Like, seriously, a LOT of text 块引用 Right angle brackets &gt; are used for block quotes. 链接和电子邮件An email &#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#x40;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109; link. Simple inline link http://chenluois.com, another inline link Smaller, one more inline link with title Resize. A reference style link. Input id, then anywhere in the doc, define the link with corresponding id: Titles ( or called tool tips ) in the links are optional. 图片An inline image , title is optional. A reference style image. 行内代码和块代码Inline code are surround by backtick key. To create a block code: Indent each line by at least 1 tab, or 4 spaces. var Mou = exactlyTheAppIwant; 有序列表Ordered lists are created using “1.” + Space: Ordered list item Ordered list item Ordered list item 无序列表Unordered list are created using “*” + Space: Unordered list item Unordered list item Unordered list item Or using “-“ + Space: Unordered list item Unordered list item Unordered list item Hard LinebreakEnd a line with two or more spaces will create a hard linebreak, called &lt;br /&gt; in HTML. ( Control + Return )Above line ended with 2 spaces. 水平线Three or more asterisks or dashes: 标题Setext-style: This is H1This is H2atx-style: This is H1This is H2This is H3This is H4This is H5This is H6附加语法Footnotes脚注主要像参考样式链接。一个脚注由两个东西组成：文本中的一个标记将成为一个上标数字；一个脚注定义，将放在文档结尾的脚注列表中。脚注看起来像这样： That’s some text with a footnote.[^1] [^1]: And that’s the footnote. 删除线Wrap with 2 tilde characters: Strikethrough 栅栏代码块Start with a line containing 3 or more backticks, and ends with the first line with the same number of backticks: 123Fenced code blocks are like Stardard Markdown’s regular codeblocks, except that they’re not indented and instead rely ona start and end fence lines to delimit the code block. 表格A simple table looks like this: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell If you wish, you can add a leading and tailing pipe to each line of the table: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell Specify alignment for each column by adding colons to separator lines: First Header Second Header Third Header Left Center Right Left Center Right","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"编辑器","slug":"编辑器","permalink":"http://yoursite.com/tags/编辑器/"}]},{"title":"Markdown简明版使用指南","slug":"Markdown简明版使用指南","date":"2018-07-19T04:53:53.000Z","updated":"2018-07-19T10:00:42.254Z","comments":true,"path":"2018/07/19/Markdown简明版使用指南/","link":"","permalink":"http://yoursite.com/2018/07/19/Markdown简明版使用指南/","excerpt":"","text":"简介Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 ###使用指南 标题标题能显示出文章的结构。行首插入1-6个 # ，每增加一个 # 表示更深入层次的内容，对应到标题的深度由 1-6 阶 文本样式（带“”星号的文本样式，在原版Markdown标准中不存在，但在其大部分衍生标准中被添加）链接 :Title加粗 :Bold斜体字 :Italics 高亮 :==text==段落 : 段落之间空一行换行符 : 一行结束时输入两个空格列表 :* 添加星号成为一个新的列表项。引用 :&gt; 引用内容内嵌代码 : alert(&#39;Hello World&#39;);画水平线 (HR) :——– 图片使用Markdown将图像插入文章，你需要在Markdown编辑器输入 。 这时在预览面板中会自动创建一个图像上传框。你可以从电脑桌面拖放图片(.png, .gif, .jpg)到上传框, 或者点击图片上传框使用标准的图像上传方式。 如果你想通过链接插入网络上已经存在的图片，只要单击图片上传框的左下角的“链接”图标，这时就会呈现图像URL的输入框。想给图片添加一个标题, 你需要做的是将标题文本插图中的方括号，e.g;. 插入图片有两种方式：行内式和参数式行内式 参数式[图片2]:(图片地址)用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的 ####区块引用比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句 语法 在之前加上“&gt;” 代码框这个就比较重要了，很多时候都需要展示出一些代码alert(&quot;nice ti meet you!&quot;)如果代码量比较少，只有单行的话，可以用单反引号包起来 多行用三个反引号，如果要写注释，可以在反引号后面写123function sum(a,b)&#123; return a+b;&#125; 华丽的分割线分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以 删除线只需要在文字前后加上两个~~ 使用链接就是这么简单 代码部分1234567891011//撤销申购$$(&quot;.clickbutton .waitfirstTrial&quot;).click(function()&#123; console.log(&quot;当前id&quot;,location.href.split(&quot;=&quot;)[1]); var orderId=location.href.split(&quot;=&quot;)[1]; Server.revokeApplypurchase(&#123;orderId:orderId&#125;,function(data)&#123; console.log(111111); &#125;); // Server.getShopcarNum(&#123; farmId: SYKTools.cookie(Server.currentFarmId) &#125;, // function (data) &#123;console.log(data)&#125; // )&#125;)","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-16T14:19:34.280Z","updated":"2018-07-16T14:19:34.280Z","comments":true,"path":"2018/07/16/hello-world/","link":"","permalink":"http://yoursite.com/2018/07/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}