{"meta":{"title":"小日的博客","subtitle":null,"description":null,"author":"XiaoRI","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-08-15T03:39:10.000Z","updated":"2018-08-15T03:40:45.631Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"##关于我！！！ 一个学习前端的小菜鸟~ Email：1554019387@qq.com"},{"title":"pagetest","date":"2018-07-21T03:50:30.000Z","updated":"2018-07-21T04:10:20.807Z","comments":true,"path":"pagetest/index.html","permalink":"http://yoursite.com/pagetest/index.html","excerpt":"","text":"使用HEXO的page模板显示引言我其实也不知道是什么样子，就是用来测试一下page模板，基本语法还是一致 还有补充一下现在头脑里充满的全是迷惑！ 这个文件就是问了测试看page模板的显示效果。别无其他用处~"},{"title":"tags","date":"2018-08-15T03:37:10.000Z","updated":"2018-08-15T03:38:01.693Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JS基础知识整理（三）","slug":"JS基础知识整理（三）","date":"2018-09-01T03:48:17.000Z","updated":"2018-09-01T05:13:57.893Z","comments":true,"path":"2018/09/01/JS基础知识整理（三）/","link":"","permalink":"http://yoursite.com/2018/09/01/JS基础知识整理（三）/","excerpt":"","text":"引言前面介绍了JS中变量和对象的概念，这篇内容将描述JS实际的组成和一些核心操作。 JS由三部分组成ECMAScript: (3/5/6/7)它是JS语言的标准,规定了JS的编程语法和基础核心知识 DOM: document object model 文档对象模型,提供给JS很多操作页面中元素的属性和方法 BOM: browser object model 浏览器对象模型 ,提供了很多操作浏览器 的属性方法,而这些方法都存放在window浏览器对象上 ECMAScript(ES) ECMAScript是一种由Ecma国际(前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association)通过ECMA-262标准化的脚本程序设计语言。现在貌似已经更新到ES7了都，不过工作中其实用的最多的还是ES5和ES6的写法，后面可以单独抽出一篇讲讲ES6的一些新特性，这里不展开讨论。 BOM及其组成BOM其实就是浏览器对象模型，提供了一些操作浏览器对象的属性和方法，接下来将一个一个走近他们。 Window对象window对象一般作为浏览器的顶层对象，其下又包括document,history,location,navigator,screen对象。 Window 对象表示浏览器中打开的窗口。 如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对 象，并为每个框架创建一个额外的 window 对象。 注释：没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象。 window对象属性 属性 描述 closed 返回窗口是否已被关闭。 defaultStatus 设置或返回窗口状态栏中的默认文本。 document 对 Document 对象的只读引用。请参阅 Document 对象。 history 对 History 对象的只读引用。请参数 History 对象。 innerheight 返回窗口的文档显示区的高度。 innerwidth 返回窗口的文档显示区的宽度。 length 设置或返回窗口中的框架数量。 location 用于窗口或框架的 Location 对象。请参阅 Location 对象。 name 设置或返回窗口的名称。 Navigator 对 Navigator 对象的只读引用。请参数 Navigator 对象。 opener 返回对创建此窗口的窗口的引用。 outerheight 返回窗口的外部高度。 outerwidth 返回窗口的外部宽度。 pageXOffset 设置或返回当前页面相对于窗口显示区左上角的 X 位置。 pageYOffset 设置或返回当前页面相对于窗口显示区左上角的 Y 位置。 parent 返回父窗口。 Screen 对 Screen 对象的只读引用。请参数 Screen 对象。 self 返回对当前窗口的引用。等价于 Window 属性。 status 设置窗口状态栏的文本。 top 返回最顶层的先辈窗口。 window window 属性等价于 self 属性，它包含了对窗口自身的引用。 screenLeftscreenTopscreenXscreenY 只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。IE、Safari 和 Opera 支持 screenLeft 和 screenTop，而 Firefox 和 Safari 支持 screenX 和 screenY。 Window 对象方法 方法 描述 alert() 显示带有一段消息和一个确认按钮的警告框。 blur() 把键盘焦点从顶层窗口移开。 clearInterval() 取消由 setInterval() 设置的 timeout。 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 close() 关闭浏览器窗口。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 createPopup() 创建一个 pop-up 窗口。 focus() 把键盘焦点给予一个窗口。 moveBy() 可相对窗口的当前坐标把它移动指定的像素。 moveTo() 把窗口的左上角移动到一个指定的坐标。 open() 打开一个新的浏览器窗口或查找一个已命名的窗口。 print() 打印当前窗口的内容。 prompt() 显示可提示用户输入的对话框。 resizeBy() 按照指定的像素调整窗口的大小。 resizeTo() 把窗口的大小调整到指定的宽度和高度。 scrollBy() 按照指定的像素值来滚动内容。 scrollTo() 把内容滚动到指定的坐标。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 一般来说，Window 对象的方法都是对浏览器窗口或框架进行某种操作。而 alert() 方法、confirm() 方法和 prompt 方法则不同，它们通过简单的对话框与用户进行交互。 Navigator对象Navigator 对象包含有关浏览器的信息。 注释：没有应用于 navigator 对象的公开标准，不过所有浏览器都支持该对象。 Navigator 对象属性 属性 描述 appCodeName 返回浏览器的代码名。 appMinorVersion 返回浏览器的次级版本。 appName 返回浏览器的名称。 appVersion 返回浏览器的平台和版本信息。 browserLanguage 返回当前浏览器的语言。 cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值。 cpuClass 返回浏览器系统的 CPU 等级。 onLine 返回指明系统是否处于脱机模式的布尔值。 platform 返回运行浏览器的操作系统平台。 systemLanguage 返回 OS 使用的默认语言。 userAgent 返回由客户机发送服务器的 user-agent 头部的值。 userLanguage 返回 OS 的自然语言设置。 Navigator 对象方法 方法 描述 javaEnabled() 规定浏览器是否启用 Java。 taintEnabled() 规定浏览器是否启用数据污点 (data tainting)。 Navigator对象描述Navigator 对象包含的属性描述了正在使用的浏览器。可以使用这些属性进行平台专用的配置。 虽然这个对象的名称显而易见的是 Netscape 的 Navigator 浏览器，但其他实现了 JavaScript 的浏览器也支持这个对象。 Navigator 对象的实例是唯一的，可以用 Window 对象的 navigator 属性来引用它。 Location对象Location 对象包含有关当前 URL 的信息。 Location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。 Location 对象属性 属性 描述 hash 设置或返回从井号 (#) 开始的 URL（锚）。 host 设置或返回主机名和当前 URL 的端口号。 hostname 设置或返回当前 URL 的主机名。 href 设置或返回完整的 URL。 pathname 设置或返回当前 URL 的路径部分。 port 设置或返回当前 URL 的端口号。 protocol 设置或返回当前 URL 的协议。 search 设置或返回从问号 (?) 开始的 URL（查询部分）。 Location 对象方法 属性 描述 assign() 加载新的文档。 reload() 重新加载当前文档。 replace() 用新的文档替换当前文档。 Location 对象描述Location 对象存储在 Window 对象的 Location 属性中，表示那个窗口中当前显示的文档的 Web 地址。它的 href 属性存放的是文档的完整 URL，其他属性则分别描述了 URL 的各个部分。这些属性与 Anchor 对象（或 Area 对象）的 URL 属性非常相似。当一个 Location 对象被转换成字符串，href 属性的值被返回。这意味着你可以使用表达式 location 来替代 location.href。 不过 Anchor 对象表示的是文档中的超链接，Location 对象表示的却是浏览器当前显示的文档的 URL（或位置）。但是 Location 对象所能做的远远不止这些，它还能控制浏览器显示的文档的位置。如果把一个含有 URL 的字符串赋予 Location 对象或它的 href 属性，浏览器就会把新的 URL 所指的文档装载进来，并显示出来。 除了设置 location 或 location.href 用完整的 URL 替换当前的 URL 之外，还可以修改部分 URL，只需要给 Location 对象的其他属性赋值即可。这样做就会创建新的 URL，其中的一部分与原来的 URL 不同，浏览器会将它装载并显示出来。例如，假设设置了Location对象的 hash 属性，那么浏览器就会转移到当前文档中的一个指定的位置。同样，如果设置了 search 属性，那么浏览器就会重新装载附加了新的查询字符串的 URL。 除了 URL 属性外，Location 对象的 reload() 方法可以重新装载当前文档，replace() 可以装载一个新文档而无须为它创建一个新的历史记录，也就是说，在浏览器的历史列表中，新文档将替换当前文档。 History对象History 对象包含用户（在浏览器窗口中）访问过的 URL。 History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。 注释：没有应用于 History 对象的公开标准，不过所有浏览器都支持该对象。 History 对象属性 属性 描述 length 返回浏览器历史列表中的 URL 数量。 History 对象方法 方法 描述 back() 加载 history 列表中的前一个 URL。 forward() 加载 history 列表中的下一个 URL。 go() 加载 history 列表中的某个具体页面。 History 对象描述History 对象最初设计来表示窗口的浏览历史。但出于隐私方面的原因，History 对象不再允许脚本访问已经访问过的实际 URL。唯一保持使用的功能只有 back()、forward() 和 go() 方法。 Screen对象Screen 对象包含有关客户端显示屏幕的信息。 注释：没有应用于 screen 对象的公开标准，不过所有浏览器都支持该对象。 Screen 对象属性 属性 描述 availHeight 返回显示屏幕的高度 (除 Windows 任务栏之外)。 availWidth 返回显示屏幕的宽度 (除 Windows 任务栏之外)。 bufferDepth 设置或返回调色板的比特深度。 colorDepth 返回目标设备或缓冲器上的调色板的比特深度。 deviceXDPI 返回显示屏幕的每英寸水平点数。 deviceYDPI 返回显示屏幕的每英寸垂直点数。 fontSmoothingEnabled 返回用户是否在显示控制面板中启用了字体平滑。 height 返回显示屏幕的高度。 logicalXDPI 返回显示屏幕每英寸的水平方向的常规点数。 logicalYDPI 返回显示屏幕每英寸的垂直方向的常规点数。 pixelDepth 返回显示屏幕的颜色分辨率（比特每像素）。 updateInterval 设置或返回屏幕的刷新率。 width 返回显示器屏幕的宽度。 Screen 对象描述每个 Window 对象的 screen 属性都引用一个 Screen 对象。Screen 对象中存放着有关显示浏览器屏幕的信息。JavaScript 程序将利用这些信息来优化它们的输出，以达到用户的显示要求。例如，一个程序可以根据显示器的尺寸选择使用大图像还是使用小图像，它还可以根据显示器的颜色深度选择使用 16 位色还是使用 8 位色的图形。另外，JavaScript 程序还能根据有关屏幕尺寸的信息将新的浏览器窗口定位在屏幕中间。 DOM Document每个载入浏览器的 HTML 文档都会成为 Document 对象。 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 Document 对象集合 集合 描述 all[] 提供对文档中所有 HTML 元素的访问。 anchors[] 返回对文档中所有 Anchor 对象的引用。 applets 返回对文档中所有 Applet 对象的引用。 forms[] 返回对文档中所有 Form 对象引用。 images[] 返回对文档中所有 Image 对象引用。 links[] 返回对文档中所有 Area 和 Link 对象引用。 Document 对象属性 属性 描述 body 提供对 元素的直接访问。对于定义了框架集的文档，该属性引用最外层的 。 cookie 设置或返回与当前文档有关的所有 cookie。 domain 返回当前文档的域名。 lastModified 返回文档被最后修改的日期和时间。 referrer 返回载入当前文档的文档的 URL。 title 返回当前文档的标题。 URL 返回当前文档的 URL。 Document 对象方法 方法 描述 close() 关闭用 document.open() 方法打开的输出流，并显示选定的数据。 getElementById() 返回对拥有指定 id 的第一个对象的引用。 getElementsByName() 返回带有指定名称的对象集合。 getElementsByTagName() 返回带有指定标签名的对象集合。 getElementsByClassName() 返回带有指定类名的对象集合 querySelector() 返回符合选择器的第一个元素 querySelectorAll() 返回符合选择器的所有元素 open() 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。 write() 向文档写 HTML 表达式 或 JavaScript 代码。 writeln() 等同于 write() 方法，不同的是在每个表达式之后写一个换行符。 DOM对象及其组成DOM分类核心DOM 公用接口处理树结构 XML DOM 操作XML文档 HTML DOM 操作HTML文档 HTML DOM事件模型 事件响应，让页面具有交互能力 CSS DOM 操作CSS样式 节点的类型文档节点 document 元素节点 element 属性节点 attrobute 文本节点 text DOM节点对象遍历节点parentNode 返回父亲节点 childNodes 返回所有子节点的集合 firstElementChild 返回大儿子元素节点 lastElementChild 返回小儿子元素节点 nextElementChild 返回下一个兄弟元素节点 previousElement 返回上一个兄弟元素节点 删除节点父节点.removeChild(子节点) 要被删除的节点.remove() 父节点.hasChildNodes 有子节点返回true,否则false 添加节点创建元素节点 document.createElement(“标签名称”) 创建文本节点 document.createTextNode(“文本内容”) 设置属性 节点.setAttribute(“属性名称”,”属性值”) 获取属性 节点.getAttribute(“属性名”) 替换节点父节点.replaceChild(新节点,旧节点) 节点.innerHTML=”HTML内容” 节点.innerText=”文本内容” 复制节点目标节点.cloneNode(是否克隆子节点和属性)","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JS基础知识整理（二）","slug":"JS基础知识整理（二）","date":"2018-08-27T06:32:30.000Z","updated":"2018-08-28T08:14:08.004Z","comments":true,"path":"2018/08/27/JS基础知识整理（二）/","link":"","permalink":"http://yoursite.com/2018/08/27/JS基础知识整理（二）/","excerpt":"","text":"引言 前一篇博客在讲JS中的变量，涉及到很多非常基础的概念，这边将会着重讲到JS中的对象。 JS对象JS对象JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…，此外，JavaScript 允许自定义对象。 JavaScript 提供多个内建对象，比如 String、Date、Array 等等。 对象只是带有属性和方法的特殊数据类型。所以我们早探讨一个对象时，就主要从它的属性和方法上研究。 JavaScript Array对象数组对象的作用是：使用单独的变量名来存储一系列的值。 这里不去过多的讲基础概念，而是将平时回用到的方法和属性例举出来： constructor属性constructor 属性返回对创建此对象的数组函数的引用。 语法 object.constructor 实例 在本例中，我们将展示如何使用 constructor 属性： 1234567891011function employee(name,job,born)&#123;this.name=name;this.job=job;this.born=born;&#125;var bill=new employee(\"Bill Gates\",\"Engineer\",1985);document.write(bill.constructor);//输出//function employee(name, jobtitle, born)//&#123;this.name = name; this.jobtitle = job; this.born = born;&#125; length属性length 属性可设置或返回数组中元素的数目。 语法arrayObject.length 数组的 length 属性总是比数组中定义的最后一个元素的下标大 1。对于那些具有连续元 素，而且以元素 0 开始的常规数组而言，属性 length 声明了数组中的元素的个数。 数组的 length 属性在用构造函数 Array() 创建数组时被初始化。给数组添加新元素时，如 果必要，将更新 length 的值。 设置 length 属性可改变数组的大小。如果设置的值比其当前值小，数组将被截断，其尾部 的元素将丢失。如果设置的值比它的当前值大，数组将增大，新的元素被添加到数组的尾部， 它们的值为 undefined。 concat()方法concat() 方法用于连接两个或多个数组。 该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本 语法 arrayObject.concat(arrayX,arrayX,......,arrayX) 参数 描述 arrayX 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。 实例 12var a = [1,2,3];document.write(a.concat(4,5)); //1,2,3,4,5 join()方法join() 方法用于把数组中的所有元素放入一个字符串。 元素是通过指定的分隔符进行分隔的。 语法arrayObject.join(separator) 参数 描述 separator 可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。 返回值 返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字 符串连接起来，在两个元素之间插入 separator 字符串而生成的。 实例 12345var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr.join())//George,John,Thomas pop()方法pop() 方法用于删除并返回数组的最后一个元素。 语法 arrayObject.pop() 返回值 arrayObject 的最后一个元素 说明 pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素 的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。 push()方法push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 语法 arrayObject.push(newelement1,newelement2,....,newelementX) 参数 描述 newelement1 必需。要添加到数组的第一个元素。 newelement2 可选。要添加到数组的第二个元素。 newelementX 可选。可添加多个元素。 返回值 把指定的值添加到数组后的新长度 说明 push() 方法可把它的参数顺序添加到 arrayObject 的尾部。它直接修改 arrayObject，而不 是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。 shift()方法shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 语法 arrayObject.shift() 返回值 数组原来的第一个元素的值。 unshift()方法unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 语法arrayObject.unshift(newelement1,newelement2,....,newelementX) 参数 描述 newelement1 必需。向数组添加的第一个元素。 newelement2 可选。向数组添加的第二个元素。 newelementX 可选。可添加若干个元素。 返回值 arrayObject 的新长度。 小结：如果是删除元素，返回该元素值，如果是增加元素，返回新的长度值；都是操作原数组，不会产生新数组 reverse()方法reverse() 方法用于颠倒数组中元素的顺序。 语法 arrayObject.reverse() 提示 该方法回改变原来的数组，而不会创建新数组 实例 123456var arr = new Array(3)arr[0] = \"George\"arr[1] = \"John\"arr[2] = \"Thomas\"document.write(arr + \"&lt;br /&gt;\") //George,John,Thomasdocument.write(arr.reverse()) //Thomas,John,George sort()方法sort() 方法用于对数组的元素进行排序。 语法arrayObject.sort(sortby) 参数 描述 sortby 可选。规定排序顺序。必须是函数。 返回值 对数组的引用。 请注意，数组在原数组上进行排序，不生成副本。 说明 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点， 是按照字符编码的顺序进行排序(ASCII编码)。要实现这一点，首先应把数组的元素都转换成字符串（如 有必要），以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个 用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：  若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。  若 a 等于 b，则返回 0。  若 a 大于 b，则返回一个大于 0 的值 实例 创建一个数组，并按字母顺序进行排序： 123456789var arr = new Array(6)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;arr[3] = &quot;James&quot;arr[4] = &quot;Adrew&quot;arr[5] = &quot;Martin&quot;document.write(arr + &quot;&lt;br /&gt;&quot;) //George,John,Thomas,James,Adrew,Martindocument.write(arr.sort()) //Adrew,George,James,John,Martin,Thomas 例2 我们将创建一个数组，并按字母顺序进行排序： 123456789var arr = new Array(6)arr[0] = &quot;10&quot;arr[1] = &quot;5&quot;arr[2] = &quot;40&quot;arr[3] = &quot;25&quot;arr[4] = &quot;1000&quot;arr[5] = &quot;1&quot;document.write(arr + &quot;&lt;br /&gt;&quot;) //10,5,40,25,1000,1document.write(arr.sort()) //1,10,1000,25,40,5 若需要以数字大小排序，就必须使用一个排序函数 12345678910111213function sortNumber(a,b)&#123;return a - b&#125;var arr = new Array(6)arr[0] = &quot;10&quot;arr[1] = &quot;5&quot;arr[2] = &quot;40&quot;arr[3] = &quot;25&quot;arr[4] = &quot;1000&quot;arr[5] = &quot;1&quot;document.write(arr + &quot;&lt;br /&gt;&quot;) //10,5,40,25,1000,1document.write(arr.sort(sortNumber)) //1,5,10,25,40,1000 slice()方法slice() 方法可从已有的数组中返回选定的元素。 语法 arrayObject.slice(start,end) 参数 描述 start 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。 也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定 该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负 数，那么它规定的是从数组尾部开始算起的元素。 返回值 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。 说明 请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应 该使用方法 Array.splice()。 注释：您可使用负值从数组的尾部选取元素。 注释：如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。 实例 1234567var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr + &quot;&lt;br /&gt;&quot;) //George,John,Thomasdocument.write(arr.slice(1) + &quot;&lt;br /&gt;&quot;) //John,Thomasdocument.write(arr) //George,John,Thomas splice()方法splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目，该方法非常强大，既可以删除数组元素也可以增加数组元素 注释：该方法会改变原始数组。 语法 arrayObject.splice(index,howmany,item1,.....,itemX) 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规 定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX 可选。向数组添加的新项目 返回值 类型 Array 描述 包含被删除项目的新数组，如果有的话 说明 splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多 个值来替换那些被删除的元素。 如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。 实例 12345678910var arr = new Array(6)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;arr[3] = &quot;James&quot;arr[4] = &quot;Adrew&quot;arr[5] = &quot;Martin&quot;document.write(arr + &quot;&lt;br /&gt;&quot;) //George,John,Thomas,James,Adrew,Martinarr.splice(2,0,&quot;William&quot;)document.write(arr + &quot;&lt;br /&gt;&quot;) //George,John,William,Thomas,James,Adrew,Martin toString()方法toString() 方法可把数组转换为字符串，并返回结果 语法 arrayObject.toString() 返回值 arrayObject 的字符串表示。返回值与没有参数的 join() 方法返回的字符串相同。 说明 当数组用于字符串环境时，JavaScript 会调用这一方法将数组自动转换成字符串。但是在某 些情况下，需要显式地调用该方法。 提示和注释 注释：数组中的元素之间用逗号分隔。 实例 12345var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr.toString()) //George,John,Thomas toLocaleString()方法把数组转换为本地字符串。 语法 arrayObject.toLocaleString() 返回值 arrayObject 的本地字符串表示。 说明 首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符 串连接起来，形成一个字符串。 实例 12345var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr.toLocaleString()) //George, John, Thomas toString和toLocaleString的区别 toString()方法获取的是String(传统字符串),而toLocaleString()方法获取的是LocaleString(本地环境字符串)。 如果你开发的脚本在世界范围都有人使用，那么将对象转换成字符串时请使用toString()方法来完成。 LocaleString()会根据你机器的本地环境来返回字符串，它和toString()返回的值在不同的本地环境下使用的符号会有微妙的变化。 所以使用toString()是保险的，返回唯一值的方法,它不会因为本地环境的改变而发生变化。如果是为了返回时间类型的数据，推荐使用LocaleString()。若是在后台处理字符串，请务必使用toString()。 valueOf()方法valueOf() 方法返回 Array 对象的原始值。 该原始值由 Array 对象派生的所有对象继承。 valueOf() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。 语法arrayObject.valueOf() JavaScript String对象String 对象描述字符串是 JavaScript 的一种基本的数据类型。 String 对象的 length 属性声明了该字符串中的字符数。 String 类定义了大量操作字符串的方法，例如从字符串中提取字符或子串，或者检索字符或 子串。 需要注意的是，JavaScript 的字符串是不可变的（immutable），String 类定义的方法都不能 改变字符串的内容。像 String.toUpperCase() 这样的方法，返回的是全新的字符串，而不是 修改原始字符串。 在较早的 Netscape 代码基的 JavaScript 实现中（例如 Firefox 实现中），字符串的行为就像 只读的字符数组。例如，从字符串 s 中提取第三个字符，可以用 s[2] 代替更加标准的 s.charAt(2)。此外，对字符串应用 for/in 循环时，它将枚举字符串中每个字符的数组下标（但 要注意，ECMAScript 标准规定，不能枚举 length 属性）。因为字符串的数组行为不标准， 所以应该避免使用它。 length属性length 属性可返回字符串中的字符数目。 语法 stringObject.length charAt() 方法charAt() 方法可返回指定位置的字符。 请注意，JavaScript 并没有一种有别于字符串类型的字符数据类型，所以返回的字符是长度 为 1 的字符串。 语法stringObject.charAt(index) 参数 描述 index 必需。表示字符串中某个位置的数字，即字符在字符串中的下标。 注释：字符串中第一个字符的下标是 0。如果参数 index 不在 0 与 string.length 之间，该 方法将返回一个空字符串。 concat() 方法concat() 方法用于连接两个或多个字符串。 语法stringObject.concat(stringX,stringX,...,stringX) 参数 描述 stringX 必需。将被连接为一个字符串的一个或多个字符串对象。 concat() 方法将把它的所有参数转换成字符串，然后按顺序连接到字符串 stringObject 的尾 部，并返回连接后的字符串。请注意，stringObject 本身并没有被更改。 stringObject.concat() 与 Array.concat() 很相似。 提示：请注意，使用 “ + “ 运算符来进行字符串的连接运算通常会更简便一些。 indexOf() 方法indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 语法 stringObject.indexOf(searchvalue,fromindex) 参数 描述 searchvalue 必需。规定需检索的字符串值。 fromindex 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。 注释：indexOf() 方法对大小写敏感！ 注释：如果要检索的字符串值没有出现，则该方法返回 -1。 replace() 方法replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配 的子串。 语法stringObject.replace(regexp/substr,replacement) 参数 描述 regexp/substr 必需。规定子字符串或要替换的模式的 RegExp 对象。 请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而 不是首先被转换为 RegExp 对象。 replacement 必需。一个字符串值。规定了替换文本或生成替换文本的函数。 返回值 一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的 。 说明 字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中 查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有 全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串 替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得 到的字符串将用于替换。 字符 替换文本 $1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 直接量符号。 实例 12var str=&quot;Visit Microsoft!&quot;document.write(str.replace(/Microsoft/, &quot;world&quot;)) //Visit world! substr() 方法substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。 语法stringObject.substr(start,length) 参数 描述 start 必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字 符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数 第二个字符，以此类推。 length 可 选 。 子 串 中 的 字 符 数 。 必 须 是 数 值 。 如 果 省 略 了 该 参 数 ， 那 么 返 回 从 stringObject 的开始位置到结尾的字串 。 返回值 一个 新的字 符串，包 含从 stringObject 的 start（包 括 start 所指 的字符 ） 处开 始 的 length 个字符。如果没有指定 length，那么返回的字符串包含从 start 到 stringObject 的结 尾的字符。 substring() 方法substring() 方法用于提取字符串中介于两个指定下标之间的字符。 语法 stringObject.substring(start,stop) 参数 描述 start 必需。一个非负的整数，规定要提取的子串的第一个字符在 stringObject 中的位 置。 stop 可选。一个非负的整数，比要提取的子串的最后一个字符在 stringObject 中的位 置多 1。 如果省略该参数，那么返回的子串会一直到字符串的结尾。 返回值 一个新的字符串，该字符串值包含 stringObject 的一个子字符串，其内容是从 start 处到 stop-1 处的所有字符，其长度为 stop 减 start。 说明 substring() 方法返回的子串包括 start 处的字符，但不包括 stop 处的字符。 如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如 果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。 重要事项：与 slice() 和 substr() 方法不同的是，substring() 不接受负的参数。 Number对象在 JavaScript 中，数字是一种基本的数据类型。JavaScript 还支持 Number 对象，该对象是 原始数值的包装对象。在必要时，JavaScript 会自动地在原始数据和对象之间转换。在 JavaScript 1.1 中，可以用构造函数 Number() 明确地创建一个 Number 对象，尽管这样做 并没有什么必要。 构造函数 Number() 可以不与运算符 new 一起使用，而直接作为转化函数来使用。以这种 方式调用 Number() 时，它会把自己的参数转化成一个数字，然后返回转换后的原始数值（或 NaN）。 构造函数通常还用作 5 个有用的数字常量的占位符，这 5 个有用的数字常量分别是可表示 的最大数、可表示的最小数、正无穷大、负无穷大和特殊的 NaN 值。 注意，这些值是构 造函数 Number() 自身的属性，而不是单独的某个 Number 对象的属性。 constructor属性constructor 属性返回对创建此对象的 Boolean 函数的引用。 语法 object.constructor MAX_VALUE属性MAX_VALUE 属性是 JavaScript 中可表示的最大的数。它的近似值为 1.7976931348623157 x 10308。 语法 Number.MAX_VALUE MIN_VALUE属性MIN_VALUE 属性是 JavaScript 中可表示的最小的数（接近 0 ，但不是负数）。它的近似值 为 5 x 10-324。 语法 Number.MIN_VALUE NaN属性NaN 属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对 象设置为该值，来指示其不是数字值。 提示：请使用 isNaN() 全局函数来判断一个值是否是 NaN 值。 语法 Number.NaN 说明 Number.NaN 是一个特殊值，说明某些算术运算（如求负数的平方根）的结果不是数字。方 法 parseInt() 和 parseFloat() 在不能解析指定的字符串时就返回这个值。对于一些常规情况 下返回有效数字的函数，也可以采用这种方法，用 Number.NaN 说明它的错误情况。 JavaScript 以 NaN 的形式输出 Number.NaN。请注意，NaN 与其他数值进行比较的结果总 是不相等的，包括它自身在内。因此，不能与 Number.NaN 比较来检测一个值是不是数字， 而只能调用 isNaN() 来比较。 在 ECMAScript v1 和其后的版本中，还可以用预定义的全局属性 NaN 代替 Number.NaN。 提示和注释 提示：请使用 isNaN() 来判断一个值是否是数字。原因是 NaN 与所有值都不相等，包括它 自己。 toString()方法toString() 方法可把一个 Number 对象转换为一个字符串，并返回结果。 语法 NumberObject.toString(radix) 参数 描述 radix 可选。规定表示数字的基数，是2 ~ 36 之间的整数。若省略该参数，则使用基数 10。 但是要注意，如果该参数是 10 以外的其他值，则 ECMAScript 标准允许实现返回 任意值。 返回值 数字的字符串表示。例如，当 radix 为 2 时，NumberObject 会被转换为二进制值表示的字 符串。 抛出 当调用该方法的对象不是 Number 时抛出 TypeError 异常。 toLocaleString() 方法toLocaleString() 方法可把一个 Number 对象转换为本地格式的字符串。 语法 NumberObject.toLocaleString() 返回值 数字的字符串表示，由实现决定，根据本地规范进行格式化，可能影响到小数点或千分位分 隔符采用的标点符号。 抛出 当调用该方法的对象不是 Number 时抛出 TypeError 异常。 toFixed()方法toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。 语法 NumberObject.toFixed(num) 参数 描述 num 必需。规定小数的位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实现可以支持更 大的数值范围。如果省略了该参数，将用 0 代替。 返回值 返回 NumberObject 的字符串表示，不采用指数计数法，小数点后有固定的 num 位数字。 如果必要，该数字会被舍入，也可以用 0 补足，以便它达到指定的长度。如果 num 大于 le+21，则该方法只调用 NumberObject.toString()，返回采用指数计数法表示的字符串。 抛出 当 num 太小或太大时抛出异常 RangeError。0 ~ 20 之间的值不会引发该异常。有些实现支 持更大范围或更小范围内的值。 当调用该方法的对象不是 Number 时抛出 TypeError 异常。 toExponential() 方法toExponential() 方法可把对象的值转换成指数计数法。 语法 NumberObject.toExponential(num) 参数 描述 num 必需。规定指数计数法中的小数位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实 现可以支持更大的数值范围。如果省略了该参数，将使用尽可能多的数字。 返回值 返回 NumberObject 的字符串表示，采用指数计数法，即小数点之前有一位数字，小数点之 后有 num 位数字。该数字的小数部分将被舍入，必要时用 0 补足，以便它达到指定的长 度。 抛出 当 num 太小或太大时抛出异常 RangeError。0 ~ 20 之间的值不会引发该异常。有些实现支 持更大范围或更小范围内的值。 当调用该方法的对象不是 Number 时抛出 TypeError 异常。 实例 12var num = new Number(10000);document.write (num.toExponential(1)) //1.0e+4 Boolean 对象constructor属性constructor 属性返回对创建此对象的 Boolean 函数的引用。 语法 object.constructor toString()方法toString() 方法可把一个逻辑值转换为字符串，并返回结果。 语法 booleanObject.toString() 返回值 根据原始布尔值或者 booleanObject 对象的值返回字符串 “true” 或 “false”。 抛出 如果调用该方法的对象不是 Boolean，则抛出异常 TypeError。 注释：在 Boolean 对象被用于字符串环境中时，此方法会被自动调用。 toSource()方法toSource() 方法返回表示对象源代码的字符串。 语法 object.toSource() 提示和注释 注释：该方法在 Internet Explorer 中无效。 实例 12345678function employee(name,job,born)&#123;this.name=name;this.job=job;this.born=born;&#125;var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);document.write(bill.toSource()); //(&#123;name:&quot;Bill Gates&quot;, job:&quot;Engineer&quot;, born:1985&#125;) valueOf()方法valueOf() 方法可返回 Boolean 对象的原始值。 语法 booleanObject.valueOf() 返回值 booleanObject 的原始布尔值。 抛出 如果调用该方法的对象不是 Boolean，则抛出异常 TypeError。 Date 对象Date 对象用于处理日期和时间。 创建 Date 对象的语法： var myDate=new Date() 注释：Date 对象会自动把当前日期和时间保存为其初始值。 Date 对象方法 方法 描述 Date() 返回当日的日期和时间。 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getFullYear() 从 Date 对象以四位数字返回年份。 getYear() 请使用 getFullYear() 方法代替。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。 getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。 getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。 getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。 getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。 getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。 parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。 setMonth() 设置 Date 对象中月份 (0 ~ 11)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setYear() 请使用 setFullYear() 方法代替。 setHours() 设置 Date 对象中的小时 (0 ~ 23)。 setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setTime() 以毫秒设置 Date 对象。 setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。 setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。 setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。 setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。 setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。 setUTCSeconds() 根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。 setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。 toSource() 返回该对象的源代码。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toDateString() 把 Date 对象的日期部分转换为字符串。 toGMTString() 请使用 toUTCString() 方法代替。 toUTCString() 根据世界时，把 Date 对象转换为字符串。 toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串。 toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 UTC() 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 valueOf() 返回 Date 对象的原始值。 Math对象Math 对象用于执行数学任务。 使用 Math 的属性和方法的语法： var pi_value=Math.PI; var sqrt_value=Math.sqrt(15); 注释：Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，不是某个对象的方法。您无需创建它，通过把 Math 作为 对象使用就可以调用其所有属性和方法。 Math 对象方法 方法 描述 abs(x) 返回数的绝对值。 acos(x) 返回数的反余弦值。 asin(x) 返回数的反正弦值。 atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。 ceil(x) 对数进行上舍入。 cos(x) 返回数的余弦。 exp(x) 返回 e 的指数。 floor(x) 对数进行下舍入。 log(x) 返回数的自然对数（底为e）。 max(x,y) 返回 x 和 y 中的最高值。 min(x,y) 返回 x 和 y 中的最低值。 pow(x,y) 返回 x 的 y 次幂。 random() 返回 0 ~ 1 之间的随机数。 round(x) 把数四舍五入为最接近的整数。 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根。 tan(x) 返回角的正切。 toSource() 返回该对象的源代码。 valueOf() 返回 Math 对象的原始值。","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"JS基础知识整理（一）","slug":"JS基础知识整理（一）","date":"2018-08-20T11:44:31.000Z","updated":"2018-08-27T09:00:49.142Z","comments":true,"path":"2018/08/20/JS基础知识整理（一）/","link":"","permalink":"http://yoursite.com/2018/08/20/JS基础知识整理（一）/","excerpt":"","text":"引言发现很多东西一段事件不使用的话，总会模糊，所以学习最好的方式就是自己形成系统的思路~ 自己也想通过博客的方式重头系统的整理一些知识，有不对的希望大家可以互相交流。 变量变量热身，数据存储在哪里？生活中越来越多的数据存储到计算机中，然而数据存储的位置又有所不同； 当变量存储在内存中时，是起到临时存储的作用，方便下次使用； 存储在硬盘中的变量，则是起到永久存储的作用； 还有数据库中变量，也是永久存储的一种方式，让调用时更加方便； 什么是变量？变量简单的说就是用于存储程序中变化的数据（也可以是常量，即值不变的数据） 变量介绍ECMAScript的变量是松散类型的，所谓松散型就是可以用来保存任何类型的数据,换句话说，每个变量仅仅是一个用于保存值的占位符而已。定义变量时使用var操作符，后跟变量名， 变量的命名规则区分大小写； 不能以数字开头，不能使用特殊字符； 不能使用保留字和关键词； 变量类型undefined类型undefined类型只有一个值，就是特殊的undefined，在使用var声明变量但未对其加以初始化的这个变量的值就是undefined; 123var meassage;alert(message); //undefinedalert(age); //产生错误 age is not defined Null类型Null是第二个只有一个值的数据类型，这个特殊的值就是null.从逻辑角度来看，null值表只是一个空对象指针，而这也正是使用typeof null 返回object的原因。 123var car=null;alert(typeof(car)); //objectalert(null == undefined); //true Boolean类型Boolean类型是ECMAScript中使用得最多得一种类型，该类型只有两个值：true和false. 在 JavaScript 中，布尔值是一种基本的数据类型。Boolean 对象是一个将布尔值打包的布尔对象。Boolean 对象主要用于提供将布尔值转换成字符串的 toString() 方法。 当调用 toString() 方法将布尔值转换成字符串时（通常是由 JavaScript 隐式地调用），JavaScript 会内在地将这个布尔值转换成一个临时的 Boolean 对象，然后调用这个对象的 toString() 方法。 Number类型Number 对象是 Number 原始类型的引用类型。要创建 Number 对象，采用下列代码： 1var oNumberObject = new Number(68); 所有特殊值都是 Number 对象的静态属性。 要得到数字对象的 Number 原始值，只需要使用 valueOf() 方法： 1var iNumber = oNumberObject.valueOf(); 当然，Number 类也有 toString() 方法，在讨论类型转换的小节中详细讨论该方法。 除了从 Object 对象继承的标准方法外，Number 对象还有几个处理数值的专用方法。 toFixed() 方法toFixed() 方法返回的是具有指定位数小数的数字的字符串表示。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toFixed(2)); //输出 &quot;68.00&quot; 在这里，toFixed() 方法的参数是 2，说明应该显示两位小数。该方法返回 “68.00”，空的字符串位由 0 来补充。对于处理货币的应用程序，该方法非常有用。toFixed() 方法能表示具有 0 到 20 位小数的数字，超过这个范围的值会引发错误。 toExponential() 方法与格式化数字相关的另一个方法是 toExponential()，它返回的是用科学计数法表示的数字的字符串形式。 与 toFixed() 方法相似，toExponential() 方法也有一个参数，指定要输出的小数的位数。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toExponential(1)); //输出 &quot;6.8e+1&quot; 这段代码的结果是 “6.8e+1”，前面解释过，它表示 6.8x101。问题是，如果不知道要用哪种形式（预定形式或指数形式）表示数字怎么办？可以用 toPrecision() 方法。 toPrecision() 方法toPrecision() 方法根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。例如， 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(1)); //输出 &quot;7e+1&quot; 这段代码的任务是用一位数字表示数字 68，结果为 “7e+1”，以另外的形式表示即 70。的确，toPrecision() 方法会对数进行舍入。不过，如果用 2 位数字表示 68，就容易多了： 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(2)); //输出 &quot;68&quot; 当然，输出的是 “68”，因为这正是该数的准确表示。不过，如果指定的位数多于需要的位数又如何呢？ 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(3)); //输出 &quot;68.0&quot; 在这种情况下，toPrecision(3) 等价于 toFixed(1)，输出的是 “68.0”。 toFixed()、toExponential() 和 toPrecision() 方法都会进行舍入操作，以便用正确的小数位数正确地表示一个数。 String类型String 对象的 valueOf() 方法和 toString() 方法都会返回 String 类型的原始值： 1alert(oStringObject.valueOf() == oStringObject.toString()); //输出 &quot;true&quot; 首先，两个方法 charAt() 和 charCodeAt() 访问的是字符串中的单个字符。这两个方法都有一个参数，即要操作的字符的位置。 charAt() 方法返回的是包含指定位置处的字符的字符串： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.charAt(1)); //输出 &quot;e&quot; 在字符串 “hello world” 中，位置 1 处的字符是 “e”。在“ECMAScript 原始类型”这一节中我们讲过，第一个字符的位置是 0，第二个字符的位置是 1，依此类推。因此，调用 charAt(1) 返回的是 “e”。 如果想得到的不是字符，而是字符代码，那么可以调用 charCodeAt() 方法： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.charCodeAt(1)); //输出 &quot;101&quot; 这个例子输出 “101”，即小写字母 “e” 的字符代码。 concat() 方法接下来是 concat() 方法，用于把一个或多个字符串连接到 String 对象的原始值上。该方法返回的是 String 原始值，保持原始的 String 对象不变： 1234var oStringObject = new String(&quot;hello &quot;);var sResult = oStringObject.concat(&quot;world&quot;);alert(sResult); //输出 &quot;hello world&quot;alert(oStringObject); //输出 &quot;hello &quot; 在上面这段代码中，调用 concat() 方法返回的是 “hello world”，而 String 对象存放的仍然是 “hello “。出于这种原因，较常见的是用加号（+）连接字符串，因为这种形式从逻辑上表明了真正的行为： 1234var oStringObject = new String(&quot;hello &quot;);var sResult = oStringObject + &quot;world&quot;;alert(sResult); //输出 &quot;hello world&quot;alert(oStringObject); //输出 &quot;hello &quot; indexOf() 和 lastIndexOf() 方法如果无法确定在某个字符串中是否确实存在一个字符，应该调用什么方法呢？这时，可调用 indexOf() 和 lastIndexOf() 方法。 indexOf() 和 lastIndexOf() 方法返回的都是指定的子串在另一个字符串中的位置，如果没有找不到子串，则返回 -1。 这两个方法的不同之处在于，indexOf() 方法是从字符串的开头（位置 0）开始检索字符串，而 lastIndexOf() 方法则是从字符串的结尾开始检索子串。例如 123var oStringObject = new String(&quot;hello world!&quot;);alert(oStringObject.indexOf(&quot;o&quot;)); 输出 &quot;4&quot;alert(oStringObject.lastIndexOf(&quot;o&quot;)); 输出 &quot;7&quot; 在这里，第一个 “o” 字符串出现在位置 4，即 “hello” 中的 “o”；最后一个 “o” 出现在位置 7，即 “world” 中的 “o”。如果该字符串中只有一个 “o” 字符串，那么 indexOf() 和 lastIndexOf() 方法返回的位置相同。 slice() 和 substring()ECMAScript 提供了两种方法从子串创建字符串值，即 slice() 和 substring()。这两种方法返回的都是要处理的字符串的子串，都接受一个或两个参数。第一个参数是要获取的子串的起始位置，第二个参数（如果使用的话）是要获取子串终止前的位置（也就是说，获取终止位置处的字符不包括在返回的值内）。如果省略第二个参数，终止位就默认为字符串的长度。 与 concat() 方法一样，slice() 和 substring() 方法都不改变 String 对象自身的值。它们只返回原始的 String 值，保持 String 对象不变。 12345var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.slice(&quot;3&quot;)); //输出 &quot;lo world&quot;alert(oStringObject.substring(&quot;3&quot;)); //输出 &quot;lo world&quot;alert(oStringObject.slice(&quot;3&quot;, &quot;7&quot;)); //输出 &quot;lo w&quot;alert(oStringObject.substring(&quot;3&quot;, &quot;7&quot;)); //输出 &quot;lo w&quot; instanceof 运算符在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。 instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。例如： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject instanceof String); //输出 &quot;true&quot; 这段代码问的是“变量 oStringObject 是否为 String 对象的实例？”oStringObject 的确是 String 对象的实例，因此结果是 “true”。尽管不像 typeof 方法那样灵活，但是在 typeof 方法返回 “object” 的情况下，instanceof 方法还是很有用的。 Object类型Object（对象）是在所有的编程语言中都十分重要的一个概念，对于事物我们可以把他们看作是一个对象，而每一个事物都有自己的表示的属性和对于某一信息作出的相应的操作。而这些东西就变成了事物的属性和方法。 在JS中我们可以见到的对象常量有如下的形式： 12345678910111213 1 var obj= &#123; 2 3 name:&quot;Arvin&quot;, 4 5 lastName:&quot;Huang&quot; , 6 7 whatsName:function()&#123; 8 9 alert(this.name+&quot; &quot;+this.lastName); 10 11 &#125;,12 13 &#125; 由上面的代码我们可以看出实际上在JS中的对象就是一个以键值对形式存储属性的一个集合，每一个属性有一个特定的名称，并与名称相对应的值。其实这种关系是有一个专有名称的，我们可以称之为映射，当然对于对象来说，除了可以通过这种方式来保持自有属性，还可以通过继承的方式来获取继承属性。这种方式我们称作“原型式继承”。 关于对象可以衍生的知识太多，不在这里做过多阐述，后续单独分出一节讲JS对象。 变量分类变量按照类型又可以分为基本数据类型和复杂数据类型 基本类型：ECMAScript中有5种简单数据类型（也称为基本数据类型），分别是：undefined,null,boolean,number和string。还有一种复杂数据类型—object,object本质上是由一组无序的名值对组成的。ECMAScript不支持任何创建自定义类型的机制，所有值都是上述6种数据类型之一。 区别基本类型和复杂数据类型的方式 第一：它们在内存种存放的位置不同。基本数据类型存储在内存的栈中，而反观复杂数据类型则不同，它的键名存储在栈中，而它的值存储在栈所对应的指针所指向的堆中，在这里也就形成了深浅拷贝的问题，即当我们复制一个复杂类型的数据时，操作的是堆中的同一个数据，下图可以很好的说明这点关系 第二：基本类型的数据不能新增属性和方法，引用类型可以 第三：使用类型判断方法。 ​ typeof操作符：使用方法typeof(变量) ​ “undefined”——-这个值未定义； ​ “boolean”——–这个值是布尔值； ​ “string”——–这个值是字符串； ​ “number”———这个值是数值； ​ “object”——–这个值是对象或者null； ​ “function”——–这个值是函数； 123var message = &quot;some string&quot;;alert(typeof(message)); //&quot;string&quot;alert(typeof(45)); //&quot;number&quot; 有些时候，typeof操作符会返回一些令人迷惑但技术上却正确的值，比如调用typeof null会返回“object”,因为特殊值null被认为一个空的对用引用。Safari5及之前版本,Chrome7及之前版本在对正则表达式调用typeof操作会返回“function”，而在其他浏览器会返回”object”。 数据类型的转换在JS中，数据类型的转换又分为强制转换和隐式转换。 强制转换方法： parseInt(变量名)：把数字部分转换为整数（开头字符不是数字，返回NAN） parseFloat(变量名):把数字部分转换为小数（开头字符不是数字，返回NAN） Number(变量名)：把纯数字字符串转换为数字（包含非数字，返回NAN） Boolean(变量名)：转换成布尔值 String(变量名)：转换成字符串 隐式转换方式由运算符控制（比如-,*,/）。 表作为参考, 来自js权威指南, 看过书的应该都记得这表： 原始类型和对象类型 转换成String: 转换成Number 转换成Boolean 转换成Object undefined “undefined” NaN false throws TypeError null “null” 0 false throws TypeError true “true” 1 new Boolean(true) false “false” 0 new Boolean(false) “” (empty string) 0 false new String(“”);Object(“”) “1.2” (nonempty, numeric) 1.2 true new String(“1.2”);Object(“1.2”) “one” (nonempty, non-numeric) NaN true new String(“one”);Object(“one”) 0 “0” false new Number(0);Object(0) -0 “0” false new Number(-0);Object(-0) NaN “undefined” false new Number(NaN);Object(NaN) Infinity “Infinity” true new Number(Infinity);Object(Infinity) -Infinity “-Infinity” true new Number(-Infinity);Object(-Infinity) 1 (finite, non-zero) “1” true new Number(1);Object(1) {} (any object) NaN true [] (empty array) “” 0 true [9] (1 numeric elt) “9” 9 true [‘a’] (any other array) use join() method NaN true function(){} (any function “undefined” NaN true","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"canvas基础","slug":"canvas基础","date":"2018-08-16T07:27:31.000Z","updated":"2018-08-16T08:51:04.167Z","comments":true,"path":"2018/08/16/canvas基础/","link":"","permalink":"http://yoursite.com/2018/08/16/canvas基础/","excerpt":"","text":"什么是 canvas? canvas是 HTML5 新增的，一个可以使用脚本(通常为JavaScript)在其中绘制图像的 HTML元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。 它最初由苹果内部使用自己MacOS X WebKit推出，供应用程序使用像仪表盘的构件和 Safari 浏览器使用。 后来，有人通过Gecko内核的浏览器 (尤其是Mozilla和Firefox)，Opera和Chrome和超文本网络应用技术工作组建议为下一代的网络技术使用该元素。 Canvas是由HTML代码配合高度和宽度属性而定义出的可绘制区域。JavaScript代码可以访问该区域，类似于其他通用的二维API，通过一套完整的绘图函数来动态生成图形。 Mozilla 程序从 Gecko 1.8 (Firefox 1.5)开始支持 canvas, Internet Explorer 从IE9开始canvas 。Chrome和Opera 9+ 也支持 canvas。 对于不能支持canvas的浏览器，可以采用提示的方法：123&lt;canvas id=&quot;clock&quot; width=&quot;150&quot; height=&quot;150&quot;&gt; &lt;img src=&quot;images/clock.png&quot; width=&quot;150&quot; height=&quot;150&quot; alt=&quot;&quot;/&gt;&lt;/canvas&gt; canvas基础使用一个画布在网页中是一个矩形框，通过 canvas元素来绘制.注意: 默认情况下 canvas元素没有边框和内容。 第一步：创建canvas实例&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;注意: 标签通常需要指定一个id属性 (脚本中经常引用), width 和 height 属性定义的画布的大小.提示:你可以在HTML页面中使用多个 canvas元素.使用 style 属性来添加边框:1&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;border:1px solid #000000;&quot;&gt; &lt;/canvas&gt; 第二步：找到canvas元素,创建context对象canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成：12var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); getContext(“2d”) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法，我们重点研究 2D渲染上下文 。（有机会再研究3D,又是截然不同的一种方式） 第三步：定义绘制方法 12ctx.fillStyle=&quot;#FF0000&quot;;ctx.fillRect(0,0,150,75); 设置fillStyle属性可以是CSS颜色，渐变，或图案。fillStyle 默认设置是#000000（黑色）。fillRect(x,y,width,height) 方法定义了矩形当前的填充方式。 Canvas 坐标canvas 是一个二维网格。canvas 的左上角坐标为 (0,0)上面的 fillRect 方法拥有参数 (0,0,150,75)。意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0)。 Canvas - 路径在Canvas上画线，我们将使用以下两种方法： moveTo(x,y) 定义线条开始坐标 lineTo(x,y) 定义线条结束坐标绘制线条我们必须使用到 “ink” 的方法，就像stroke().在canvas中绘制圆形, 我们将使用以下方法:1arc(x,y,r,start,stop) 实际上我们在绘制圆形时使用了 “ink” 的方法, 比如 stroke()描边 或者 fill()填充. Canvas - 文本使用 canvas 绘制文本，重要的属性和方法如下： font - 定义字体 fillText(text,x,y) - 在 canvas 上绘制实心的文本 strokeText(text,x,y) - 在 canvas 上绘制空心的文本使用 fillText():1234var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;);ctx.font=&quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,10,50); Canvas - 渐变渐变可以填充在矩形, 圆形, 线条, 文本等等, 各种形状可以自己定义不同的颜色。以下有两种不同的方式来设置Canvas渐变： createLinearGradient(x,y,x1,y1) - 创建线条渐变 createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变当我们使用渐变对象，必须使用两种或两种以上的停止颜色。addColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1.使用渐变，设置fillStyle或strokeStyle的值为 渐变，然后绘制形状，如矩形，文本，或一条线。使用 createLinearGradient():创建一个线性渐变。使用渐变填充矩形:123456789var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);// 创建渐变var grd=ctx.createLinearGradient(0,0,200,0);grd.addColorStop(0,&quot;red&quot;); grd.addColorStop(1,&quot;white&quot;); // 填充渐变ctx.fillStyle=grd;ctx.fillRect(10,10,150,80); 创建一个径向/圆渐变。使用渐变填充矩形：123456789var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);// 创建渐变var grd=ctx.createRadialGradient(75,50,5,90,60,100);grd.addColorStop(0,&quot;red&quot;); grd.addColorStop(1,&quot;white&quot;);// 填充渐变ctx.fillStyle=grd;ctx.fillRect(10,10,150,80); Canvas - 图像把一幅图像放置到画布上, 使用以下方法: drawImage(image,x,y)1234var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var img=document.getElementById(&quot;scream&quot;);ctx.drawImage(img,10,10);","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"移动端开发的兼容问题","slug":"移动端开发的兼容问题","date":"2018-08-12T10:44:18.000Z","updated":"2018-09-01T04:01:33.220Z","comments":true,"path":"2018/08/12/移动端开发的兼容问题/","link":"","permalink":"http://yoursite.com/2018/08/12/移动端开发的兼容问题/","excerpt":"","text":"前言这里总结一下移动端开发在android和ios不同情况下会遇到的兼容问题~后期陆续跟新补上 示例1、ios下input设置type=button属性disabled设置true,会出现样式文字和背景异常问题，使用opacity=1来解决 2、一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发，css增加cursor:pointer就搞定了 3、1px边框问题使用xx:before{content:’’;position: absolute;top: 0;left: 0;border: 1px solid #ccc;width: 200%;height: 200%;box-sizing:border-box;-webkit-box-sizing:border-box;-webkit-transform: scale(0.5);transform: scale(0.5);-webkit-transform-origin: left top;transform-origin: left top;} 4、input为fixed定位在ios下的bug问题，点击焦点input，input跳到中间位置，可以使用内容滚动框也是fixed来设置 5、移动端字体小于12px使用四周边框或者背景色块，安卓文字偏上bug问题，可以使用整体放大1倍再缩放，而且字体不要是奇数 6、在移动端图片上传图片 使用accept=”image/*” multiple,兼容低端机的问题 7、在h5嵌入app中，ios如果出现垂直滚动条时，手指滑动页面滚动之后，滚动很快停下来，好像踩着刹车在开车，有“滚动很吃力”的感觉self.webView.scrollView.decelerationRate = UIScrollViewDecelerationRateNormal;对webview设置了更低的“减速率” 8、click 300ms 延时响应 使用 Fastclickwindow.addEventListener( “load”, function() {FastClick.attach( document.body );}, false ); 9、input 有placeholder情况下不要设置行高，否则会偏上 10、移动端适配可以使用lib-flexible CSS伪类:active如果你想使用元素的伪类来实现 按下激活 状态，那么你需要知道以下问题： iOS上的几乎任何浏览器，定义元素的伪类 :active 都是无效； Android上，Android Browser 和 Chrome 都支持伪类 :active ，其它第三方浏览器有部分不支持； 定义了 :active 并且当前浏览器环境支持，当手指在滚动或者无意间的划过时，:active 状态都会被激活； 为了规避上述所有的问题，如果需要 按下激活 状态，推荐使用 js 新增一个 className 清除输入框内阴影iOS上的几乎任何浏览器输入框（input, textarea）默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭： 12345678910111213input,textarea &#123; /* 方法1: 去掉边框 */ border: 0; /* 方法2: 边框色透明 */ border-color: transparent; /* 方法3: 重置输入框默认外观 */ -webkit-appearance: none; appearance: none;&#125;复制代码 修正iOS输入框禁用文本色在 iOS 上，如果将输入框 disabled，此时输入框内的文字颜色将比 color 所定义的要浅，并且无法通过给输入框的伪类 :disabled 定义 color 来修正。 想解决这个问题，可以作如下设置，定义输入框的文本填充色： 1234input:disabled &#123; -webkit-text-fill-color: #000;&#125;复制代码 需要注意的是，在 Mac 上的 Safari 也有同样的问题。 Samsung S4圆角BugSamsung S4 手机在 Android Browser4.4.2 上（其他版本未测），如果你使用了 border-radius，并且使用了 -webkit-transform 属性，当使用了 translatez 或者 translate3d 值，圆角会出现问题： 1234567891011.test &#123; border: 2px solid red; width: 50px; height: 50px; border-radius: 50%; background-color: gray; box-shadow: 0 2px 5px rgba(0, 0, 0, .3); -webkit-transform: translate(0, 0) translatez(0); transform: translate(0, 0) translatez(0);&#125;复制代码 12&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;复制代码 如上代码，-webkit-transform: translate(0, 0) translatez(0) 将会导致圆角无法包裹住 background-color。 当然，-webkit-transform: translate3d(0, 0, 0) 也是一样的，所以如果你的某个场景是这样的，那么可以直接使用 -webkit-transform: translate(0, 0) 来避免这个问题。 边框圆角致背景溢出在红米和OPPO等手机某些版本的 Android Webview 中，如果一个元素定义了 border + border-radius，这时如果该元素有背景，那么背景将会溢出圆角之外。 之所以会出现这个问题：其主要原因是因为CSS对背景裁剪（background-clip）有不同的处理方式，通常它可以是 border-box | padding-box | content-box 这3种方式。 浏览器的默认裁减方式是 border-box，即溢出 border 之外的背景都将被裁减。 对于上述无法裁减边框之外背景的手机，将值定义为 padding-box | content-box 都能fix这问题，不过更推荐使用 padding-box。因为使用 content-box，如果定义了 padding 不为 0，背景将无法铺满元素。 fixed在IOS中不生效问题相信大家在做移动端项目时都会遇到fixed失效的问题，就是底部的按钮随着页面的滑动一起抖动，看起来像是抽搐一般，这个时候肯定就需要想办法解决了，在这里我们说的是在ios 下 。那么如何解决这个问题呢？这里有个小诀窍分享给大家。 其实有两种解决方案可以实现： 一种是将滚动区域和固定区域分开，不过要注意将按钮放在滚动区域外侧，代码如下 123456789101112131415&lt;body&gt; &lt;div class=\"header\"&gt;头部&lt;/div&gt; &lt;div class=\"main\"&gt; &lt;div class=\"content\"&gt; &lt;!-- 内容区域（可以滚动的区域） --&gt; &lt;/div&gt; &lt;/div&gt; &lt;footer class=\"footer\"&gt; &lt;!-- fixed定位的底部 --&gt; &lt;input type=\"text\" placeholder=\"请输入姓名\"&gt; &lt;/footer&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930313233343536.header,.footer,.main &#123; display: block; &#125; .header &#123; position: fixed; top: 0; left: 0; right: 0; height: 100px; &#125; .footer &#123; position: fixed; bottom: 0; left: 0; right: 0; height: 30px; &#125; .main &#123; /*main绝对定位，进行内部滚动*/ position: absolute; /*top是头部的高度*/ top: 100px; /*bottom是底部的高度*/ bottom: 30px; /*使之可以滚动*/ overflow-y: scroll; /*增加弹性滚动,解决滚动不流畅的问题*/ -webkit-overflow-scrolling: touch; &#125; .main .content &#123; height: 2000px; &#125; 另一种因为fixed在IOS中兼容不好，需要定位的话你可以采取absolute的方式进行定位。就不会出现该问题了。","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"兼容","slug":"兼容","permalink":"http://yoursite.com/tags/兼容/"}]},{"title":"Vue和微信小程序的区别和比较","slug":"Vue和微信小程序的区别和比较","date":"2018-08-04T14:47:23.000Z","updated":"2018-08-04T14:48:48.641Z","comments":true,"path":"2018/08/04/Vue和微信小程序的区别和比较/","link":"","permalink":"http://yoursite.com/2018/08/04/Vue和微信小程序的区别和比较/","excerpt":"","text":"引言写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。 一、生命周期先贴两张图： vue生命周期 小程序生命周期 相比之下，小程序的钩子函数要简单得多。 ue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。onLoad：页面加载 一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow：页面显示 每次打开页面都会调用一次。 onReady：页面初次渲染完成 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。 对界面的设置如 wx.setNavigationBarTitle请在 onReady之后设置。详见生命周期。 onHide：页面隐藏 当 navigateTo或底部tab切换时调用。 onUnload：页面卸载 当 redirectTo或 navigateBack的时候调用。 数据请求在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在 created或者 mounted中请求数据，而在小程序，会在 onLoad或者 onShow中请求数据。 二、数据绑定vue：vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例： 1&lt;img :src=&quot;imgSrc&quot;/&gt; 小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例： 1&lt;image src=&quot;&#123;&#123;imgSrc&#125;&#125;&quot;&gt;&lt;/image&gt; 三、列表渲染直接贴代码，两者还是有些相似： vue： 1&lt;ul id=&quot;example-1&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;var example1 = new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; items: [ &#123; message: &apos;Foo&apos; &#125;, &#123; message: &apos;Bar&apos; &#125; ] &#125;&#125;) 小程序： 1Page(&#123; data: &#123; items: [ &#123; message: &apos;Foo&apos; &#125;, &#123; message: &apos;Bar&apos; &#125; ] &#125;&#125;)&lt;text wx:for=&quot;&#123;&#123;items&#125;&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt; 四、显示与隐藏元素vue中，使用 v-if 和 v-show控制元素的显示和隐藏。 小程序中，使用 wx-if和 hidden控制元素的显示和隐藏。 五、事件处理vue：使用 v-on:event绑定事件，或者使用 @event绑定事件，例如： 1&lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;&lt;button v-on:click.stop=&quot;counter+=1&quot;&gt;Add1&lt;/button&gt; //阻止事件冒泡 小程序中，全用 bindtap(bind+event)，或者 catchtap(catch+event)绑定事件，例如： 1&lt;button bindtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt;&lt;button catchtap=&quot;noWork&quot;&gt;明天不上班&lt;/button&gt; //阻止事件冒泡 六、数据双向绑定1、设置值在vue中，只需要再表单元素上加上 v-model,然后再绑定 data中对应的一个值，当表单元素内容发生变化时， data中对应的值也会相应改变，这是vue非常nice的一点。 1&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;reason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos;/&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#app&apos;, data: &#123; reason:&apos;&apos; &#125;&#125;) 但是在小程序中，却没有这个功能。那怎么办呢？ 当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过 this.setData({key:value})来将表单上的值赋值给 data中的对应值。 下面是代码，可以感受一下： 1&lt;input bindinput=&quot;bindReason&quot; placeholder=&quot;填写理由&quot; class=&apos;reason&apos; value=&apos;&#123;&#123;reason&#125;&#125;&apos; name=&quot;reason&quot; /&gt;Page(&#123;data:&#123; reason:&apos;&apos;&#125;,bindReason(e) &#123; this.setData(&#123; reason: e.detail.value &#125;) &#125;&#125;) 当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的 v-model简直爽的不要不要的。 2、取值vue中，通过 this.reason取值。 小程序中，通过 this.data.reason取值。 七、绑定事件传参 在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如： 1&lt;button @click=&quot;say(&apos;明天不上班&apos;)&quot;&gt;&lt;/button&gt;new Vue(&#123; el: &apos;#app&apos;, methods:&#123; say(arg)&#123; consloe.log(arg) &#125; &#125;&#125;) 在 小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的 data-属性上，然后在方法中，通过 e.currentTarget.dataset.*的方式获取，从而完成参数的传递，很麻烦有没有… 1&lt;view class=&apos;tr&apos; bindtap=&apos;toApprove&apos; data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt;&lt;/view&gt;Page(&#123;data:&#123; reason:&apos;&apos;&#125;,toApprove(e) &#123; let id = e.currentTarget.dataset.id; &#125;&#125;) 八、父子组件通信1、子组件的使用在vue中，需要： 1、编写子组件 2、在需要使用的父组件中通过 import引入 3、在 vue的 components中注册 4、在模板中使用 1//子组件 bar.vue&lt;template&gt; &lt;div class=&quot;search-box&quot;&gt; &lt;div @click=&quot;say&quot; :title=&quot;title&quot; class=&quot;icon-dismiss&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123;props:&#123; title:&#123; type:String, default:&apos;&apos; &#125; &#125;&#125;,methods:&#123; say()&#123; console.log(&apos;明天不上班&apos;); this.$emit(&apos;helloWorld&apos;) &#125;&#125;&lt;/script&gt;// 父组件 foo.vue&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;bar :title=&quot;title&quot; @helloWorld=&quot;helloWorld&quot;&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bar from &apos;./bar.vue&apos;export default&#123;data:&#123; title:&quot;我是标题&quot;&#125;,methods:&#123; helloWorld()&#123; console.log(&apos;我接收到子组件传递的事件了&apos;) &#125;&#125;,components:&#123; Bar&#125;&lt;/script&gt; 在小程序中，需要： 1、编写子组件 2、在子组件的 json文件中，将该文件声明为组件 1&#123; &quot;component&quot;: true &#125; 3、在需要引入的父组件的 json文件中，在 usingComponents填写引入组件的组件名以及路径 1&quot;usingComponents&quot;: &#123; &quot;tab-bar&quot;: &quot;../../components/tabBar/tabBar&quot; &#125; 4、在父组件中，直接引入即可 1&lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt; 具体代码： 1// 子组件 &lt;!--components/tabBar/tabBar.wxml--&gt; &lt;view class=&apos;tabbar-wrapper&apos;&gt; &lt;view class=&apos;left-bar &#123;&#123;currentpage===&quot;index&quot;?&quot;active&quot;:&quot;&quot;&#125;&#125;&apos; bindtap=&apos;jumpToIndex&apos;&gt; &lt;text class=&apos;iconfont icon-shouye&apos;&gt;&lt;/text&gt; &lt;view&gt;首页&lt;/view&gt; &lt;/view&gt; &lt;view class=&apos;right-bar &#123;&#123;currentpage===&quot;setting&quot;?&quot;active&quot;:&quot;&quot;&#125;&#125;&apos; bindtap=&apos;jumpToSetting&apos;&gt; &lt;text class=&apos;iconfont icon-shezhi&apos;&gt;&lt;/text&gt; &lt;view&gt;设置&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 2、父子组件间通信在vue中 父组件向子组件传递数据，只需要在子组件通过 v-bind传入一个值，在子组件中，通过 props接收，即可完成数据的传递，示例： 1// 父组件 foo.vue&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;bar :title=&quot;title&quot;&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bar from &apos;./bar.vue&apos;export default&#123;data:&#123; title:&quot;我是标题&quot;&#125;,components:&#123; Bar&#125;&lt;/script&gt;// 子组件bar.vue&lt;template&gt; &lt;div class=&quot;search-box&quot;&gt; &lt;div :title=&quot;title&quot; &gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123;props:&#123; title:&#123; type:String, default:&apos;&apos; &#125; &#125;&#125;&lt;/script&gt; 子组件和父组件通信可以通过 this.$emit将方法和数据传递给父组件。 在小程序中 父组件向子组件通信和vue类似，但是小程序没有通过 v-bind，而是直接将值赋值给一个变量，如下： 1&lt;tab-bar currentpage=&quot;index&quot;&gt;&lt;/tab-bar&gt; 此处， “index”就是要向子组件传递的值。 在子组件 properties中，接收传递的值。 1properties: &#123; // 弹窗标题 currentpage: &#123; // 属性名 type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型） value: &apos;index&apos; // 属性初始值（可选），如果未指定则会根据类型选择一个 &#125; &#125; 子组件向父组件通信和 vue也很类似，代码如下： 1//子组件中methods: &#123; // 传递给父组件 cancelBut: function (e) &#123; var that = this; var myEventDetail = &#123; pickerShow: false, type: &apos;cancel&apos; &#125; // detail对象，提供给事件监听函数 this.triggerEvent(&apos;myevent&apos;, myEventDetail) //myevent自定义名称事件，父组件中使用 &#125;,&#125;//父组件中&lt;bar bind:myevent=&quot;toggleToast&quot;&gt;&lt;/bar&gt;// 获取子组件信息toggleToast(e)&#123; console.log(e.detail)&#125; 如果父组件想要调用子组件的方法vue会给子组件添加一个 ref属性，通过 this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如： 1//子组件&lt;bar ref=&quot;bar&quot;&gt;&lt;/bar&gt;//父组件this.$ref.bar.子组件的方法 小程序是给子组件添加 id或者 class，然后通过 this.selectComponent找到子组件，然后再调用子组件的方法,示例： 1//子组件&lt;bar id=&quot;bar&quot;&gt;&lt;/bar&gt;// 父组件this.selectComponent(&apos;#id&apos;).syaHello() 小程序和vue在这点上还是很相似的。 好了，关于微信小程序和VUE的对比就写到这里，未来微信小程序会越来越好，应用到更多成熟的技术。","categories":[],"tags":[{"name":"framework7","slug":"framework7","permalink":"http://yoursite.com/tags/framework7/"}]},{"title":"framework7学习总结-2","slug":"framework7学习总结-2","date":"2018-08-04T14:44:00.000Z","updated":"2018-08-04T14:45:15.921Z","comments":true,"path":"2018/08/04/framework7学习总结-2/","link":"","permalink":"http://yoursite.com/2018/08/04/framework7学习总结-2/","excerpt":"","text":"前言前面几篇介绍了 framework7的一些基础知识，现在介绍一下自己在使用过程中遇到的一些坑的地方，也能叫踩坑日记吧。 事件多次绑定问题不知道有没有在使用framework7的时候遇到过这个问题，从A页面开始，跳转到B页面，再次返回A页面的时候，页面绑定的事件会触发两次，这时候我就蒙蔽了，一开始我是以为出于页面机制原因，再次返回该页面的时候DOM重新加载，页面又存在缓存的问题，就会导致DOM节点存在多个，也就会触发多次事件，然后我就打印事件源节点，最终发现并不是这个原因。后来通过反复的找，最终发现是绑定事件时机不对，妈呀，这个坑可烦了我好一段时间，后来发现，每次返回页面都会重新绑定事件，就会导致页面点击时多次触发事件，触发次数决定于第几次加载此页，这个时候重新刷新页面可以解决这个问题，但是不可能每次都刷新页面，于是就把点击事件绑定时机由之前的pagereinit换为pageinit,问题也就迎刃而解了。 总之，绑定事件时，由于f7机制的不同，为了避免重复绑定事件，必需保证事件只绑定一次！而将绑定的回调放在除pageinit的其他时机，要么是导致页面触发多次事件，要么是导致事件绑定失败。","categories":[],"tags":[{"name":"framework7","slug":"framework7","permalink":"http://yoursite.com/tags/framework7/"}]},{"title":"framework7学习总结(1)","slug":"framework7学习总结-1","date":"2018-07-29T03:17:20.000Z","updated":"2018-07-29T04:09:28.810Z","comments":true,"path":"2018/07/29/framework7学习总结-1/","link":"","permalink":"http://yoursite.com/2018/07/29/framework7学习总结-1/","excerpt":"","text":"引言本篇主要讨论framework7的page和路由 page页面结构使用framework有着严格的布局要求，依次body&gt;div class=&quot;views&quot;&gt;div class=&quot;view&quot;&gt;div class=&quot;pages&gt;div class=&quot;page&quot;&gt;div class=&quot;page-content&quot;;必须依据此布局格式进行布局，否则会遇到很多意想不到的bug,比如页面不能正常返回和切换等等； 1234567891011121314151617181920212223242526272829&lt;body&gt; ... &lt;!-- Views --&gt; &lt;div class=&quot;views&quot;&gt; &lt;!-- Your main view --&gt; &lt;div class=&quot;view view-main&quot;&gt; &lt;!-- Pages --&gt; &lt;div class=&quot;pages&quot;&gt; &lt;div class=&quot;page&quot; data-page=&quot;home&quot;&gt; &lt;div class=&quot;page-content&quot;&gt; ... page content goes here ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Another view --&gt; &lt;div class=&quot;view another-view&quot;&gt; &lt;!-- Pages --&gt; &lt;div class=&quot;pages&quot;&gt; &lt;div class=&quot;page&quot; data-page=&quot;home-another&quot;&gt; &lt;div class=&quot;page-content&quot;&gt; ... page content goes here ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ...&lt;/body&gt; page事件掌握了常见了page事件能帮助我们更高效的开发app，现在我们看看页面浏览的时候最重要的一部分 - Page 事件。这些事件可以让我们通过JS来操作加载好的Page。 Event Target Description pageBeforeInit Page Element 当Framework7把新页面插入DOM的时候会触发 pageInit Page Element 当Framework7初始化页面的组件的时候会触发 pageReinit Page Element 当缓存页面可见时，将触发此事件。它只适用于内联页面（DOM缓存页）。 pageBeforeAnimation Page Element 当页面初始化完成并且可以做动画的时候触发 pageAfterAnimation Page Element 在页面动画完成之后触发 pageBeforeRemove Page Element Page从DOM中移除之前就会触发这个事件。如果你希望做一些解除事件绑定或者销毁一些插件的时候，这个方法是很有用的。 pageBack Page Element 在返回上一页动画执行之前就会触发这个事件。和 “pageBeforeAnimation” 的不同之处在于，这个事件在老页面上也会触发，也就是那个从中间滑动到右边的页面。 pageAfterBack Page Element 返回上一页动画执行完成之后触发这个事件。同样，区别于”pageAfterAnimation”，他也会在老页面上触发。 有两种方式可以使用这些事件： 12345678910// Option 1. Using one &apos;pageInit&apos; handler for all pages (recommended way):$$(document).on(&apos;pageInit&apos;, function (e) &#123; // Do something here when page loaded and initialized &#125;) // Option 2. Using live &apos;pageInit&apos; event handlers for each page (not recommended)$$(document).on(&apos;pageInit&apos;, &apos;.page[data-page=&quot;about&quot;]&apos;, function (e) &#123; // Do something here when page with data-page=&quot;about&quot; attribute loaded and initialized&#125;) 视图中页面切换的方法在视图中切换是非常常见的功能，官方也给我们提供了对应的API 在视图中主要有两个路由器方法: mainView.router.load(options) - 把一个页面加载到当前视图 mainView.router.back(options) - 这个方法会触发一个反向的动画并回到上一个页面，也就是浏览历史上的回退 上面这些方法都接受一个 options 对象作为参数，这个参数有如下属性: 参数 类型 说明 url string 需要加载的页面的URL content string or HTMLElement or [jQuery/Zepto/DOM7 collection] or [array of HTMLElement] 需要加载的动态页面的内容 pageName string 需要加载的页面的名称(data-page)。只用在内联页面(DOM cached)。 template function (Template7 compiled template) 需要加载并渲染的模板 context object or array 渲染Template7 模板时需要的上下文。这里有更多说明Template7 Pages。 contextName string 可选的。用来渲染 Template7 的 templatesData 的上下文名称/路径。这里查看更多说明 Template7 Pages query object Object with additionall query parameters that could be retreived in query object of Page Data force boolean 可选的。只对 back 方法有效。如果设置为 true，那么会忽略浏览历史中的上一个页面，而是直接加载指定的页面。 ignoreCache boolean 可选的。如果设置为 true ，那么会忽略URL对应的缓存，并且再次通过XHR来加载。 animatePages boolean 可选的。可以覆盖在 View 中的相同参数，打开/关闭页面切换的动画。 reload boolean 可选的。如果设置为 true，那么不会当做新页面加载，而是直接替换当前视图的当前页面。并且在视图浏览历史中替换最后一条历史。 reloadPrevious boolean 可选的。和 reload 一样，不过是对上一个页面。 pushState boolean 可选的。是否把浏览历史存储在浏览器的浏览历史中。(这样可以使用浏览器的后退/前进按钮） 注意， url, content, pageName 这三个参数，你只能同时使用一个。 视图中页面切换的快捷方式加载新页面的方法:mainView.router.loadPage(url) - 加载指定的页面到视图中。其实和你在页面中点击一个链接是一样的效果。 url - 需要加载的页面的URL mainView..router.loadContent(content) - 把动态生成的内容当做一个页面加载 content - string or HTMLElement or [jQuery/Zepto/DOM7 collection] or [array of HTMLElement] - 需要加载的内容 重新加载当前页面的方法:mainView.router.reloadPage(url) - 重新加载指定的页面到视图的当前页面。同时也会修改视图的浏览历史，把最后一条记录替换成指定的URL。 url - 需要加载页面的URL mainView.router.reloadContent(content) - 重新加载指定的内容到视图的当前页面。同时也会修改视图的浏览历史，把最后一条记录替换成指定的URL。 content - string or HTMLElement or [jQuery/Zepto/DOM7 collection] or [array of HTMLElement] - 需要加载的内容 重新加载上一个页面的方法（如果视图的DOM中有两个页面）：mainView.router.reloadPreviousPage(url) - 重新加载指定的页面到视图的上一个页面。同时也会修改视图的浏览历史，把最后一条记录替换成指定的URL。 url - 需要加载页面的URL mainView.router.reloadPreviousContent(content) - 重新加载指定的内容到视图的上一个页面。同时也会修改视图的浏览历史，把最后一条记录替换成指定的URL。 content - string or HTMLElement or [jQuery/Zepto/DOM7 collection] or [array of HTMLElement] - 需要加载内容 刷新页面的方法:mainView.router.refreshPage() - 刷新视图的当前页面。和你调用 .reloadPage 方法并且传入当前页面的URL是一样的效果 mainView.router.refreshPreviousPage() - 刷新视图的上一个页面。和你调用 .reloadPreviousPage 方法并且传入上一个页面的URL是一样的效果 路由Ajax Page我们有了一个有View和Page的应用结构，现在我们需要理解如何创建新的Page，以及Framework7是如何加载他们的。 下面有两个重要的地方请注意： p 默认情况下 Framework7 会使用 Ajax 加载所有的页面，除了带有 external class的链接（）和没有正确 href 值的链接（比如是空的或者是 #）。 p 在 初始化 时候传递不同的 ajaxLinks 参数可以改变这个行为。 所以我们如果需要创建一个链接指向 about.html，我们只需要按照平时一样写 &lt;a&gt;标签就可以： 1&lt;a href=&quot;about.html&quot;&gt;Go to About page&lt;/a&gt; 当我们点击这个链接的时候，Framework7会通过Ajax获取 about.html，解析它的内容，然后把它插入到DOM中，并且做一个动画切换到这个新页面。 Page 内部的结构因为Framework7有一个非常聪明的解析器，所以在内部页面中我们不需要完整的HTML结构（head,body,views,pages等)。比如 about.html 的内容： 1234&lt;-- That is all we have in about.html file --&gt;&lt;div class=&quot;page&quot; data-page=&quot;about&quot;&gt;... About page content goes here&lt;/div&gt; 重点是，Framework7 解析器会尝试在ajax加载的页面中寻找 &lt;div class=&quot;page&quot;&gt;，所以我们不需要完整的HTML结构。当然这不是强制的，你可以写出完整的页面结构。 取消/增加页面切换动画有时候你在加载页面或者后退的时候需要立刻执行，不想要一个切换的动画效果，可以通过增加一个 “no-animation” class 在链接上即可。 1234567&lt;div class=&quot;page&quot; data-page=&quot;about&quot;&gt; &lt;-- Add additional &quot;no-anmation&quot; class to link to diable animated page transition --&gt; &lt;a href=&quot;about.html&quot; class=&quot;no-animation&quot;&gt; Load About page immediately &lt;/a&gt; &lt;-- The same rule for back link --&gt; &lt;a href=&quot;index.html&quot; class=&quot;back no-animation&quot;&gt; Go back immediately &lt;/a&gt;&lt;/div&gt; 如果我们已经全局禁用了动画，但是在某些链接上希望启用这些动画，那么我们可以给链接加上 “with-animation” class。 1234567&lt;div class=&quot;page&quot; data-page=&quot;about&quot;&gt; &lt;!-- Add additional &quot;with-anmation&quot; class to link to enable animated page transition --&gt; &lt;a href=&quot;about.html&quot; class=&quot;with-animation&quot;&gt; Load About page with animation &lt;/a&gt; &lt;!-- The same rule for back link --&gt; &lt;a href=&quot;index.html&quot; class=&quot;back with-animation&quot;&gt; Go back with animation &lt;/a&gt;&lt;/div&gt; 通过 data 标签配置更多选项有时候我们希望在某些链接上有更多的配置，我们可以使用作为 data-属性来配置所有在 视图链接方法中的参数，比如： 12345678&lt;!-- Refresh currently active page (reload from server) --&gt;&lt;a href=&quot;about.html&quot; data-reload=&quot;true&quot; data-ignore-cache=&quot;true&quot;&gt;Refresh page&lt;/a&gt; &lt;!-- Go back but to another page, not to actual previous page in history. Such method also allows to jump back in history: --&gt;&lt;a href=&quot;about.html&quot; class=&quot;back&quot; data-force=&quot;true&quot;&gt;Back to About&lt;/a&gt; &lt;!-- Load new page without animation --&gt;&lt;a href=&quot;about.html&quot; data-animate-pages=&quot;false&quot;&gt;&lt;/a&gt; 结论Framework7 中，页面之间的链接和路由都是很简单的，你只需要记住： 你需要使用普通的 &lt;a&gt; 标签，她有一个href属性指向你需要加载的页面。 通过ajax加载的页面不需要有完整的HTML结构。只需要有 (和 如果你需要动态的滚动条) 如果你在同一个文件中有多个Page，把他们用 包裹起来，并且给每一个View设置好正确的class。 只需给一个链接加上 back class ()，她就会自动变成一个后退链接。 ###","categories":[],"tags":[{"name":"framework7","slug":"framework7","permalink":"http://yoursite.com/tags/framework7/"}]},{"title":"Hybrid App 和Native App开发对比","slug":"Hybrid-App-和Native-App开发对比","date":"2018-07-28T02:40:22.000Z","updated":"2018-07-29T02:37:23.092Z","comments":true,"path":"2018/07/28/Hybrid-App-和Native-App开发对比/","link":"","permalink":"http://yoursite.com/2018/07/28/Hybrid-App-和Native-App开发对比/","excerpt":"","text":"引言目前app开发市场需求量越来越大，此片文章主要涉及开发技术展开讨论。 智能手机之普及不用多说，手机APP渗投到各个行业：电商（淘宝、京东等）、金融（各手机行业、P2P借贷等）、医疗（智慧医疗）、交通（滴滴、Uber等）、教育（慕课网等）、餐饮（饿了吗、美团等）……反正只要是个企业，无论规模大小，都已经订制或将要订制自己的APP。这么多APP无外乎就三种模式：Native App、Web App、Hybrid App。 app的开发技术，目前流行的无非就是两种开发方式，原生和Html5。原生又分为安卓平台和IOS平台。 背景目前争论不休的问题，在早先前争论CS，BS架构的软件系统是一样一样的。原先BS，CS对用户而言的区别是需不需要安装客户端。BS是通过浏览器来访问，用PC，平板，Win，Mac都能访问，用户不需要下载额外的客户端，同时运维和升级提供很大的便利。CS则需要下载客户端软件，安装，然后登录使用，升级的话，要么升级链接库，要么重新安装升级包，比较不方便，优势是很多算法在本地运行，对服务器要求不高。 CS、BS之争是在PC端，那么现在原生和H5之争是在移动端。 那么评判一个APP用什么技术来开发呢？经过总结，可以有如下判断依据： 1.如果APP中出现大段文字（如新闻、攻略等），且格式比较丰富（如加粗，字体多样），那么用H5会比较方便。原因是原生开发解析json对字符串格式处理不算很好。 2.如果讲究APP反应速度（含页面切换流畅性），则选用原生开发，因为H5其本质是网页，换页时，基本要加载整个页面，就像是浏览器打开一个新页面一样，显得较慢，而原生系统则只加载变化部分。 3.如果APP对有无网络、网络优劣敏感（譬如有离线操作，在线操作），那么，基本选用原生开发，虽然H5可以做到，但是很复杂。 4.如果APP需要频繁调用硬件（摄像头、麦克风、未来的湿度检测仪等等）那么，基本选用原生开发，这样支持硬件更多，更容易扩展，且调用速度更快，H5就望尘莫及了。 5.如果APP用户常见页面频换，如（淘宝首页各种不同活动），那么用H5，维护起来更容易。 6.如果预算有限（H5开发一套可跨平台覆盖安卓、ios，黑莓、塞班），不是很讲究用户体验，不在乎加载速度，那非H5不可。 列举那么多，实际上有个采阴补阳的方法是H5+原生混合开发，对于固定格式、页面速度要求高，的模块（如PDB的即时通讯、宝典、我的项目）采用原生开发，对于新闻、大段文字、资讯类的（如信息广场、发表、问吧等）用H5页面来加载，将其嵌入到原生框架中那么，可以达到比较良好的体验。那么到底什么时混合式开发了，终于可以切入主题了。 三种开发方式1. Native AppNative App，原生APP，使用原生（即Android或iOS）开发的APP。两年多以前这非常流行，到现在为止，原生开发人员数量众多，一抓一大票，技术成熟，好多培训机构都抱着老掉牙的API翻来覆去的讲——尤其是Android。Sorry，说错话了……使用原生开发有其优势：应用的性能好，适配起来相对容易。学习成本要看人，个人觉得技术点不多，门槛相对稍高，但入门后学习起来就很轻松——网络资料实在是太多了。 但原生APP最头疼的有三个问题： 1、无法跨平台：Android和iOS都需要开发各自平台的版本——开发成本高； 2、升级麻烦：每次升级都要下载安装包，Android还好，反正不需要审核，下载就下载吧，但iOS就麻烦了，发布每个版本还得经过App Store的审核，这导致第三个问题； 3、Android和iOS很难同步发布。 2.Web App所谓的Web App，就是把手机当做一个浏览器（Android使用WebView，iOS使用UIWebView），做几个页面挂在服务器端，类似于一个小网站。这样说虽然不太贴切，但实际上给人的感觉就是这样的。虽然开发成本大大降低，但页面访问速度慢、操作体验差。于是第三种模式诞生了。 3.Hybrid App乍一看和Web App没啥差别，但涉及到的技术成本、开发成本、学习成本比Web App高，它综合了Web App的开发速度和Native App的高性能体验。之所以说学习成本高，是因为开发高性能的Hybrid App有难度，网络资料少。如何做好屏幕适配、提高UI响应速度、如何最大化使用原生功能等内容，网络几乎没有资料。网上能搜索到的都是很粗略的东西，或者就是Hello World级别的东西，涉及到稍微细节一点的东西几乎没有。由于本系列文章都只讲Hybrid，故在此不再啰嗦了。 在网上搜集到了关于三种开发方式的详细对比，如下表 特性 Native App Hybrid App Web App 开发语言 只用Native开发语言 Native和Web开发语言或只用Web开发语言 只用Web开发语言 代码移植性和优化 无 高 高 访问针对特定设备的特性 高 中 低 充分利用现有知识 低 高 高 高级图形 高 中 中 升级灵活性 低，总是通过应用升级 中，部分更新可不通过应用商店升级 高 安装体验 高，从应用商店安装 高，从应用商店安装 中，通过浏览器安装 混合开发概述Hybrid App主要以JS+Native两者相互调用为主，从开发层面实现“一次开发，多处运行”的机制，成为真正适合跨平台的开发。Hybrid App兼具了Native App良好用户体验的优势，也兼具了Web App使用HTML5跨平台开发低成本的优势。 目前已经有众多Hybrid App开发成功应用，比如美团、爱奇艺、微信等知名移动应用，都是采用Hybrid App开发模式。 混合开发应用场景 （1）折中考虑——如果企业使用 Hybrid 开发方法，就能集Native 和web两者之所长。一方面，Native 让开发者可以充分利用现代移动设备所提供的全部不同的特性和功能。另一方面，使用 Web 语言编写的所有代码都可以在不同的移动平台之间共享，使得开发和日常维护过程变得集中式、更简短、更经济高效。 （2）内部技能——许多企业都拥有Web 开发技能。如果选择 Hybrid 开发方法，在合适解决方案的支持下，Web 开发者只要仅仅运用 HTML、CSS 和 JavaScript 等 Web 技能，就能构建 App，同时提供 Native 用户体验。 （3）考虑未来——HTML5的可用性和功能都在迅速改进。许多分析师预测，它可能会成为开发前端 App 的默认技术。如果用 HTML 来编写 App 的大部分代码，并且只有在需要时才使用 Native 代码，公司就能确保他们今天的投入在明天不会变得过时，因为 HTML 功能变得更丰富，可以满足现代企业一系列更广泛的移动要求。 总结起来两句话： 纯Native的迭代太慢，不能动态更新，且不能跨平台 纯Web页，有很功能无法实现，有些动画效果实现其体验太差 因此我们需要Hybrid ps：怎样判断一个App的页面是native的还是web的？ Android手机 设置-&gt;开发者选项-&gt;显示布局边界 即可 混合开发app技术Hybrid App所需技术Hybrid App由于需要保证运行性能与开发速度，需要如下技术支持，本系列博文均会按照Demo的开发顺序依次描述本人的开发心得和教训，希望能起到一个抛砖引玉的作用。 Native技术Native技术主要用于提供原生支持，要做到跨平台，就需要掌握部分Android和iOS的知识，除了多线程，文件存储等基础知识，Android需要非常熟练的掌握WebView**、WebSettings、WebChromeClient、WebClient四大对象。iOS需要非常熟练掌握UIWebView**对象。 Web技术1、 HTML5熟练掌握HTML5的各个标签，如何编写最优的文档结构。 2、 CSS熟练掌握CSS2和CSS3的新特性，能按照效果图编写最高性能的样式。 使用SCSS生成CSS，将CSS可编程化。 3、 JavaScript实现业务逻辑控制。个人理解JavaScript主要包含两大内容：DOM编程和面向对象编程。大部分JS开发人员就只掌握DOM编程，诸如document.getElementById()等，但面向对象是很重要的一个方面。 4、 性能和开发模块化编程：编写可复用的组建； CSS渲染：了解浏览器的CSS渲染引擎才能编写更高效率的样式； JS解析：了解浏览器的JS解析引擎才能优化JS脚本； HTTP**协议**：熟练掌握HTTP请求的各个内容； AJAX：和服务器端的交互大都采用AJAX。 流行框架Hybrid 框架Cordova/PhoneGap：侧重于JS与原生的交互，开发简单，但性能差，如触摸时反应不灵敏。 AppCan：性能还行，使用简单，但要提交代码给AppCan的服务器才能打包，相信有追求的企业是不会把自己的代码提交给第三方，把打包权利交给第三方的。 Ionic Framework：在Cordova的基础上增加一些UI/JS方面的东西，样式还不错，但同样具有Cordova的不足。 UI/JS框架jQuery Mobile：上手简单，组件丰富，但性能超级差，闪屏现象严重。 Senche Touch：简单看过，没有使用过，貌似UI很漂亮，学习成本高。 React Native：FB推出的，当年FB是最早尝试Hybrid的，但性能超差，于是APP放弃了Hybrid，走原生的道路。在大家都不看好H5时，FB暗中深入挖掘H5，三年之后推出了这个框架，非常推荐各位去学习其中的思想。 GMU：百度推出的，这个不错。 Framework7 是一个开源免费的框架可以用来开发混合移动应用（原生和HTML混合）或者开发iOS7风格的WEB APP。也可以用来作为原型开发工具，可以迅速创建一个应用的原型。Framework7 最主要的功能是可以使用HTML、CSS和JS来开发iOS7应用。Framework7 是完全免费开源的。 Framework7 并不能兼容所有的设备。她只专注于为iOS7 提供最好的体验。 Framework7 或者叫 F7 是全功能的绑定 iOS 7 应用的 HTML 框架。Framework7 是免费开源的 HTML 移动端框架，用来开发混合移动端应用或者 iOS 7 的 Web 应用，并且带有 iOS 7 的原生外观和感觉。Framework7 也是独立的原型应用工具。 Framework7 使用 Javascript，CSS 和 HTML 来创建 iOS 7 应用，支持多个平台的迁移（PhoneGap），但是不是支持所有平台，主要还是针对 iOS 7。 UI/JS库这个就多了，jQuery、Zepto、Swiper、iScroll、RequireJS、AngularJS…… 个人建议由于移动端是一个重视性能和用户体验的终端，大量采用框架存在一些问题： 1、 扩展、维护、定制成本，这个非常需要考虑，或许框架提供的UI风格和自己设计的UI风格差异大，导致设计围绕框架转，不符合产品的需求。 2、 既然是框架，强调的是覆盖面广度和功能的全面，会有很多无用的东西，带来累赘； 3、 框架本身存在BUG，或许需要开发人员面对一些能力之外的问题。 好了，本篇文章就先介绍到这里，下篇文章再介绍关于Framework7一些使用中容易踩坑的地方。","categories":[],"tags":[{"name":"hybridApp 框架","slug":"hybridApp-框架","permalink":"http://yoursite.com/tags/hybridApp-框架/"}]},{"title":"整理一下framework7零散知识","slug":"framework7学习总结（入门篇）","date":"2018-07-21T04:35:13.000Z","updated":"2018-07-21T05:52:30.038Z","comments":true,"path":"2018/07/21/framework7学习总结（入门篇）/","link":"","permalink":"http://yoursite.com/2018/07/21/framework7学习总结（入门篇）/","excerpt":"","text":"引言最近在工作时遇到一个以前都没接触过的框架，Framework7,这里简单介绍一下最近一个月左右自己的理解。希望有理解不对的大家可以纠正。 之所以大家会选择Framework7，最根本的原因还是Framework7 是一个开源免费的框架。可以用来开发混合移动应用（原生和 HTML 混合）或者开发 iOS &amp; Android 风格的 WEB APP。也可以用来作为原型开发工具，可以迅速创建一个应用的原型。 开发自己的app是当前互联网公司必不可少的一种战略方式，而不同的公司考虑的角度和使用的用户又各有不同，这里再网上找到一副整理的很好的当前开发app的框架对比图，大家可以通过仔细对比，找到符合公司文化，最适合公司的移动端混合式开发框架，废话不多说了，上图 再来对于开发者而言，快速上手也算得上框架的一种优势，使用时只需要一个基本的 HTML 布局，并且把 Framework7 的 CSS 和 JS 文件引入即可！Framework7 不会强制你写任何自定义的标签，也不会通过 JS 来生成任何额外的内容。你不需要通过 JS 或者 JSON 来写页面，只需要普通的 HTML 就可以。 同时，Framework7 有大量可以直接使用的 UI 组件和工具，比如导航栏、侧边栏、弹出层、标签页、虚拟列表、日期控件、手风琴等。大部分的组件你都完全不需要写任何 JS 代码。具体参看官方文档,注意：现在Framework7已经更新到3.x的版本，目前用的最多的应该依然是2.x的版本，毋庸置疑，新出来的东西大多开发者都不会选择直接使用，而是等社区成熟，避免踩坑，不过这也是开发者边工作边进步的一种方式。走远了，现在回到正题，介绍一下Framework7框架的简单使用 入门级使用使用Framework7可以很方便创建你的web应用，有两种快速上手的办法： 你可以从example或者demo apps中选择一个应用并做修改成为自己的应用。也可以从头开始创建应用。 让我们看看如何从头开始创建一个应用: 下载安装Framework7首先，我们需要下载Framework7需要的所有文件： 可以从 Framework7 GitHub repository 上下载代码。 或者通过bower来安装: bower install framework7 在下载/安装好的目录下，我们需要的文件都在 dist 目录下 基本布局在这个基本APP中我们使用iOS主题。Android/Material 应用布局请参考App Layout 我们首选需要创建一个 index.html 文件。这是一个 iOS 单页应用，有一个 view, left panel 和 动态穿透布局的navbar 和 toolbar: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!-- Required meta tags--&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt; &lt;!-- Your app title --&gt; &lt;title&gt;My App&lt;/title&gt; &lt;!-- Path to Framework7 iOS CSS theme styles--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/framework7.ios.min.css&quot;&gt; &lt;!-- Path to Framework7 iOS related color styles --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/framework7.ios.colors.min.css&quot;&gt; &lt;!-- Path to your custom app styles--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/my-app.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- Status bar overlay for full screen mode (PhoneGap) --&gt; &lt;div class=&quot;statusbar-overlay&quot;&gt;&lt;/div&gt; &lt;!-- Panels overlay--&gt; &lt;div class=&quot;panel-overlay&quot;&gt;&lt;/div&gt; &lt;!-- Left panel with reveal effect--&gt; &lt;div class=&quot;panel panel-left panel-reveal&quot;&gt; &lt;div class=&quot;content-block&quot;&gt; &lt;p&gt;Left panel content goes here&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Views --&gt; &lt;div class=&quot;views&quot;&gt; &lt;!-- Your main view, should have &quot;view-main&quot; class --&gt; &lt;div class=&quot;view view-main&quot;&gt; &lt;!-- Top Navbar--&gt; &lt;div class=&quot;navbar&quot;&gt; &lt;div class=&quot;navbar-inner&quot;&gt; &lt;!-- We need cool sliding animation on title element, so we have additional &quot;sliding&quot; class --&gt; &lt;div class=&quot;center sliding&quot;&gt;Awesome App&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;!-- Right link contains only icon - additional &quot;icon-only&quot; class Additional &quot;open-panel&quot; class tells app to open panel when we click on this link --&gt; &lt;a href=&quot;#&quot; class=&quot;link icon-only open-panel&quot;&gt;&lt;i class=&quot;icon icon-bars-blue&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Pages container, because we use fixed-through navbar and toolbar, it has additional appropriate classes--&gt; &lt;div class=&quot;pages navbar-through toolbar-through&quot;&gt; &lt;!-- Page, &quot;data-page&quot; contains page name --&gt; &lt;div data-page=&quot;index&quot; class=&quot;page&quot;&gt; &lt;!-- Scrollable page content --&gt; &lt;div class=&quot;page-content&quot;&gt; &lt;p&gt;Page content goes here&lt;/p&gt; &lt;!-- Link to another page --&gt; &lt;a href=&quot;about.html&quot;&gt;About app&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Bottom Toolbar--&gt; &lt;div class=&quot;toolbar&quot;&gt; &lt;div class=&quot;toolbar-inner&quot;&gt; &lt;!-- Toolbar links --&gt; &lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;Link 1&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;Link 2&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Path to Framework7 Library JS--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;path/to/framework7.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Path to your app js--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;path/to/my-app.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 初始化APP我们写好布局，引用了 Framework7 的JS和CSS之后，我们需要初始化 APP 和 View. 在我们的 my-app.js 文件中这样写： 1234567891011// Initialize appvar myApp = new Framework7();// If we need to use custom DOM library, let's save it to $$ variable:var $$ = Framework7.$;// Add viewvar mainView = myApp.addView('.view-main', &#123; // Because we want to use dynamic navbar, we need to enable it for this view: dynamicNavbar: true&#125;); 再添加一个Page我们添加一个 “about app”页面，放在 about.html 文件中 这里需要注意的几个地方，避免大家踩坑 &lt;div class=&quot;pages&quot;&gt; 是page在同一个View中的容器. Pages 是必须的，因为所有的页面切换都在这里 ； 在 main layout(index.html) 中，每一个 Page 都应该放在 Pages 容器中(&lt;div class=&quot;pages&quot;&gt;)，而 Pages 必须是 View 的子元素(&lt;div class=&quot;view&quot;&gt;)。 你会发现每一个 page 都有一个 data-page 属性，存储了一个唯一的page名。这个属性不是必须的，但是强烈推荐使用。 这个属性在 page 事件中或者在page 回调函数中会非常有用，可以用来帮助我们确定加载的是哪一个页面。 所有的可见的内容，比如列表和表单等，都应该放在 &lt;div class=&quot;page-content&quot;&gt; 中，她是 &lt;div class=&quot;page&quot;&gt; 的子元素。这样才能保证正确的样式，布局和滚动。 12345678910111213141516171819202122232425&lt;!-- Top Navbar--&gt;&lt;div class=&quot;navbar&quot;&gt; &lt;div class=&quot;navbar-inner&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;back link&quot;&gt; &lt;i class=&quot;icon icon-back-blue&quot;&gt;&lt;/i&gt; &lt;span&gt;Back&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;center sliding&quot;&gt;About&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;link icon-only open-panel&quot;&gt;&lt;i class=&quot;icon icon-bars-blue&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;pages&quot;&gt; &lt;div data-page=&quot;about&quot; class=&quot;page&quot;&gt; &lt;div class=&quot;page-content&quot;&gt; &lt;div class=&quot;content-block&quot;&gt; &lt;p&gt;Here is About page!&lt;/p&gt; &lt;p&gt;Fusce eros lectus, accumsan eget mi vel, iaculis tincidunt felis. Nulla tincidunt pharetra sagittis. Fusce in felis eros. Nulla sit amet aliquam lorem, et gravida ipsum. Mauris consectetur nisl non sollicitudin tristique. Praesent vitae metus ac quam rhoncus mattis vel et nisi. Aenean aliquet, felis quis dignissim iaculis, lectus quam tincidunt ligula, et venenatis turpis risus sed lorem. Morbi eu metus elit. Ut vel diam dolor.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 给about页面添加JS代码假设我们需要在 about 页面中执行JS代码。因为 about.html 页面是通过JS加载的，我们不能通过在 about.html 中添加 script 标签的方式来添加JS代码，因为script标签会直接被忽略。Framework7 提供了简单的回调函数，我们可以在 my-app.js中使用： 12345678910111213141516171819202122232425262728293031// 初始化应用程序并将其存储到MyApp变量以进一步访问其方法var myApp = new Framework7();// 我们需要使用自定义DOM库，让我们把它保存到$$变量:var $$ = Framework7.$;// 添加视图var mainView = myApp.addView('.view-main', &#123; // Because we want to use dynamic navbar, we need to enable it for this view: dynamicNavbar: true&#125;);// 现在我们需要运行只针对页面执行的代码// 对于这种情况，我们需要为“pageInit”事件添加事件监听器// Option 1. 对所有页面使用“pageInit”事件处理程序（推荐方式）:$$(document).on('pageInit', function (e) &#123; // 从事件数据获取页面数据 var page = e.detail.page; if (page.name === 'about') &#123; // 下面的代码将针对data-page等于“about”的页执行 myApp.alert('Here comes About page'); &#125;&#125;)// Option 2. 对每个页面的“pageInit”事件注册处理程序$$(document).on('pageInit', '.page[data-page=\"about\"]', function (e) &#123; // 下面的代码将针对data-page等于“about”的页执行 myApp.alert('Here comes About page');&#125;) 打开页面 我们只需要在浏览器中输入 index.html 的地址即可。 因为Framework7是通过Ajax在不同页面间跳转的，所以你需要启动一个 http 服务器才可以（不要直接打开本地文件) 好了，到这一步就证明你已经学会初步使用framework7了，至于组件的使用的和其他核心库我们放到下一篇文章再讲。","categories":[],"tags":[{"name":"framework7","slug":"framework7","permalink":"http://yoursite.com/tags/framework7/"}]},{"title":"Markdown中文版编辑器Tyora","slug":"Markdown中文版编辑器Tyora","date":"2018-07-20T06:24:53.000Z","updated":"2018-07-20T06:24:59.920Z","comments":true,"path":"2018/07/20/Markdown中文版编辑器Tyora/","link":"","permalink":"http://yoursite.com/2018/07/20/Markdown中文版编辑器Tyora/","excerpt":"","text":"Typora(markdown编辑器)前言无意中发现了 Typora 这款 Markdown 编辑器。第一眼看上去它就像任何一款 Markdown 编辑器的同类，尤其是 Mou，但再看一眼，你就发现，它是如此的不同。 因为它将「写字」和「预览」这两件事情合并了，你输入的地方，也是输出的地方，即现在很流行的 WYSIWYG（What You See Is What You Get）。其实转念一想，这不就是回到了 Office Word 嘛，只不过编辑文本时不用再去工具栏上点选，一切的格式都能通过符号来控制。 用 Typora 官方的介绍视频，你就懂这一切是多么的自然。没错，所有的行内元素（如加粗、斜体）都会根据当前是否在编辑态而智能地在编辑态和预览态切换，而区块级元素（如标题、列表）则会在按下 Enter 后即时渲染，不能再次编辑。一切都变得如此干净、纯粹。接下来一起了解一下吧~ 概述Typora, the missing Markdown editor for web developers. 语法加粗强调strong or strong ( Cmd + B ) emphasize or emphasize ( Cmd + I ) Sometimes I want a lot of text to be bold.Like, seriously, a LOT of text 块引用 Right angle brackets &gt; are used for block quotes. 链接和电子邮件An email &#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#64;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d; link. Simple inline link http://chenluois.com, another inline link Smaller, one more inline link with title Resize. A reference style link. Input id, then anywhere in the doc, define the link with corresponding id: Titles ( or called tool tips ) in the links are optional. 图片An inline image , title is optional. A reference style image. 行内代码和块代码Inline code are surround by backtick key. To create a block code: Indent each line by at least 1 tab, or 4 spaces. var Mou = exactlyTheAppIwant; 有序列表Ordered lists are created using “1.” + Space: Ordered list item Ordered list item Ordered list item 无序列表Unordered list are created using “*” + Space: Unordered list item Unordered list item Unordered list item Or using “-“ + Space: Unordered list item Unordered list item Unordered list item Hard LinebreakEnd a line with two or more spaces will create a hard linebreak, called &lt;br /&gt; in HTML. ( Control + Return )Above line ended with 2 spaces. 水平线Three or more asterisks or dashes: 标题Setext-style: This is H1This is H2atx-style: This is H1This is H2This is H3This is H4This is H5This is H6附加语法Footnotes脚注主要像参考样式链接。一个脚注由两个东西组成：文本中的一个标记将成为一个上标数字；一个脚注定义，将放在文档结尾的脚注列表中。脚注看起来像这样： That’s some text with a footnote.[^1] [^1]: And that’s the footnote. 删除线Wrap with 2 tilde characters: Strikethrough 栅栏代码块Start with a line containing 3 or more backticks, and ends with the first line with the same number of backticks: 123Fenced code blocks are like Stardard Markdown’s regular codeblocks, except that they’re not indented and instead rely ona start and end fence lines to delimit the code block. 表格A simple table looks like this: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell If you wish, you can add a leading and tailing pipe to each line of the table: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell Specify alignment for each column by adding colons to separator lines: First Header Second Header Third Header Left Center Right Left Center Right","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"编辑器","slug":"编辑器","permalink":"http://yoursite.com/tags/编辑器/"}]},{"title":"Markdown简明版使用指南","slug":"Markdown简明版使用指南","date":"2018-07-19T04:53:53.000Z","updated":"2018-07-19T10:00:42.254Z","comments":true,"path":"2018/07/19/Markdown简明版使用指南/","link":"","permalink":"http://yoursite.com/2018/07/19/Markdown简明版使用指南/","excerpt":"","text":"简介Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 ###使用指南 标题标题能显示出文章的结构。行首插入1-6个 # ，每增加一个 # 表示更深入层次的内容，对应到标题的深度由 1-6 阶 文本样式（带“”星号的文本样式，在原版Markdown标准中不存在，但在其大部分衍生标准中被添加）链接 :Title加粗 :Bold斜体字 :Italics 高亮 :==text==段落 : 段落之间空一行换行符 : 一行结束时输入两个空格列表 :* 添加星号成为一个新的列表项。引用 :&gt; 引用内容内嵌代码 : alert(&#39;Hello World&#39;);画水平线 (HR) :——– 图片使用Markdown将图像插入文章，你需要在Markdown编辑器输入 。 这时在预览面板中会自动创建一个图像上传框。你可以从电脑桌面拖放图片(.png, .gif, .jpg)到上传框, 或者点击图片上传框使用标准的图像上传方式。 如果你想通过链接插入网络上已经存在的图片，只要单击图片上传框的左下角的“链接”图标，这时就会呈现图像URL的输入框。想给图片添加一个标题, 你需要做的是将标题文本插图中的方括号，e.g;. 插入图片有两种方式：行内式和参数式行内式 参数式[图片2]:(图片地址)用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的 ####区块引用比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句 语法 在之前加上“&gt;” 代码框这个就比较重要了，很多时候都需要展示出一些代码alert(&quot;nice ti meet you!&quot;)如果代码量比较少，只有单行的话，可以用单反引号包起来 多行用三个反引号，如果要写注释，可以在反引号后面写123function sum(a,b)&#123; return a+b;&#125; 华丽的分割线分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以 删除线只需要在文字前后加上两个~~ 使用链接就是这么简单 代码部分1234567891011//撤销申购$$(&quot;.clickbutton .waitfirstTrial&quot;).click(function()&#123; console.log(&quot;当前id&quot;,location.href.split(&quot;=&quot;)[1]); var orderId=location.href.split(&quot;=&quot;)[1]; Server.revokeApplypurchase(&#123;orderId:orderId&#125;,function(data)&#123; console.log(111111); &#125;); // Server.getShopcarNum(&#123; farmId: SYKTools.cookie(Server.currentFarmId) &#125;, // function (data) &#123;console.log(data)&#125; // )&#125;)","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-16T14:19:34.280Z","updated":"2018-07-16T14:19:34.280Z","comments":true,"path":"2018/07/16/hello-world/","link":"","permalink":"http://yoursite.com/2018/07/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}